*Domain.FP.Compile> print $ compileWithRanges "f = \\x y -> x"

ModuleR NoNameR (BodyR [DPatBindR (PVarR (IdentR "f" (RangeR (PositionR "Prelude" 1 1) (PositionR "Prelude" 1 2))) (RangeR (PositionR "Prelude" 1 1) (PositionR "Prelude" 1 2))) (RhsR (LambdaR [PVarR (IdentR "x" (RangeR (PositionR "Prelude" 1 6) (PositionR "Prelude" 1 7))) (RangeR (PositionR "Prelude" 1 6) (PositionR "Prelude" 1 7)),PVarR (IdentR "y" (RangeR (PositionR "Prelude" 1 8) (PositionR "Prelude" 1 9))) (RangeR (PositionR "Prelude" 1 8) (PositionR "Prelude" 1 9))] (VarR (IdentR "x" (RangeR (PositionR "Prelude" 1 13) (PositionR "Prelude" 1 14))) (RangeR (PositionR "Prelude" 1 13) (PositionR "Prelude" 1 14))) (RangeR (PositionR "Prelude" 1 5) (PositionR "Prelude" 1 14))) [] (RangeR (PositionR "Prelude" 1 3) (PositionR "Prelude" 1 14))) (RangeR (PositionR "Prelude" 1 1) (PositionR "Prelude" 1 14))] (RangeR (PositionR "Prelude" 1 1) (PositionR "Prelude" 1 14))) (RangeR (PositionR "Prelude" 1 1) (PositionR "Prelude" 1 14))


*Domain.FP.Compile> print $ compile "f = \\x y -> x"
Module NoName (Body [DPatBind (PVar (Ident "f")) (Rhs (Lambda [PVar (Ident "x"),PVar (Ident "y")] (Var (Ident "x"))) [])])


*Domain.FP.Compile> print $ compile "f = \\x -> \\y -> x"
Module NoName (Body [DPatBind (PVar (Ident "f")) (Rhs (Lambda [PVar (Ident "x")] (Lambda [PVar (Ident "y")] (Var (Ident "x")))) [])])


*Domain.FP.Compile> print $ compile "f = \\x -> \\y -> \\z -> x"
Module NoName (Body [DPatBind (PVar (Ident "f")) (Rhs (Lambda [PVar (Ident "x")] (Lambda [PVar (Ident "y")] (Lambda [PVar (Ident "z")] (Var (Ident "x"))))) [])])

*Domain.FP.Compile> print $ compile "f = \\x y z -> x"
Module NoName (Body [DPatBind (PVar (Ident "f")) (Rhs (Lambda [PVar (Ident "x"),PVar (Ident "y"),PVar (Ident "z")] (Var (Ident "x"))) [])])


expandLambdas (LambdaR (x:xs) body range) = LambdaR [x] (expandLambdas $ LambdaR xs body range) range
expandLambdas (LambdaR [] body _ = body

expandLambdas (LambdaR (x:xs) body range) = LambdaR [x] (foldr LambdaR body xs) range

*Domain.FP.Compile> expandLambdas $ LambdaR [PVarR (IdentR "x" (RangeR (PositionR "Prelude" 1 6) (PositionR "Prelude" 1 7))) (RangeR (PositionR "Prelude" 1 6) (PositionR "Prelude" 1 7)),PVarR (IdentR "y" (RangeR (PositionR "Prelude" 1 8) (PositionR "Prelude" 1 9))) (RangeR (PositionR "Prelude" 1 8) (PositionR "Prelude" 1 9))] (VarR (IdentR "x" (RangeR (PositionR "Prelude" 1 13) (PositionR "Prelude" 1 14))) (RangeR (PositionR "Prelude" 1 13) (PositionR "Prelude" 1 14))) (RangeR (PositionR "Prelude" 1 5) (PositionR "Prelude" 1 14))


LambdaR [PVarR (IdentR "x" (RangeR (PositionR "Prelude" 1 6) (PositionR "Prelude" 1 7))) (RangeR (PositionR "Prelude" 1 6) (PositionR "Prelude" 1 7))] (LambdaR [PVarR (IdentR "y" (RangeR (PositionR "Prelude" 1 8) (PositionR "Prelude" 1 9))) (RangeR (PositionR "Prelude" 1 8) (PositionR "Prelude" 1 9))] (VarR (IdentR "x" (RangeR (PositionR "Prelude" 1 13) (PositionR "Prelude" 1 14))) (RangeR (PositionR "Prelude" 1 13) (PositionR "Prelude" 1 14))) (RangeR (PositionR "Prelude" 1 5) (PositionR "Prelude" 1 14))) (RangeR (PositionR "Prelude" 1 5) (PositionR "Prelude" 1 14))


*Domain.FP.Compile> compile "f x y z = (x y) z"
Module NoName (Body [DFunBinds [FunBind Nothing (Ident "f") [PVar (Ident "x"),PVar (Ident "y"),PVar (Ident "z")] (Rhs (App (Paren (App (Var (Ident "x")) [Var (Ident "y")])) [Var (Ident "z")]) [])]])


*Domain.FP.Compile> compile "f x y z = x y z"
Module NoName (Body [DFunBinds [FunBind Nothing (Ident "f") [PVar (Ident "x"),PVar (Ident "y"),PVar (Ident "z")] (Rhs (App (Var (Ident "x")) [Var (Ident "y"),Var (Ident "z")]) [])]])

dropFromTail :: Int -> [a] -> [a]
dropFromTail n xs = 
 let l = zip xs [0..]
     cutoff = (length l) - n
     f (x,i) | i >= cutoff = []
             | i < cutoff = [x]
 in concatMap f l

expandApps (App f p@(x:y:xs)) = App (expandApps $ App (Paren $ App f [x]) (dropFromTail 1 (y:xs))) [(last p)]
expandApps (App f p@(x:xs))   = App f [x]

-- App (Var (Ident "x")) [Var (Ident "y"),Var (Ident "z"),Var (Ident "a"),Var (Ident "b")]
expandApps' (App f [x])     = App f [x]
expandApps' (App f (x:xs)) = App (expandApps' $ Paren (App f (dropFromTail 1 (x:xs)))) [(last xs)]
expandApps' (Paren x) = Paren (expandApps' x)

App (Paren (App (Paren (App (Paren (App (Var (Ident "x")) [Var (Ident "y")])) [Var (Ident "z")])) [Var (Ident "a")])) [Var (Ident "b")]


App (App (App (Paren (App (Var (Ident "x")) [Var (Ident "y")])) [Var (Ident "z")]) [Var (Ident "a")]) [Var (Ident "b")]



App (App (App (Paren (App (Paren (App (Var (Ident "x")) [Var (Ident "y")])) [Var (Ident "z")])) []) [Var (Ident "a")]) [Var (Ident "b")]


App (App (Paren (App (Var (Ident "x")) [Var (Ident "y")])) [Var (Ident "z")]) [Var (Ident "z")]


"f = let x = \"a\"\\n        y = \"b\"\\n    in x ++ y"

f = let x = "a"
        y = "b"
    in x ++ y

"f = let x = \"a\"\n    in let y = \"b\"\n       in x ++ y"

f = let x = "a"
    in let y = "b"
       in x ++ y

*Domain.FP.Compile> compile "f = let x = \"a\"\n        y = \"b\"\n    in x ++ y"
Module NoName (Body [DPatBind (PVar (Ident "f")) (Rhs (Let [DPatBind (PVar (Ident "x")) (Rhs (Lit (LString "a")) []),DPatBind (PVar (Ident "y")) (Rhs (Lit (LString "b")) [])] (InfixApp (JustExpr (Var (Ident "x"))) (Var (Operator "++")) (JustExpr (Var (Ident "y"))))) [])])

*Domain.FP.Compile> compile "f = let x = \"a\"\n    in let y = \"b\"\n       in x ++ y"
Module NoName (Body [DPatBind (PVar (Ident "f")) (Rhs (Let [DPatBind (PVar (Ident "x")) (Rhs (Lit (LString "a")) [])] (Let [DPatBind (PVar (Ident "y")) (Rhs (Lit (LString "b")) [])] (InfixApp (JustExpr (Var (Ident "x"))) (Var (Operator "++")) (JustExpr (Var (Ident "y")))))) [])])

expandLets (LetR (x:xs) e r) = LetR [x] (expandLets $ LetR xs e r) r
expandLets (LetR [] e _) = e

*Domain.FP.Compile> compile "f = [1,2,3]"
Module NoName (Body [DPatBind (PVar (Ident "f")) (Rhs (List [Lit (LInt 1),Lit (LInt 2),Lit (LInt 3)]) [])])

*Domain.FP.Compile> compile "f = 1:2:[3]"
Module NoName (Body [DPatBind (PVar (Ident "f")) (Rhs (InfixApp (JustExpr (Lit (LInt 1))) (Con (Operator ":")) (JustExpr (InfixApp (JustExpr (Lit (LInt 2))) (Con (Operator ":")) (JustExpr (List [Lit (LInt 3)]))))) [])])

expandLists (List (x:xs)

"f x = case x of\n       (x:xs) -> True\n       []     -> False"

f x = case x of
       (x:xs) -> True
       []     -> False

*Domain.FP.Debug> compile "f (True) = True"
Module NoName (Body [DFunBinds [FunBind Nothing (Ident "f") [PParen (PCon (Ident "True") [])] (Rhs (Con (Ident "True")) [])]])


*Domain.FP.Debug> compile "f ((:) x xs) = True"
Module NoName (Body [DFunBinds [FunBind Nothing (Ident "f") [PParen (PCon (Operator ":") [PVar (Ident "x"),PVar (Ident "xs")])] (Rhs (Con (Ident "True")) [])]])
*Domain.FP.Debug> 

"f x = g x\n where g = id"

f x = g x
 where g = id

"f = let (x:xs) = [1,2]\n    in xs"

f = let (x:xs) = [1,2]
    in xs

Module NoName (Body [DPatBind (PVar (Ident "f")) (Rhs (Let [DPatBind (PParen (PInfixCon (PVar (Ident "x")) (Operator ":") (PVar (Ident "xs")))) (Rhs (List [Lit (LInt 1),Lit (LInt 2)]) [])] (Var (Ident "xs"))) [])])

*Domain.FP.Debug> compile "f x = x\ng x = x\nz x = x"
Module NoName (Body [DFunBinds [FunBind Nothing (Ident "f") [PVar (Ident "x")] (Rhs (Var (Ident "x")) [])],DFunBinds [FunBind Nothing (Ident "g") [PVar (Ident "x")] (Rhs (Var (Ident "x")) [])],DFunBinds [FunBind Nothing (Ident "z") [PVar (Ident "x")] (Rhs (Var (Ident "x")) [])]])


f (x:y:xs) = [x]
f (x:[]) = []
f [] = []

Module NoName (Body [DFunBinds [FunBind Nothing (Ident "f") [PParen (PInfixCon (PVar (Ident "x")) (Operator ":") (PInfixCon (PVar (Ident "y")) (Operator ":") (PVar (Ident "xs"))))] (Rhs (List [Var (Ident "x")]) []),FunBind Nothing (Ident "f") [PParen (PInfixCon (PVar (Ident "x")) (Operator ":") (PCon (Special "[]") []))] (Rhs (Con (Special "[]")) []),FunBind Nothing (Ident "f") [PCon (Special "[]") []] (Rhs (Con (Special "[]")) [])]])



Lambda [PVar (Ident "p1"),PVar (Ident "p2"),PVar (Ident "p3")] (Case (Var (Ident "p1")) [Alt Nothing (PParen (PInfixCon (PVar (Ident "x")) (Operator ":") (PInfixCon (PVar (Ident "y")) (Operator ":") (PVar (Ident "xs"))))) (Rhs (Case (Var (Ident "p2")) *** Exception: Prelude.head: empty list

\p1 p2 p3 -> Case p1 of
              (x:y:xs) -> Case p2 


transformFunctions (Body (DFunBinds decls)) = 
 let allPats = collectPatterns decls
     collectPatterns = map (\(FunBind _ _ ps _) -> ps)
     collectRhs = map ((\FunBind _ _ _ rhs _) -> rhs)
     allRhs = collectRhs decls
     differentPats = filter (\x -> length x == 1) allPats
     allVars = ["p" ++ show i | i <- [1..length (head allPats)]]
     allMatches = map (\x -> Var $ Ident x) allVars
     allPats = map (\x -> PVar $ Ident x) allVars
 in Lambda allPats (constructCase allMatches allPats allRhs)

constructCase (m:ms) pats rhs = 
 let alts = head $ nub $ transpose pats
     nextVals = groupBy (\x y -> head x == head y) pats
     valsByAlt = (\(x:xs) -> zip x xs) $ map nub $ transpose nextVals
     altExprs = map (\pat -> Alt Nothing pat (constructCase ms (lookup pat valsByAlt) rhs)) alts
 in Case m altExprs
constructCase [m] [p] [r] = Case m [(Alt Nothing p r)]

"f (x:y:xs) = [x]\nf (x:[]) = []\nf [] = []"

f = let (x,y) = (1,2)
        (x:xs) = [1,2]
    in x

"f = let (x,y) = (1,2)\n        (x:xs) = [1,2]\n    in x"



f x = case x of
       (y:ys) -> x
       []     -> x

"f x = case x of\n       (y:ys) -> x\n       []     -> x"

