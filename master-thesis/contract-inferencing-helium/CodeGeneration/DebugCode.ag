imports
{
import qualified  Text.PrettyPrint as PP
import            Text.PrettyPrint.Boxes as BOX
}

include "Domain/FP/CodeGeneration/PrettyPrinting.ag"


{

-- Expects the code as a string and the point of entry.
showDebug :: String -> String -> IO ()
showDebug code pointOfEntry = 
 let topLevelEnv = generateImportEnv $ H.extractTypes $ H.compile' False code
     astCode = compileWithRanges code
     semModule = sem_ModuleR astCode
     inhModule = Inh_ModuleR pointOfEntry [] topLevelEnv
     wrapModule = wrap_ModuleR semModule inhModule
 in printBox (debug_Syn_ModuleR wrapModule)

showDebugExample1 :: IO ()
showDebugExample1 = showDebug "f x = g x\n  where g x = [x]\ng f x = f x" []

showDebugExample2 :: IO ()
showDebugExample2 = showDebug "f x = x\ng x = f [x]\nisort xs = foldr insert [] xs\n  where insert x [] = []\n        insert x (y:ys) = case x > y of\n                            True -> y : f x ys\n                            False -> x : g (y:ys)\n        f x ys = insert x ys\n        g ys = ys" []

showDebugExample3 :: IO ()
showDebugExample3 = showDebug "f x = n x\n  where n x = g x\ng x = x" []

showDebugExample4 :: IO ()
showDebugExample4 = showDebug "f x = x\ng x =\n    let\n        (z,zs) =\n            (f x,f [x]) in\n        zs" []

-- Shadowing test
showDebugExample5 :: IO ()
showDebugExample5 = showDebug "f x = (\\ y -> z x y)\n  where z x y = x y\nz x y = x y" []

-- AltR test
showDebugExample6 :: IO ()
showDebugExample6 = showDebug "g x = [x]\nf x = case (g x) of\n           (x:xs) -> let n = xs\n                     in n\n           []     -> error \"Test\"" []

-- PAsR test
-- PTupleR test
showDebugExample7 :: IO ()
showDebugExample7 = showDebug "f n@(x,y,z) = (g z,n)\n  where g = x y" []

-- Lambda test
showDebugExample8 :: IO ()
showDebugExample8 = showDebug "f x = (\\y -> let n = y\n             in n)" []
}

{
-- Prettyprinting helper functions

-- Generates a vertical line the height of a box.
makeVerticalLine :: Box -> Box
makeVerticalLine box = vcat BOX.left $ map text $ replicate (rows box) "|"

leftLine :: Box -> Box
leftLine box = (makeVerticalLine box) BOX.<+> box

leftLineNoSpace :: Box -> Box
leftLineNoSpace box = (makeVerticalLine box) BOX.<> box

rightLine :: Box -> Box
rightLine box = box BOX.<+> (makeVerticalLine box)

verticalLines :: Box -> Box
verticalLines = leftLine.rightLine

makeHorizontalLine :: Box -> Box
makeHorizontalLine = makeHorizontalLineWith "-"

makeHorizontalLineWith :: String -> Box -> Box
makeHorizontalLineWith s box = text $ concat $ replicate (cols box) s

topLine :: Box -> Box
topLine box = (makeHorizontalLine box) BOX.// box

bottomLine :: Box -> Box
bottomLine box = box BOX.// (makeHorizontalLine box)

horizontalLines :: Box -> Box
horizontalLines = (bottomLine.topLine)

horizontalLinesWith :: String -> Box -> Box
horizontalLinesWith s box =
 let l = makeHorizontalLineWith s box
 in l BOX.// box BOX.// l

-- Draws an ASCII box around a box.
drawBox :: Box -> Box
drawBox = verticalLines.horizontalLines


-- Replicates the indenting behaviour of original Text.PrettyPrint
nest :: Int -> Box -> Box
nest i box = 
 let indent = emptyBox (rows box) i
 in hcat BOX.left [indent,box]


}

-- Some pretty-printed debug code so we can have a look at what's going on at each node in the AST.
attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
  syn  debug     use {BOX.//}         {nullBox}      :: Box

-- Debug info synthesis
sem ModuleR
  | ModuleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "ModuleR"
                                                ,  text "Available contracts:"            BOX.<+> vcat BOX.left @loc.debugContracts
                                                ,  nest 2 @body.debug
                                                ]
     loc  .debugContracts               = map (\(nm,ctrt) -> hcat BOX.left [pprint nm,text " : ",pprint ctrt]) ((DM.toList @loc.newContracts)::[(String,Contract)])

sem BodyR
  | BodyR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "BodyR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  nest 2 @decls.debug
                                                ]
  | BHoleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "BHoleR"
                                                ]

sem RhsR
  | RhsR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "RhsR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "Generated types by where-clause:"       BOX.<+> text (show @loc.types)
                                                ,  text "Available contracts:"            BOX.<+> vcat BOX.left @loc.debugContracts
                                                ,  text "Number of contracts:" BOX.<+> pprint ( length (DM.toList @loc.newContractEnv))
                                                ,  nest 2 @where.debug
                                                ,  nest 2 @expr.debug
                                                ]
     loc  .debugContracts               = map (\(nm,ctrt) -> hcat BOX.left [pprint nm,text " : ",pprint ctrt]) ((DM.toList @loc.newContractEnv)::[(String,Contract)])


  | GRhsR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "RhsR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "Generated types by where-clause:"       BOX.<+> text (show @loc.types)
                                                ,  text "Available contracts:"            BOX.<+> vcat BOX.left @loc.debugContracts

                                                ,  nest 2 @where.debug
                                                ,  nest 2 @gexprs.debug
                                                ]
     loc  .debugContracts               = map (\(nm,ctrt) -> hcat BOX.left [pprint nm,text " : ",pprint ctrt]) ((DM.toList @loc.newContractEnv)::[(String,Contract)])

sem DeclR
  | DHoleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "DHoleR"
                                                ]
  | DEmptyR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "DEmptyR"
                                                ]
  | DFunBindsR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "DFunBindsR"
                                                ,  nest 2 @funbinds.debug
                                                ]
  | DPatBindR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "DPatBindR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "is top-level:"          BOX.<+> pprint @lhs.isTopLevel
                                                ,  text "local idents known to RHS:"          BOX.<+> pprint @loc.localIdentifiers
                                                ,  nest 2 @pat.debug
                                                ,  nest 2 @rhs.debug
                                                ]

sem ExprR
  | HoleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "HoleR"
                                                ]
  | FeedbackR
     lhs   .debug                       = @expr.debug
  | MustUseR
     lhs   .debug                       = @expr.debug
  | CaseR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "CaseR"
                                                ,  nest 2 @expr.debug
                                                ,  nest 2 @alts.debug
                                                ]
  | ConR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "ConR"
                                                ,  nest 2 @name.debug
                                                ]

  | IfR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "IfR"
                                                ,   nest 2 @cond.debug
                                                ,   nest 2 @then.debug
                                                ,   nest 2 @else.debug
                                                ]

  | InfixAppR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "InfixAppR"
                                                ,  nest 2 @left.debug
                                                ,  nest 2 @op.debug
                                                ,  nest 2 @right.debug
                                                ]
  | LambdaR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "LambdaR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "pattern types:"         BOX.<+> text (show @loc.functionHeliumTypes)
                                                ,  text "local idents known to expr:"          BOX.<+> pprint @loc.localIdentifiers
                                                ,  nest 2 @pats.debug
                                                ,  nest 2 @expr.debug
                                                ]

  | LetR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "LetR"
                                                ,   text "Contracts:"            BOX.<+> vcat BOX.left @loc.debugContracts
                                                ,   nest 2 @decls.debug
                                                ,   nest 2 @expr.debug
                                                ]
     loc  .debugContracts               = map (\(nm,ctrt) -> hcat BOX.left [pprint nm,text " : ",pprint ctrt]) ((DM.toList @loc.newContractEnv)::[(String,Contract)])

  | LitR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "LitR"
                                                ,  nest 2 @lit.debug
                                                ]

  | AppR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "AppR"
                                                ,  nest 2 @fun.debug
                                                ,  nest 2 @args.debug
                                                ]

  | ParenR
     lhs   .debug                       = @expr.debug

  | TupleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "TupleR"
                                                ,  nest 2 @exprs.debug
                                                ]

  | VarR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "VarR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "orig ident:"            BOX.<+> pprint @name.copy
                                                ,  text "updated ident:"         BOX.<+> pprint @loc.updatedName
                                                ,  text "point of entry:"        BOX.<+> text @lhs.entryFunction
                                                ,  text "local idents:"          BOX.<+> pprint @lhs.localIdentifiers
                                                ]

  | EnumR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "EnumR"
                                                ,  nest 2 @from.debug
                                                ,  nest 2 @then.debug
                                                ,  nest 2 @to.debug
                                                ]

  | ListR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "ListR"
                                                ,  nest 2 @exprs.debug
                                                ]

sem MaybeExprR
  | NoExprR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "NoExprR"
                                                ]
  | JustExprR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "JustExprR"
                                                ,  nest 2 @expr.debug
                                                ]




sem AltR
  | AHoleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "AHoleR"
                                                ]
  | AltEmptyR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "AltEmptyR"
                                                ]

  | AltR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "AltR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "pattern types:"     BOX.<+> text (show @loc.patternTypes)
                                                ,  text "local idents known to RHS"          BOX.<+> pprint @loc.localIdentifiers
                                                ,  nest 2 @pat.debug
                                                ,  nest 2 @rhs.debug
                                                ]

sem FunBindR
  | FBHoleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "FBHoleR"
                                                ]
  | FunBindR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "FunBindR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "Helium type:"           BOX.<+> text (show @loc.heliumType)
                                                ,  text "pattern types:"     BOX.<+> text (show @loc.patternTypes)
                                                ,  text "orig ident:"            BOX.<+> pprint @name.copy
                                                ,  text "updated ident:"         BOX.<+> pprint @loc.updatedName
                                                ,  text "point of entry:"        BOX.<+> text @lhs.entryFunction
                                                ,  text "local idents known to RHS:"          BOX.<+> pprint @loc.localIdentifiers
                                                ,  nest 2 @name.debug
                                                ,  nest 2 @pats.debug
                                                ,  nest 2 @rhs.debug
                                                ]

sem PatR
  | PHoleR
     lhs    .debug                      = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "PHoleR"
                                                ]
  | PConR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "PConR",
                                                   nest 2 @name.debug,
                                                   nest 2 @pats.debug
                                                ]
    
  | PInfixConR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "PInfixConR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "local patterns:"        BOX.<+> pprint @loc.localPatterns
                                                ,  nest 2 @left.debug
                                                ,  nest 2 @name.debug
                                                ,  nest 2 @right.debug
                                                ]

  | PListR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "PListR",
                                                   nest 2 @pats.debug
                                                ]

  | PLitR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "PLitR",
                                                   nest 2 @lit.debug
                                                ]

  | PTupleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "PTupleR",
                                                   nest 2 @pats.debug
                                                ]

  | PVarR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "PVarR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "local patterns:"        BOX.<+> pprint @loc.localPatterns
                                                ,  nest 2 @name.debug
                                                ]
   | PAsR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "PAsR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "local patterns:"        BOX.<+> pprint @loc.localPatterns
                                                ,  nest 2 @name.debug
                                                ,  nest 2 @pat.debug
                                                ]

  | PWildcardR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "PWildcardR"
                                                ]


sem LiteralR
  | LCharR LFloatR LIntR LStringR
     lhs   .debug                       = pprint @val

sem NameR
  | IdentR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "IdentR"
                                                ,  text "name:"                  BOX.<+> text @name
                                                ]
  | OperatorR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "OperatorR"
                                                ,  text "name:"                  BOX.<+> text @name
                                                ]
  | SpecialR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "SpecialR"
                                                ,  text "name:"                  BOX.<+> text @name
                                                ]
