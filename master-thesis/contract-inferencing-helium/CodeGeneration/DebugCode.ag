imports
{
import qualified  Text.PrettyPrint as PP
import            Text.PrettyPrint.Boxes as BOX

-- TEST
import qualified  StaticAnalysis.Inferencers.TypeInferencing as TYPINF
import qualified  Main.Args as HELIUMARGS
import qualified  StaticAnalysis.Miscellaneous.ConstraintInfo as CONSTRINFO
import qualified  StaticAnalysis.Miscellaneous.DoublyLinkedTree as DLNKTREE
}

include "Domain/FP/CodeGeneration/PrettyPrinting.ag"

include "Domain/FP/CodeGeneration/FlatDebugCode.ag"


{
-- TEST
debugTypeInferencing :: [HELIUMARGS.Option] -> IE.ImportEnvironment -> H.Module -> CONSTRINFO.InfoTree 
debugTypeInferencing options importEnv module_ =
   let res = TYPINF.wrap_Module (TYPINF.sem_Module module_) TYPINF.Inh_Module {
       	         TYPINF.importEnvironment_Inh_Module = importEnv,
		 TYPINF.options_Inh_Module = options }          
   in (TYPINF.infoTree_Syn_Module res)

doDebugTypeInferencing m = debugTypeInferencing [HELIUMARGS.Overloading, HELIUMARGS.UseTutor] IE.emptyEnvironment m

{-
-- TEST
typeSchemesInInfoTree :: FixpointSubstitution -> Predicates -> CONSTRINFO.InfoTree -> CONSTRINFO.InfoTree
typeSchemesInInfoTree subst ps infoTree =
   let local = attribute infoTree
       rest  = concatMap (typeSchemesInInfoTree subst ps) (children infoTree)
   in case assignedType local of 
         Just tp -> let is     = ftv tp 
                        ps'    = filter (any (`elem` is) . ftv) ps
                        scheme = generalizeAll (subst |-> (ps' .=>. tp))
                    in DLNKTREE.DoublyLinkedTree CONSTRINFO.InfoTree  (rangeOfSource (self local), scheme) : rest
         Nothing -> rest
-}

{-

*Domain.FP.CodeGeneration.CodeGeneration> :t TYPINF.proximaTypeInferencing [HELIUMARGS.Overloading, HELIUMARGS.UseTutor] IE.emptyEnvironment  $ (either error id $ H.compile "f x = g x\n  where g x = [x]\ng f x = f x")
TYPINF.proximaTypeInferencing [HELIUMARGS.Overloading, HELIUMARGS.UseTutor] IE.emptyEnvironment  $ (either error id $ H.compile "f x = g x\n  where g x = [x]\ng f x = f x")
  :: (StaticAnalysis.Messages.TypeErrors.TypeErrors,
      StaticAnalysis.Messages.Warnings.Warnings,
      IE.TypeEnvironment,
      [(Range, S.TpScheme)])
*Domain.FP.CodeGeneration.CodeGeneration> :t (\(_,_,_,x) -> x) $ TYPINF.proximaTypeInferencing [HELIUMARGS.Overloading, HELIUMARGS.UseTutor] IE.emptyEnvironment  $ (either error id $ H.compile "f x = g x\n  where g x = [x]\ng f x = f x")
(\(_,_,_,x) -> x) $ TYPINF.proximaTypeInferencing [HELIUMARGS.Overloading, HELIUMARGS.UseTutor] IE.emptyEnvironment  $ (either error id $ H.compile "f x = g x\n  where g x = [x]\ng f x = f x")
  :: [(Range, S.TpScheme)]
*Domain.FP.CodeGeneration.CodeGeneration> 
*Domain.FP.CodeGeneration.CodeGeneration> (\(_,_,_,x) -> x) $ TYPINF.proximaTypeInferencing [HELIUMARGS.Overloading, HELIUMARGS.UseTutor] IE.emptyEnvironment  $ (either error id $ H.compile "f x = g x\n  where g x = [x]\ng f x = f x")
[((1,3),a),((1,7),[a]),((1,7),a -> [a]),((1,9),a),((2,11),a),((2,15),[a]),((2,16),a),((3,3),a -> b),((3,5),a),((3,9),a),((3,9),a -> b),((3,11),a)]
*Domain.FP.CodeGeneration.CodeGeneration> (\(_,_,_,x) -> x) $ TYPINF.proximaTypeInferencing [HELIUMARGS.Overloading, HELIUMARGS.UseTutor] IE.emptyEnvironment  $ (either error id $ H.compile "f x = x\ng x = f [x]\nisort xs = foldr insert [] xs\n  where insert x [] = []\n        insert x (y:ys) = case x > y of\n                            True -> y : f x ys\n                            False -> x : g (y:ys)\n        f x ys = insert x ys\n        g ys = ys")
[((1,3),a),((1,7),a),((2,3),a),((2,7),[a]),((2,7),[a] -> [a]),((2,9),[a]),((2,10),a),((3,7),a),((3,12),a),((3,12),(a -> b -> c) -> d -> e -> f),((3,18),a -> b -> c),((3,25),a),((3,28),a),((4,16),a),((4,18),a),((4,23),a),((5,16),a),((5,19),a),((5,19),a),((5,21),a),((5,27),a),((5,32),a),((5,32),a),((5,34),a -> b -> c),((5,36),a),((6,29),a),((6,37),a),((6,37),a),((6,39),a -> b -> b),((6,41),a),((6,41),a -> b -> c),((6,43),a),((6,45),a),((7,29),a),((7,38),a),((7,38),a),((7,40),a -> b -> c),((7,42),a),((7,42),a -> a),((7,45),a),((7,45),a),((7,46),a -> b -> c),((7,47),a),((8,11),a),((8,13),a),((8,18),a),((8,18),a -> b -> c),((8,25),a),((8,27),a),((9,11),a),((9,16),a)]


-}
}

{

flatDebug :: String -> String -> IO ()
flatDebug code pointOfEntry = 
 let noFreeLambdaCode = removeFreeLambdas code pointOfEntry
     topLevelEnv = generateImportEnv $ H.extractTypes $ H.compile' False (show noFreeLambdaCode)
     semModule = sem_ModuleR noFreeLambdaCode
     inhModule = Inh_ModuleR pointOfEntry [] topLevelEnv 0
     wrapModule = wrap_ModuleR semModule inhModule
 in do putStrLn (simpledebug_Syn_ModuleR wrapModule)

convertPatBindToFunBind :: String -> String -> ModuleR
convertPatBindToFunBind code pointOfEntry = 
 let topLevelEnv = generateImportEnv $ H.extractTypes $ H.compile' False code
     astCode = compileWithRanges code
     semModule = sem_ModuleR astCode
     inhModule = Inh_ModuleR pointOfEntry [] topLevelEnv 0
     wrapModule = wrap_ModuleR semModule inhModule
 in patBindToFunBind_Syn_ModuleR wrapModule

removeFreeLambdas :: String -> String -> ModuleR
removeFreeLambdas code pointOfEntry = 
 let convertedPatBinds = convertPatBindToFunBind code pointOfEntry
     topLevelEnv = generateImportEnv $ H.extractTypes $ H.compile' False code
     semModule = sem_ModuleR convertedPatBinds
     inhModule = Inh_ModuleR pointOfEntry [] topLevelEnv 0
     wrapModule = wrap_ModuleR semModule inhModule
 in removeFreeLambdas_Syn_ModuleR wrapModule

-- Expects the code as a string and the point of entry.
showDebug :: String -> String -> IO ()
showDebug code pointOfEntry = 
 let noFreeLambdaCode = removeFreeLambdas code pointOfEntry
     topLevelEnv = generateImportEnv $ H.extractTypes $ H.compile' False (show noFreeLambdaCode)
     semModule = sem_ModuleR noFreeLambdaCode
     inhModule = Inh_ModuleR pointOfEntry [] topLevelEnv 0
     wrapModule = wrap_ModuleR semModule inhModule
 in do printBox (debug_Syn_ModuleR wrapModule)
       writeFile "debugOutput" (render $ debug_Syn_ModuleR wrapModule)


showDebugExample1 :: IO ()
showDebugExample1 = showDebug "f x = g x\n  where g x = [x]\ng f x = f x" []

showDebugExample2 :: IO ()
showDebugExample2 = showDebug "f x = x\ng x = f [x]\nisort xs = foldr insert [] xs\n  where insert x [] = []\n        insert x (y:ys) = case x > y of\n                            True -> y : f x ys\n                            False -> x : g (y:ys)\n        f x ys = insert x ys\n        g ys = ys" []

showDebugExample3 :: IO ()
showDebugExample3 = showDebug "f x = n x\n  where n x = g x\ng x = x" []

showDebugExample4 :: IO ()
showDebugExample4 = showDebug "f x = x\ng x =\n    let\n        (z,zs) =\n            (f x,f [x]) in\n        zs" []

-- Shadowing test
showDebugExample5 :: IO ()
showDebugExample5 = showDebug "f x = (\\ y -> z x y)\n  where z x y = x y\nz x y = x y" []

-- AltR test
showDebugExample6 :: IO ()
showDebugExample6 = showDebug "g x = [x]\nf x = case (g x) of\n           (x:xs) -> let n = xs\n                     in n\n           []     -> error \"Test\"" []

-- PAsR test
-- PTupleR test
showDebugExample7 :: IO ()
showDebugExample7 = showDebug "f n@(x,y,z) = (g z,n)\n  where g = x y" []

-- Lambda test
showDebugExample8 :: IO ()
showDebugExample8 = showDebug "f x = (\\y -> let n = y\n             in n)" []

}


{
-- Prettyprinting helper functions

-- Generates a vertical line the height of a box.
makeVerticalLine :: Box -> Box
makeVerticalLine box = vcat BOX.left $ map text $ replicate (rows box) "|"

leftLine :: Box -> Box
leftLine box = (makeVerticalLine box) BOX.<+> box

leftLineNoSpace :: Box -> Box
leftLineNoSpace box = (makeVerticalLine box) BOX.<> box

rightLine :: Box -> Box
rightLine box = box BOX.<+> (makeVerticalLine box)

verticalLines :: Box -> Box
verticalLines = leftLine.rightLine

makeHorizontalLine :: Box -> Box
makeHorizontalLine = makeHorizontalLineWith "-"

makeHorizontalLineWith :: String -> Box -> Box
makeHorizontalLineWith s box = text $ concat $ replicate (cols box) s

topLine :: Box -> Box
topLine box = (makeHorizontalLine box) BOX.// box

bottomLine :: Box -> Box
bottomLine box = box BOX.// (makeHorizontalLine box)

horizontalLines :: Box -> Box
horizontalLines = (bottomLine.topLine)

horizontalLinesWith :: String -> Box -> Box
horizontalLinesWith s box =
 let l = makeHorizontalLineWith s box
 in l BOX.// box BOX.// l

-- Draws an ASCII box around a box.
drawBox :: Box -> Box
drawBox = verticalLines.horizontalLines


-- Replicates the indenting behaviour of original Text.PrettyPrint
nest :: Int -> Box -> Box
nest i box = 
 let indent = emptyBox (rows box) i
 in hcat BOX.left [indent,box]


}

-- Some pretty-printed debug code so we can have a look at what's going on at each node in the AST.
attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
  syn  debug     use {BOX.//}         {nullBox}      :: Box

-- Debug info synthesis
sem ModuleR
  | ModuleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "ModuleR"
                                                ,  text "Available types:"                BOX.<+> text (show @loc.types)
                                                ,  text "Available contracts:"            BOX.<+> vcat BOX.left @loc.debugContracts
                                                ,  text "Final code:"                     BOX.<+> pprint @body.functionAppSelf
                                                ,  nest 2 @body.debug
                                                ]
     loc  .debugContracts               = map (\(nm,ctrt) -> hcat BOX.left [pprint nm,text " : ",pprint ctrt]) ((DM.toList @loc.newContracts)::[(String,Contract)])

sem BodyR
  | BodyR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "BodyR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  nest 2 @decls.debug
                                                ]
  | BHoleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "BHoleR"
                                                ]

sem RhsR
  | RhsR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "RhsR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "Code fed to Helium compiler:"           BOX.<+> pprint @loc.asModuleR
                                                ,  text "Generated types by where-clause:"       BOX.<+> text (show @loc.types)
                                                ,  text "Available contracts:"            BOX.<+> vcat BOX.left @loc.debugContracts
                                                ,  text "Number of contracts:" BOX.<+> pprint ( length (DM.toList @loc.newContractEnv))
                                                ,  nest 2 @where.debug
                                                ,  nest 2 @expr.debug
                                                ]
     loc  .debugContracts               = map (\(nm,ctrt) -> hcat BOX.left [pprint nm,text " : ",pprint ctrt]) ((DM.toList @loc.newContractEnv)::[(String,Contract)])


  | GRhsR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "GRhsR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "Generated types by where-clause:"       BOX.<+> text (show @loc.types)
                                                ,  text "Available contracts:"            BOX.<+> vcat BOX.left @loc.debugContracts

                                                ,  nest 2 @where.debug
                                                ,  nest 2 @gexprs.debug
                                                ]
     loc  .debugContracts               = map (\(nm,ctrt) -> hcat BOX.left [pprint nm,text " : ",pprint ctrt]) ((DM.toList @loc.newContractEnv)::[(String,Contract)])

sem DeclR
  | DHoleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "DHoleR"
                                                ]
  | DEmptyR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "DEmptyR"
                                                ]
  | DFunBindsR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "DFunBindsR"
                                                ,  nest 2 @funbinds.debug
                                                ]
  | DPatBindR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "DPatBindR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "helium arity:"           BOX.<+> (text.show) @loc.arity
                                                ,  text "is top-level:"          BOX.<+> pprint @lhs.isTopLevel
                                                ,  text "local idents known to RHS:"          BOX.<+> pprint @loc.localIdentifiers
                                                ,  nest 2 @pat.debug
                                                ,  nest 2 @rhs.debug
                                                ]

sem ExprR
  | HoleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "HoleR"
                                                ]
  | FeedbackR
     lhs   .debug                       = @expr.debug
  | MustUseR
     lhs   .debug                       = @expr.debug
  | CaseR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "CaseR"
                                                ,  nest 2 @expr.debug
                                                ,  nest 2 @alts.debug
                                                ]
  | ConR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "ConR"
                                                ,  nest 2 @name.debug
                                                ]

  | IfR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "IfR"
                                                ,   nest 2 @cond.debug
                                                ,   nest 2 @then.debug
                                                ,   nest 2 @else.debug
                                                ]

  | InfixAppR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "InfixAppR"
                                                ,  nest 2 @left.debug
                                                ,  nest 2 @op.debug
                                                ,  nest 2 @right.debug
                                                ]
  | LambdaR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "LambdaR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "pattern types:"         BOX.<+> text (show @loc.functionHeliumTypes)
                                                ,  text "types:"                 BOX.<+> text (show @loc.types)
                                                ,  text "local idents known to expr:"          BOX.<+> pprint @loc.localIdentifiers
                                                ,  nest 2 @pats.debug
                                                ,  nest 2 @expr.debug
                                                ]

  | LetR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "LetR"
                                                ,   text "Contracts:"            BOX.<+> vcat BOX.left @loc.debugContracts
                                                ,   nest 2 @decls.debug
                                                ,   nest 2 @expr.debug
                                                ]
     loc  .debugContracts               = map (\(nm,ctrt) -> hcat BOX.left [pprint nm,text " : ",pprint ctrt]) ((DM.toList @loc.newContractEnv)::[(String,Contract)])

  | LitR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "LitR"
                                                ,  nest 2 @lit.debug
                                                ]

  | AppR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "AppR"
                                                ,  text "type:"                 BOX.<+> text (show @loc.functionType)
                                                ,  text "original code:"        BOX.<+> pprint @loc.copy
                                                ,  text "modified version:"      BOX.<+> text (show @loc.functionAppSelf)
                                                ,  nest 2 @fun.debug
                                                ,  nest 2 @args.debug
                                                ]

  | ParenR
     lhs   .debug                       = @expr.debug

  | TupleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "TupleR"
                                                ,  nest 2 @exprs.debug
                                                ]

  | VarR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "VarR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "type:"                  BOX.<+> text (show @loc.functionType) BOX.<+> text ("(Arity: " ++ show @loc.arity ++ ")")
                                                ,  text "contract:"              BOX.<+> pprint @loc.contractAsExprR
                                                ,  text "is base function:"      BOX.<+> text (show @lhs.isBaseFunction)
                                                ,  text "is applied to local function:"           BOX.<+> text (show @lhs.isAppliedToLocalFunction)
                                                ,  text "is a local identifier:"      BOX.<+> text (show @loc.isLocalParameter)
                                                ,  text "is a function identifier:"          BOX.<+> text (show @loc.isFunction)
                                                ,  text "update type:"           BOX.<+> text (show @loc.updateType)
                                                ,  text "available types:"       BOX.<+> text (show @lhs.topLevelTypes)
                                                ,  text "orig ident:"            BOX.<+> pprint @name.copy
                                                ,  text "updated ident:"         BOX.<+> pprint @loc.updatedName
                                                ,  text "point of entry:"        BOX.<+> text @lhs.entryFunction
                                                ,  text "local idents:"          BOX.<+> pprint @lhs.localIdentifiers
                                                ]

  | EnumR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "EnumR"
                                                ,  nest 2 @from.debug
                                                ,  nest 2 @then.debug
                                                ,  nest 2 @to.debug
                                                ]

  | ListR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "ListR"
                                                ,  nest 2 @exprs.debug
                                                ]

sem MaybeExprR
  | NoExprR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "NoExprR"
                                                ]
  | JustExprR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "JustExprR"
                                                ,  nest 2 @expr.debug
                                                ]




sem AltR
  | AHoleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "AHoleR"
                                                ]
  | AltEmptyR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "AltEmptyR"
                                                ]

  | AltR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "AltR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "pattern types:"     BOX.<+> vcat BOX.left @loc.debugTypes
                                                ,  text "local idents known to RHS"          BOX.<+> pprint @loc.localIdentifiers
                                                ,  nest 2 @pat.debug
                                                ,  nest 2 @rhs.debug
                                                ]
     loc  .debugTypes                   = map (\(nm,ty) -> hcat BOX.left $ map text [show nm," : ",show ty]) ((DM.toList @loc.patternTypes)::[(H.Name,S.TpScheme)])

sem FunBindR
  | FBHoleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "FBHoleR"
                                                ]
  | FunBindR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "FunBindR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "helium type:"           BOX.<+> (text.show) @loc.heliumType
                                                ,  text "arity:"                 BOX.<+> pprint @loc.arity
                                                ,  text "arity params:"          BOX.<+> pprint @loc.parameterArity
                                                ,  text "pattern types:"     BOX.<+> vcat BOX.left @loc.debugTypes
                                                ,  text "pattern contracts:" BOX.<+> vcat BOX.left @loc.debugContracts
                                                ,  text "__contracted code:" BOX.<+> pprint @loc.contractedFunction
                                                ,  text "__app code:"        BOX.<+> pprint @loc.appFunction
                                                ,  text "__final code:"      BOX.<+> pprint @loc.finalFunction
                                                ,  text "orig ident:"            BOX.<+> pprint @name.copy
                                                ,  text "updated ident:"         BOX.<+> pprint @loc.updatedName
                                                ,  text "point of entry:"        BOX.<+> text @lhs.entryFunction
                                                ,  text "local idents known to RHS:"          BOX.<+> pprint @loc.localIdentifiers
                                                ,  nest 2 @name.debug
                                                ,  nest 2 @pats.debug
                                                ,  nest 2 @rhs.debug
                                                ]
     loc  .debugTypes                   = map (\(nm,ty) -> hcat BOX.left $ map text [show nm," : ",show ty]) ((DM.toList @loc.patternTypes)::[(H.Name,S.TpScheme)])
     loc  .debugContracts               = map (\(nm,ctrt) -> hcat BOX.left [text nm,text " : ",pprint ctrt]) ((DM.toList @loc.patternContracts)::[(String,Contract)])

sem PatR
  | PHoleR
     lhs    .debug                      = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "PHoleR"
                                                ]
  | PConR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "PConR",
                                                   nest 2 @name.debug,
                                                   nest 2 @pats.debug
                                                ]
    
  | PInfixConR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "PInfixConR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "local patterns:"        BOX.<+> pprint @loc.localPatterns
                                                ,  nest 2 @left.debug
                                                ,  nest 2 @name.debug
                                                ,  nest 2 @right.debug
                                                ]

  | PListR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "PListR",
                                                   nest 2 @pats.debug
                                                ]

  | PLitR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "PLitR",
                                                   nest 2 @lit.debug
                                                ]

  | PTupleR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "PTupleR",
                                                   nest 2 @pats.debug
                                                ]

  | PVarR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "PVarR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "local patterns:"        BOX.<+> pprint @loc.localPatterns
                                                ,  nest 2 @name.debug
                                                ]
   | PAsR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "PAsR"
                                                ,  text "code:"                  BOX.<+> pprint @loc.copy
                                                ,  text "local patterns:"        BOX.<+> pprint @loc.localPatterns
                                                ,  nest 2 @name.debug
                                                ,  nest 2 @pat.debug
                                                ]

  | PWildcardR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left
                                                [  horizontalLinesWith "*" $ text "PWildcardR"
                                                ]


sem LiteralR
  | LCharR LFloatR LIntR LStringR
     lhs   .debug                       = pprint @val

sem NameR
  | IdentR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "IdentR"
                                                ,  text "name:"                  BOX.<+> text @name
                                                ]
  | OperatorR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "OperatorR"
                                                ,  text "name:"                  BOX.<+> text @name
                                                ]
  | SpecialR
     lhs   .debug                       = leftLineNoSpace $ vcat BOX.left  
                                                [  horizontalLinesWith "*" $ text "SpecialR"
                                                ,  text "name:"                  BOX.<+> text @name
                                                ]
