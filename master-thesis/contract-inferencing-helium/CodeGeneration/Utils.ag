optpragmas
{
{-# LANGUAGE FlexibleContexts #-}
}

include "../ContractInferencing/ContractTypes.ag"

imports
{
import qualified Top.Types.Schemes as S
import qualified Top.Types.Primitive as P
import qualified Top.Types.Qualification as QL
import qualified Top.Types.Quantification as QN
import qualified Top.Types.Classes as CLS
import qualified ModuleSystem.ImportEnvironment as IE
import qualified Control.Exception as CE
}

{

searchTypeEnvs :: NameR -> [IE.ImportEnvironment] -> Maybe S.TpScheme
searchTypeEnvs nm envs = (DJ.listToMaybe.DJ.catMaybes) $ map ((lookupHeliumTypeMaybe nm).getTypesAndValueConstructors) envs

getTypeEnv :: IE.ImportEnvironment -> IE.TypeEnvironment
getTypeEnv (IE.ImportEnvironment _ _ ty _ _ _) = ty

getTypesAndValueConstructors :: IE.ImportEnvironment -> IE.TypeEnvironment
getTypesAndValueConstructors (IE.ImportEnvironment _ _ ty vc _ _) = DM.union ty vc

generateImportEnv :: IE.TypeEnvironment -> IE.ImportEnvironment
generateImportEnv tyenv = IE.emptyEnvironment { IE.typeEnvironment = tyenv }

-- Replace definitions in old env with definitions in new env.
overwriteImportEnv :: IE.ImportEnvironment -> IE.ImportEnvironment -> IE.ImportEnvironment
overwriteImportEnv (IE.ImportEnvironment nc ns ne nv no nt) (IE.ImportEnvironment oc os oe ov oo ot) = 
 IE.ImportEnvironment
   { IE.typeConstructors  = DM.union nc oc
   , IE.typeSynonyms      = DM.union ns os
   , IE.typeEnvironment   = DM.union ne oe
   , IE.valueConstructors = DM.union nv ov
   , IE.operatorTable     = DM.union no oo
   , IE.typingStrategies  = nt ++ ot
   }

removeFromTypeEnv :: H.Name -> IE.ImportEnvironment -> IE.ImportEnvironment
removeFromTypeEnv x (IE.ImportEnvironment a b tyenv c d e) =
 IE.ImportEnvironment a b (DM.delete x tyenv) c d e

getMaxVariable :: IE.ImportEnvironment -> Int
getMaxVariable (IE.ImportEnvironment _ _ c d _ _) = 
 maximum' $ map maxVar [c,d]
  where maxVar :: DM.Map H.Name S.TpScheme -> Int
        maxVar = DM.fold (\x xs -> max (getMaxInt x) xs) (0::Int)
        getMaxInt = maximum'.thd.stripTypeScheme 

getQuantifiers :: Contract -> [Contract]
getQuantifiers (CQuant qv cs) = qv : getQuantifiers cs
getQuantifiers _ = []

stripQuantifiers :: Contract -> Contract
stripQuantifiers (CQuant _ cs) = stripQuantifiers cs
stripQuantifiers x = x

splitFunctionContract :: Contract -> (Contract,Contract)
splitFunctionContract x@(CQuant qv _) = splitFunctionContract' (stripQuantifiers x) (getQuantifiers x)
splitFunctionContract x = splitFunctionContract' x []

splitFunctionContract' :: Contract -> [Contract] -> (Contract,Contract)
splitFunctionContract' (CArr x y) quants = (foldr CQuant x quants,foldr CQuant y quants)
splitFunctionContract' x _ = (error.show) $ text "Not a function contract: " BOX.<+> pprint x


type FunctionArityEnvironment = DM.Map String Int
type ParameterArityEnvironment = DM.Map String [Int]

updateName :: (NameR -> NameR) -> NameR -> String -> [String] -> NameR
updateName f n entryPoint localIdents = 
 if (getVar n == entryPoint) && not (elem (getVar n) localIdents)
  then f n
  else n

prefixPointOfEntry :: NameR -> NameR
prefixPointOfEntry (IdentR name r)    = (IdentR ("__original_"++name) r)
prefixPointOfEntry (OperatorR name r) = (OperatorR ("***"++name++"***") r)
prefixPointOfEntry _ = error "prefixPointOfEntry: Haven't defined anything yet for SpecialR."

-- Just fetches the string out of a NameR
getVar :: NameR -> String
getVar (IdentR x _)    = x
getVar (OperatorR x _) = x
getVar (SpecialR x _)  = x

-- If we need more, we should turn this into a class
getRange :: NameR -> RangeR
getRange (IdentR _ r)    = r
getRange (OperatorR _ r) = r
getRange (SpecialR _ r)  = r

lookupHeliumTypeMaybe :: NameR -> IE.TypeEnvironment -> Maybe S.TpScheme
lookupHeliumTypeMaybe nm env = DM.lookup (toHeliumWithRanges nm) env

lookupHeliumType :: NameR -> IE.TypeEnvironment -> S.TpScheme
lookupHeliumType nm env = 
 let result = lookupHeliumTypeMaybe nm env
 in case result of
     (Just x) -> x
     Nothing  -> error $ "Tried to look up " ++ show nm ++ " in type environment: " ++ show env

-- We need to remove range information because otherwise we could end up with multiple entries
scrubRangeInfo :: IE.TypeEnvironment -> IE.TypeEnvironment
scrubRangeInfo = DM.mapKeys removeRange
  where
   removeRange  :: H.Name -> H.Name
   removeRange  = toHeliumWithRanges.removeRange'.fromHeliumWithRanges

removeRange' :: NameR -> NameR
removeRange' (IdentR x _)    = IdentR x noRangeR
removeRange' (OperatorR x _) = OperatorR x noRangeR
removeRange' (SpecialR x _)  = SpecialR x noRangeR

extractTypeNoRange = scrubRangeInfo.(H.extractTypes)

calculateArity :: IE.TypeEnvironment -> FunctionArityEnvironment
calculateArity env = DM.fromList $ map (\(name,ty) -> ((getVar.fromHeliumWithRanges) name, S.arityOfTpScheme ty)) (DM.toList env)

calculateParameterArity :: IE.TypeEnvironment -> ParameterArityEnvironment
calculateParameterArity env = DM.fromList  $ map (\(name,ty) -> ((getVar.fromHeliumWithRanges) name, getParameterArity ty)) (DM.toList env)
  where getParameterArity ty = ((map P.arityOfTp) . fst . P.functionSpine . QL.unqualify . QN.unquantify) ty

makeModuleR :: DeclsR -> ModuleR
makeModuleR []    = ModuleR NoNameR (BHoleR 0    noRangeR) noRangeR 
makeModuleR decls = ModuleR NoNameR (BodyR decls noRangeR) noRangeR

convertExprToFunBind :: ExprR -> FunBindR
convertExprToFunBind (LambdaR pats expr range) = 
 let nm = IdentR "__internalExpression__" noRangeR
     rhs = RhsR expr [] noRangeR
 in FunBindR Nothing nm pats rhs range
convertExprToFunBind caseExpr = 
 let nm = IdentR "__internalExpression__" noRangeR
     rhs = RhsR caseExpr [] noRangeR
 in FunBindR Nothing nm [] rhs noRangeR

noRangeR :: RangeR
noRangeR = RangeR UnknownR UnknownR

maximum' :: (Num a, Ord a) => [a] -> a
maximum' [] = 0
maximum' xs = maximum xs

thd :: (a,b,c) -> c
thd (a,b,c) = c

-- Disassembles a type scheme into the parts needed to reassemble it.
stripTypeScheme :: S.TpScheme -> (P.Tp, CLS.Predicates, [Int])
stripTypeScheme ty = 
 let quants      = QN.quantifiers ty
     noqnTy      = QN.unquantify ty
     predicates  = QL.qualifiers noqnTy
     simpleTy    = QL.unqualify noqnTy
 in (simpleTy, predicates, quants)

-- Reassembles a simple type into a type scheme again.
assembleTypeScheme :: (P.Tp, CLS.Predicates, [Int]) -> S.TpScheme
assembleTypeScheme (ty,pr,qu) = S.toTpScheme $ QN.quantify qu $ QL.qualify context pr ty
 where context = ([]::[CLS.Predicate])

allTypes :: P.Tp -> P.Tps
allTypes ty = (\(x,y) -> x++[y]) $ P.functionSpine ty

mapConvertTopTypeToContract :: Int -> [S.TpScheme] -> (Int,[Contract])
mapConvertTopTypeToContract offset (ty:ts) = 
 let (offset',ctrt) = convertTopTypeToContract offset ty
     (finalOffset,ctrts) = mapConvertTopTypeToContract offset' ts
 in (finalOffset,ctrt:ctrts)
mapConvertTopTypeToContract offset [] = (offset,[])

convertTopTypeToContract :: Int -> S.TpScheme -> (Int,Contract)
convertTopTypeToContract offset ty = 
 let primType = (QL.unqualify . QN.unquantify) ty
     quantifiedVars = map (\v -> CVar v Nothing)
     typeAsList = P.getTypes primType
     convertedTriple = convert [offset..] (head typeAsList)
     base = (\(_,c,_) -> c) convertedTriple
     usedVariables = map makeType $ (\(_,_,v) -> v) convertedTriple
     nextAvailableContractVar = (maximum' $ offset : ((\(_,_,v) -> v) convertedTriple)) + 1
 in (nextAvailableContractVar, foldr CQuant base (quantifiedVars usedVariables))
  where
   makeType :: Int -> String
   makeType i = "v" ++ show i

   -- Here, we convert a primitive type to a contract recursively.
   -- First [Int] parameter is just a list of fresh variable numbers.
   -- Result: First [Int] is the remaining fresh variable numbers,
   -- second [Int] is the list of used variable numbers, which are 
   -- collected for use in universal quantification.
   convert :: [Int] -> P.Tp -> ([Int],Contract,[Int])
   convert (n:ns) (P.TVar i) = 
    (ns, CVar (makeType n) Nothing,[n])
   convert n (P.TApp (P.TApp (P.TCon "->") t1) t2) = 
    let (n', ctrt1,q1) = convert n t1
        (n'',ctrt2,q2) = convert n' t2
    in (n'', CArr ctrt1 ctrt2,q1++q2)
   convert (n:ns) (P.TApp (P.TCon x) t1) | x `elem` ["Maybe","[]"] =
    let outer = CVar (makeType n) Nothing
        (n',inner,q) = convert ns t1 
    in (n', CFunctor outer inner,n:q)
   convert (n:ns) (P.TApp (P.TApp (P.TCon x) t1) t2) | x `elem` ["Either","(,)"] =
    let outer = CVar (makeType n) Nothing
        (n',leftInner,q1)   = convert ns t1
        (n'',rightInner,q2) = convert n' t2
    in (n'', CBifunctor outer leftInner rightInner,n:q1++q2)
   convert (n:ns) (P.TCon x) | x `elem` ["Int","Char","Float","Bool","String"] = 
    (ns, CVar (makeType n) Nothing,[n])
   -- 4-tuple
   convert n (P.TApp (P.TApp (P.TApp (P.TApp (P.TCon x) t1) t2) t3) t4) | P.isTupleConstructor x =
    let (n1, ctrt1,q1) = convert n t1
        (n2, ctrt2,q2) = convert n1 t2
        (n3, ctrt3,q3) = convert n2 t3
        (n4, ctrt4,q4) = convert n3 t4
    in (n4, CTuple [ctrt1,ctrt2,ctrt3,ctrt4],q1++q2++q3++q4)
   -- 3-tuple
   convert n (P.TApp (P.TApp (P.TApp (P.TCon x) t1) t2) t3) | P.isTupleConstructor x =
    let (n1, ctrt1,q1) = convert n t1
        (n2, ctrt2,q2) = convert n1 t2
        (n3, ctrt3,q3) = convert n2 t3
    in (n3, CTuple [ctrt1,ctrt2,ctrt3],q1++q2++q3)
   convert n (P.TCon x) | P.isTupleConstructor x = 
    error $ "Only tuples up to size 4 are currently supported. Tried to convert type: " ++ show x
   convert _ x = error $ "Was unable to convert the following type: " ++ show x 

-- Splits up a function type scheme into two parts.
splitTopTypeScheme :: S.TpScheme -> (S.TpScheme, Maybe S.TpScheme)
splitTopTypeScheme ty = 
 let (simpleTy,predicates,quants) = stripTypeScheme ty
     allTps      = allTypes simpleTy
     leftType    = assembleTypeScheme (head allTps,predicates,quants)
     restTy      = case tail allTps of
                     []  -> Nothing
                     [x] -> Just x
                     xs  -> Just $ foldr (P..->.) (last xs) (init xs)
     maybeFunc   = \rest -> Just $ assembleTypeScheme (rest,predicates,quants)
     restType    = maybe Nothing maybeFunc restTy
 in (leftType, restType)

splitUpTuple :: S.TpScheme -> [S.TpScheme]
splitUpTuple ty =
 let (simpleTy,predicates,quants) = stripTypeScheme ty
     tuple      = head (allTypes simpleTy)
     getTupleElems (P.TApp (P.TApp (P.TCon x) t1) t2) | P.isTupleConstructor x = [t1,t2]
     getTupleElems (P.TApp (P.TApp (P.TApp (P.TCon x) t1) t2) t3) | P.isTupleConstructor x = [t1,t2,t3]
     getTupleElems (P.TApp (P.TApp (P.TApp (P.TApp (P.TCon x) t1) t2) t3) t4) | P.isTupleConstructor x = [t1,t2,t3,t4]
     getTupleElems (P.TApp (P.TApp (P.TApp (P.TApp (P.TApp (P.TCon x) t1) t2) t3) t4) t5) | P.isTupleConstructor x = [t1,t2,t3,t4,t5]
     getTupleElems (P.TCon x) | P.isTupleConstructor x = error $ "Extend splitUpTuple with more tuple cases, only supports up to 5-tuples at the moment, tried to pattern match on: " ++ show x
     getTupleElems x = error $ "Expected a tuple to be split up, got the following type: " ++ show x
 in map (\x -> assembleTypeScheme (x,predicates,quants)) (getTupleElems tuple)


-- Fetches the a from [a] in a type.
getInnerListElem :: S.TpScheme -> S.TpScheme
getInnerListElem ty = 
 let (simpleTy,predicates,quants) = stripTypeScheme ty
     list           = head (allTypes simpleTy)
     getListElem (P.TApp (P.TCon "[]") t1) = t1
     getListElem x = error $ "Expected a list, got the following type: " ++ show x
 in assembleTypeScheme (getListElem list,predicates,quants)

-- Fetches the inner contract from a list contract.
getInnerListCtrt :: Contract -> Contract
getInnerListCtrt x@(CQuant qv cs) = foldr CQuant (getInnerListCtrt $ stripQuantifiers x) (getQuantifiers x)
getInnerListCtrt (CFunctor _ i) = i
getInnerListCtrt x = error $ "Tried to apply getInnerListCtrt to the following contract: " ++ show x

splitTupleContract :: Contract -> (Contract,Contract)
splitTupleContract x@(CQuant qv cs) =
 let (hd,tl) = splitTupleContract $ stripQuantifiers x
 in (foldr CQuant hd (getQuantifiers x),foldr CQuant tl (getQuantifiers x))
splitTupleContract (CTuple (x:xs)) = (x, CTuple xs)
splitTupleContract x = error $ "Tried to apply splitTupleContract to the following contract: " ++ show x

expandHigherOrderParams :: String -> String -> (Int,Int,String) -> ExprR
expandHigherOrderParams funcText funcName (listpos,arity,pat) = 
 let v = mkVar pat
     pats = take arity [x : show y | y <- [0..10], x <- ['a'..'z']  ]
     pvars = map mkPVar pats
     lam = mkParens $ mkLambda pvars apps
     apps = insertApps "appParam" base $ reverse $ zip (map appParamText (take arity [1..]) ) (map mkVar pats)
     base = v

     -- Generation of the error text for higher-order parameters.
     appParamText i = mkAppParens [mkVar "concat", mkList [parentText, positionData, posText, startText i, endText i, generatePosStr i] ]
     generatePosStr i = mkApp [mkVar "show", mkVar (pats !! (i-1))]
     parentText = (mkLit.mkStrLit) (funcText ++ " ")
     positionData = mkAppParens [mkVar "generatePositionData", mkVar "posinfo"]
     posText = (mkLit.mkStrLit) $ ". " ++ funcName ++ " has a function as its " ++ showPos listpos ++ " argument."
     endText i = (mkLit.mkStrLit) ", namely "
     startText i =  (mkLit.mkStrLit) $ " The " ++ showPos i ++ " argument of that function"
     --lookupStr i = mkApp [mkVar "show", v]
 in if arity > 0
     then lam
     else v

showPos p | p == 1 = "first"
          | p == 2 = "second"
          | p == 3 = "third"
          | p == 4 = "fourth"
          | p == 5 = "fifth"
          | p == 6 = "sixth"
          | otherwise = show p

isHOText b | b == True = " higher-order "
           | otherwise = " "

extractPositionData :: RangeR -> Maybe (Int,Int)
extractPositionData (RangeR (PositionR f l c) _) = Just (l,c)
extractPositionData _ = Nothing

generatePositionText :: Bool -> String -> String
generatePositionText isHO name = "the application of the" ++ isHOText isHO ++ "function '" ++ name ++ "'"

generatePositionData :: Maybe (Int,Int) -> String
generatePositionData (Just (l,c)) = "at line number " ++ show l ++ ", column number " ++ show c 
generatePositionData Nothing      = "at an unknown position"

posDataAsLiterals :: Maybe (Int,Int) -> ExprR
posDataAsLiterals (Just (l,c)) = mkAppParens [mkVar "Just", mkTuple [(mkLit.mkIntLit) l, (mkLit.mkIntLit) c]]
posDataAsLiterals Nothing = mkVar "Nothing"

fromJustMsg :: String -> Maybe a -> a
fromJustMsg s = maybe (error s) id 

indexMsg :: (Show a) => [a] -> Int -> a
indexMsg xs pos | length xs > pos - 1 = xs !! pos
                | otherwise = error $ "Exception when trying to find an element at position " ++ show pos ++ " in list " ++ show xs

-- 1 = prefixContract, 2 = id (but gets more information added), 3 = prefixApp, 4 = id
determineUpdateFunction :: ExprR -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Int
determineUpdateFunction expr isArg isFunc isFullyApplied isArgToFullyApplied functionIsParameter isLocalParameter
 | t [isArg, isFunc, isLocalParameter, functionIsParameter] = 4
 | t [isArg, isFunc, isLocalParameter, not functionIsParameter] = 2
 | t [isFunc, isLocalParameter] = 4
 | t [isFunc, functionIsParameter] = 4
 | t [isArg, functionIsParameter] = 4
 | t [isArg,isFunc,not isFullyApplied] = 1
 | t [isArg,isFunc, isFullyApplied]    = 3
 | t [isArg,not isFunc, isArgToFullyApplied] = 2
 | t [not isArg, isFunc, isFullyApplied] = 3
 | t [not isArg, isFunc, not isFullyApplied] = 3
 | t [isArg,not isFunc, not isArgToFullyApplied] = 4
 | t [not isArg,not isFunc, not isFullyApplied, not isArgToFullyApplied] = 4
 | otherwise = error $ "Non-exhaustive pattern when checking expression " ++ show expr ++ "(isArg=" ++ show isArg ++ ", isFunc=" ++ show isFunc ++ ", isFullyApplied=" ++ show isFullyApplied ++ ", isArgToFullyApplied=" ++ show isArgToFullyApplied ++ ")"
 where t = all (==True)

isTrueContract :: String -> Bool
isTrueContract (x:xs) = if x == 'c'
                           then case (reads xs) :: [(Integer,String)] of
                                 [(_,"")] -> True
                                 _        -> False
                           else False
isTrueContract []      = False

replaceTrueContract :: String -> String
replaceTrueContract x = if isTrueContract x
                         then "true"
                         else x

insertApps :: String -> ExprR -> [(ExprR,ExprR)] -> ExprR
insertApps appType = foldr (\(pos,var) xs -> mkParens $ mkApp [mkVar appType,xs,pos,var])

mkIdent :: String -> NameR
mkIdent x = IdentR x noRangeR

mkOp :: String -> NameR
mkOp x = OperatorR x noRangeR

mkParens :: ExprR -> ExprR
mkParens e = ParenR e noRangeR

mkList :: ListExprR -> ExprR
mkList xs = ListR xs noRangeR

mkFunbind :: NameR -> PatsR -> RhsR -> FunBindR
mkFunbind nm pats rhs = FunBindR Nothing nm pats rhs noRangeR

mkDFunbinds :: FunBindsR -> DeclR
mkDFunbinds fs = DFunBindsR fs noRangeR

mkRhs :: ExprR -> DeclsR -> RhsR
mkRhs e wher = RhsR e wher noRangeR

mkLambda :: PatsR -> ExprR -> ExprR
mkLambda p e = LambdaR p e noRangeR

mkTuple :: ExprsR -> ExprR
mkTuple es = TupleR es noRangeR

mkPTuple :: PatsR -> PatR
mkPTuple ps = PTupleR ps noRangeR

mkApp :: ExprsR -> ExprR
mkApp (e:es) = AppR e es noRangeR

mkInfixApp :: ExprR -> ExprR -> ExprR -> ExprR
mkInfixApp l m r = InfixAppR (JustExprR l) m (JustExprR r) noRangeR

mkAppParens :: ExprsR -> ExprR
mkAppParens = mkParens.mkApp

mkPVar :: String -> PatR
mkPVar s = PVarR (IdentR s noRangeR) noRangeR

mkVar :: String -> ExprR
mkVar s = VarR (mkIdent s) noRangeR

mkStrLit :: String -> LiteralR
mkStrLit s = LStringR s noRangeR

mkIntLit :: Int -> LiteralR
mkIntLit i = LIntR i noRangeR

mkLit :: LiteralR -> ExprR
mkLit l = LitR l noRangeR

isVarR :: ExprR -> Bool
isVarR (VarR _ _) = True
isVarR _          = False

{-
apps :: [(ExprR,RangeR)] ->  ExprR -> ExprR
apps xs b = foldr f b (reverse xs)
  where f (y,pos) ys = AppR (makeVar "appWithPos") [ys, makeAppPos pos, y]
        makeAppPos (RangeR start stop) = AppR (ConR (IdentR "PositionR" noRange) noRange) [makeRange start,makeRange stop] noRange
        makeRange (PositionR f l c) = AppR (ConR (IdentR "PositionR" noRange) noRange) [LitR (LStringR f noRange) noRange,LitR (LIntR l noRange),LitR (LIntR c noRange)] noRange
        makeRange UnknownR = ConR (IdentR "UnknownR" noRange) noRange
-}

}
