optpragmas
{
{-# LANGUAGE FlexibleContexts #-}
}

include "../ContractInferencing/ContractTypes.ag"

imports
{
import qualified Top.Types.Schemes as S
import qualified Top.Types.Primitive as P
import qualified Top.Types.Qualification as QL
import qualified Top.Types.Quantification as QN
import qualified Top.Types.Classes as CLS
import qualified ModuleSystem.ImportEnvironment as IE
}

{

generateImportEnv :: IE.TypeEnvironment -> IE.ImportEnvironment
generateImportEnv tyenv = IE.emptyEnvironment { IE.typeEnvironment = tyenv }

-- Replace definitions in old env with definitions in new env.
overwriteImportEnv :: IE.ImportEnvironment -> IE.ImportEnvironment -> IE.ImportEnvironment
overwriteImportEnv new@(IE.ImportEnvironment nc ns ne nv no nt) old@(IE.ImportEnvironment oc os oe ov oo ot) = IE.ImportEnvironment
   { IE.typeConstructors  = DM.union nc oc
   , IE.typeSynonyms      = DM.union ns os
   , IE.typeEnvironment   = DM.union ne oe
   , IE.valueConstructors = DM.union nv ov
   , IE.operatorTable     = DM.union no oo
   , IE.typingStrategies  = nt ++ ot
   }

removeFromTypeEnv :: H.Name -> IE.ImportEnvironment -> IE.ImportEnvironment
removeFromTypeEnv x (IE.ImportEnvironment a b tyenv c d e) =
 IE.ImportEnvironment a b (DM.delete x tyenv) c d e

getQuantifiers :: Contract -> [Contract]
getQuantifiers (CQuant qv cs) = qv : getQuantifiers cs
getQuantifiers x = []

stripQuantifiers :: Contract -> Contract
stripQuantifiers (CQuant qv cs) = stripQuantifiers cs
stripQuantifiers x = x

splitFunctionContract :: Contract -> (Contract,Contract)
splitFunctionContract x@(CQuant qv cs) = splitFunctionContract' (stripQuantifiers x) (getQuantifiers x)
splitFunctionContract x = splitFunctionContract' x []

splitFunctionContract' :: Contract -> [Contract] -> (Contract,Contract)
splitFunctionContract' (CArr x y) quants = (foldr CQuant x quants,foldr CQuant y quants)
splitFunctionContract' x _ = (error.show) $ text "Not a function contract: " BOX.<+> pprint x


type FunctionArityEnvironment = DM.Map NameR Int
type ParameterArityEnvironment = DM.Map NameR [Int]

updateName :: (NameR -> NameR) -> NameR -> String -> [NameR] -> NameR
updateName f n entryPoint localIdents = 
 if (getVar n == entryPoint) && not (elem n localIdents)
  then f n
  else n

prefixPointOfEntry :: NameR -> NameR
prefixPointOfEntry (IdentR name r)    = (IdentR ("__original_"++name) r)
prefixPointOfEntry (OperatorR name r) = (OperatorR ("***"++name++"***") r)
prefixPointOfEntry _ = error "prefixPointOfEntry: Haven't defined anything yet for SpecialR."

-- Just fetches the string out of a NameR
getVar :: NameR -> String
getVar (IdentR x _)    = x
getVar (OperatorR x _) = x
getVar (SpecialR x _)  = x

lookupHeliumType :: NameR -> IE.TypeEnvironment -> S.TpScheme
lookupHeliumType nm env = 
 let result = DM.lookup (toHeliumWithRanges nm) env
 in case result of
     (Just x) -> x
     Nothing  -> error $ "Tried to look up " ++ show nm ++ " in type environment: " ++ show env

calculateArity :: IE.TypeEnvironment -> FunctionArityEnvironment
calculateArity env = DM.fromList $ map (\(name,ty) -> (fromHeliumWithRanges name, S.arityOfTpScheme ty)) (DM.toList env)

calculateParameterArity :: IE.TypeEnvironment -> ParameterArityEnvironment
calculateParameterArity env = DM.fromList  $ map (\(name,ty) -> (fromHeliumWithRanges name, getParameterArity ty)) (DM.toList env)
  where getParameterArity ty = ((map P.arityOfTp) . fst . P.functionSpine . QL.unqualify . QN.unquantify) ty

makeModuleR :: DeclsR -> ModuleR
makeModuleR []    = ModuleR NoNameR (BHoleR 0    noRangeR) noRangeR 
makeModuleR decls = ModuleR NoNameR (BodyR decls noRangeR) noRangeR

convertLambdaToFunBind :: ExprR -> FunBindR
convertLambdaToFunBind (LambdaR pats expr range) = 
 let nm = IdentR "__internalLambda__" noRangeR
     rhs = RhsR expr [] noRangeR
 in FunBindR Nothing nm pats rhs range

noRangeR :: RangeR
noRangeR = RangeR UnknownR UnknownR

maximum' :: (Num a, Ord a) => [a] -> a
maximum' [] = 0
maximum' xs = maximum xs

-- Disassembles a type scheme into the parts needed to reassemble it.
stripTypeScheme :: S.TpScheme -> (P.Tp, CLS.Predicates, [Int])
stripTypeScheme ty = 
 let quants      = QN.quantifiers ty
     noqnTy      = QN.unquantify ty
     predicates  = QL.qualifiers noqnTy
     simpleTy    = QL.unqualify noqnTy
 in (simpleTy, predicates, quants)

-- Reassembles a simple type into a type scheme again.
assembleTypeScheme :: (P.Tp, CLS.Predicates, [Int]) -> S.TpScheme
assembleTypeScheme (ty,pr,qu) = S.toTpScheme $ QN.quantify qu $ QL.qualify context pr ty
 where context = ([]::[CLS.Predicate])

allTypes :: P.Tp -> P.Tps
allTypes ty = (\(x,y) -> x++[y]) $ P.functionSpine ty

-- TODO: We generate fresh contract variables using maximum, but this may interfere with existing types???
-- Perhaps first calculate the offset of the Helium types by synthesizing the highest value, and then passing that
-- back down, passing it along as an offset to convertTopTypeToContract. That function then returns what it's used, which is
-- given back to the rest of the AST...
convertTopTypeToContract :: S.TpScheme -> Contract
convertTopTypeToContract ty = 
 let primType = (QL.unqualify . QN.unquantify) ty
     varsToQuantify = map makeType (P.variablesInType primType)
     quantifiedVars = map (\v -> CVar v Nothing)
     typeAsList = P.getTypes primType
     convertedTriple = convert [((maximum' (P.variablesInType primType))+1)..] (head typeAsList)
     base = (\(_,c,_) -> c) convertedTriple
     usedVariables = map makeType $ (\(_,_,v) -> v) convertedTriple
 in foldr CQuant base (quantifiedVars $ varsToQuantify ++ usedVariables)
  where
   makeType :: Int -> String
   makeType i = "v" ++ show i

   -- Here, we convert a primitive type to a contract recursively.
   -- First [Int] parameter is just a list of fresh variable numbers.
   -- Result: First [Int] is the remaining fresh variable numbers,
   -- second [Int] is the list of used variable numbers, which are 
   -- collected for use in universal quantification.
   convert :: [Int] -> P.Tp -> ([Int],Contract,[Int])
   convert n (P.TVar i) = 
    (n, CVar (makeType i) Nothing,[])
   convert n (P.TApp (P.TApp (P.TCon "->") t1) t2) = 
    let (n', ctrt1,q1) = convert n t1
        (n'',ctrt2,q2) = convert n' t2
    in (n'', CArr ctrt1 ctrt2,q1++q2)
   convert (n:ns) (P.TApp (P.TCon x) t1) | x `elem` ["Maybe","[]"] =
    let outer = CVar (makeType n) Nothing
        (n',inner,q) = convert ns t1 
    in (n', CFunctor outer inner,n:q)
   convert (n:ns) (P.TApp (P.TApp (P.TCon x) t1) t2) | x `elem` ["Either","(,)"] =
    let outer = CVar (makeType n) Nothing
        (n',leftInner,q1)   = convert ns t1
        (n'',rightInner,q2) = convert n' t2
    in (n'', CBifunctor outer leftInner rightInner,n:q1++q2)
   convert (n:ns) (P.TCon x) | x `elem` ["Int","Char","Float","Bool","String"] = 
    (ns, CVar (makeType n) Nothing,[n])
   -- 4-tuple
   convert n (P.TApp (P.TApp (P.TApp (P.TApp (P.TCon x) t1) t2) t3) t4) | P.isTupleConstructor x =
    let (n1, ctrt1,q1) = convert n t1
        (n2, ctrt2,q2) = convert n1 t2
        (n3, ctrt3,q3) = convert n2 t3
        (n4, ctrt4,q4) = convert n3 t4
    in (n4, CTuple [ctrt1,ctrt2,ctrt3,ctrt4],q1++q2++q3++q4)
   -- 3-tuple
   convert n (P.TApp (P.TApp (P.TApp (P.TCon x) t1) t2) t3) | P.isTupleConstructor x =
    let (n1, ctrt1,q1) = convert n t1
        (n2, ctrt2,q2) = convert n1 t2
        (n3, ctrt3,q3) = convert n2 t3
    in (n3, CTuple [ctrt1,ctrt2,ctrt3],q1++q2++q3)
   convert n (P.TCon x) | P.isTupleConstructor x = 
    error $ "Only tuples up to size 4 are currently supported. Tried to convert type: " ++ show x
   convert _ x = error $ "Was unable to convert the following type: " ++ show x 

-- Splits up a function type scheme into two parts.
splitTopTypeScheme :: S.TpScheme -> (S.TpScheme, Maybe S.TpScheme)
splitTopTypeScheme ty = 
 let (simpleTy,predicates,quants) = stripTypeScheme ty
     allTps      = allTypes simpleTy
     leftType    = assembleTypeScheme (head allTps,predicates,quants)
     restTy      = case tail allTps of
                     []  -> Nothing
                     [x] -> Just x
                     xs  -> Just $ foldr (P..->.) (last xs) (init xs)
     maybeFunc   = \rest -> Just $ assembleTypeScheme (rest,predicates,quants)
     restType    = maybe Nothing maybeFunc restTy
 in (leftType, restType)

splitUpTuple :: S.TpScheme -> [S.TpScheme]
splitUpTuple ty =
 let (simpleTy,predicates,quants) = stripTypeScheme ty
     tuple      = head (allTypes simpleTy)
     getTupleElems (P.TApp (P.TApp (P.TCon x) t1) t2) | P.isTupleConstructor x = [t1,t2]
     getTupleElems (P.TApp (P.TApp (P.TApp (P.TCon x) t1) t2) t3) | P.isTupleConstructor x = [t1,t2,t3]
     getTupleElems (P.TApp (P.TApp (P.TApp (P.TApp (P.TCon x) t1) t2) t3) t4) | P.isTupleConstructor x = [t1,t2,t3,t4]
     getTupleElems (P.TApp (P.TApp (P.TApp (P.TApp (P.TApp (P.TCon x) t1) t2) t3) t4) t5) | P.isTupleConstructor x = [t1,t2,t3,t4,t5]
     getTupleElems (P.TCon x) | P.isTupleConstructor x = error $ "Extend splitUpTuple with more tuple cases, only supports up to 5-tuples at the moment, tried to pattern match on: " ++ show x
     getTupleElems x = error $ "Expected a tuple to be split up, got the following type: " ++ show x
 in map (\x -> assembleTypeScheme (x,predicates,quants)) (getTupleElems tuple)


-- Fetches the a from [a] in a type.
getInnerListElem :: S.TpScheme -> S.TpScheme
getInnerListElem ty = 
 let (simpleTy,predicates,quants) = stripTypeScheme ty
     list           = head (allTypes simpleTy)
     getListElem (P.TApp (P.TCon "[]") t1) = t1
     getListElem x = error $ "Expected a list, got the following type: " ++ show x
 in assembleTypeScheme (getListElem list,predicates,quants) 

{-
apps :: [(ExprR,RangeR)] ->  ExprR -> ExprR
apps xs b = foldr f b (reverse xs)
  where f (y,pos) ys = AppR (makeVar "appWithPos") [ys, makeAppPos pos, y]
        makeAppPos (RangeR start stop) = AppR (ConR (IdentR "PositionR" noRange) noRange) [makeRange start,makeRange stop] noRange
        makeRange (PositionR f l c) = AppR (ConR (IdentR "PositionR" noRange) noRange) [LitR (LStringR f noRange) noRange,LitR (LIntR l noRange),LitR (LIntR c noRange)] noRange
        makeRange UnknownR = ConR (IdentR "UnknownR" noRange) noRange
-}

}
