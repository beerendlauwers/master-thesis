optpragmas
{
{-# LANGUAGE TypeSynonymInstances, FlexibleInstances #-}
}

imports
{
import qualified Common.Library (build)
import Text.PrettyPrint as PP
--import qualified Domain.FP.Helium as H
--import Domain.FP.Views (heliumView)
}


{
class Pretty a where
  pprint :: a -> PP.Doc

instance Pretty a => Pretty (Maybe a) where
  pprint Nothing   = PP.text "Nothing"
  pprint (Just p)  = PP.parens $ PP.text "Just" PP.<+> PP.parens (pprint p)

instance Pretty a => Pretty [a] where
  pprint = foldr (\x xs -> pprint x $+$ xs) PP.empty

instance (Pretty a, Pretty b) => Pretty (a, b) where
  pprint (l, r) = PP.parens $ pprint l PP.<> PP.comma PP.<+> pprint r

instance Pretty Int where
  pprint = PP.int

instance Pretty Char where
  pprint = PP.char

instance Pretty Bool where
  pprint = PP.text . show

instance Pretty NameR where
  pprint (IdentR n _)    = PP.text n
  pprint (OperatorR n _) = PP.text n
  pprint (SpecialR n _)  = PP.text n

-- We can't use these in AGs, we get a "Duplicate instance declarations" error:
-- Domain/FP/SyntaxWithRanges.ag:506:10:
--     Duplicate instance declarations:
--       instance [overlap ok] IsTerm a => IsTerm (Maybe a)
--         -- Defined at Domain/FP/SyntaxWithRanges.ag:506:10
--       instance IsTerm a => IsTerm (Maybe a)
--         -- Defined at src/Domain/FP/SyntaxWithRanges.hs:271:10


--instance Pretty ModuleR where
--  pprint = PP.text . H.ppModule . build heliumView

--instance Pretty DeclR where
--  pprint = PP.text . H.ppDeclaration . build heliumView

--instance Pretty ExprR where
--  pprint = PP.text . H.ppExpression . build heliumView
}
