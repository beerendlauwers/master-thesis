optpragmas
{
{-# LANGUAGE TypeSynonymInstances, FlexibleInstances #-}
}

include "Domain/FP/CodeGeneration/Views.ag"

imports
{
import qualified Common.Library as CL (build)
import Text.PrettyPrint as PP
--import qualified Domain.FP.Helium as Helium --Imported in Domain/FP/CodeGeneration/Views.ag
}


{
class Pretty a where
  pprint :: a -> PP.Doc

instance Pretty a => Pretty (Maybe a) where
  pprint Nothing   = PP.text "Nothing"
  pprint (Just p)  = PP.parens $ PP.text "Just" PP.<+> PP.parens (pprint p)

instance Pretty a => Pretty [a] where
  pprint = foldr (\x xs -> pprint x $+$ xs) PP.empty

instance (Pretty a, Pretty b) => Pretty (a, b) where
  pprint (l, r) = PP.parens $ pprint l PP.<> PP.comma PP.<+> pprint r

instance Pretty Int where
  pprint = PP.int

instance Pretty Char where
  pprint = PP.char

instance Pretty Bool where
  pprint = PP.text . show

instance Pretty NameR where
  pprint (IdentR n _)    = PP.text n
  pprint (OperatorR n _) = PP.text n
  pprint (SpecialR n _)  = PP.text n

instance Pretty ModuleR where
  pprint = PP.text . Helium.ppModule . CL.build heliumWithRangesView

instance Pretty BodyR where
  pprint = PP.text . Helium.ppBody . CL.build heliumWithRangesView

instance Pretty FunBindR where
  pprint = PP.text . Helium.ppFunctionBinding . CL.build heliumWithRangesView

instance Pretty DeclR where
  pprint = PP.text . Helium.ppDeclaration . CL.build heliumWithRangesView

instance Pretty ExprR where
  pprint = PP.text . Helium.ppExpression . CL.build heliumWithRangesView

instance Pretty AltR where
  pprint = PP.text . Helium.ppAlternative . CL.build heliumWithRangesView

instance Pretty PatR where
  pprint = PP.text . Helium.ppPattern . CL.build heliumWithRangesView

instance Pretty Contract where
  pprint (CArr c1 c2) = PP.parens $ pprint c1 PP.<+> PP.text ">->" PP.<+> pprint c2
  pprint (CProp p) = PP.text p
  pprint (CFunctor o i) = pprint o PP.<+> PP.text "<@>" PP.<+> pprint i
  pprint (CBifunctor o il ir) = PP.parens $ pprint o PP.<+> PP.text "<@@>" PP.<+> PP.parens (pprint il PP.<> comma PP.<+> pprint ir)
  pprint (CVar v mc) = PP.text v
  pprint (CQuant cv cs) = case cv of
                           (CVar v _) -> PP.text "forall" PP.<+> PP.text v PP.<> PP.char '.' PP.<+> pprint cs
                           _          -> error "Quantifier needs variable"
  pprint (CTuple (c:[])) = pprint c
  pprint (CTuple (c:cs)) = PP.parens $ pprint c PP.<+> PP.char ',' PP.<+> pprint (CTuple cs)
  pprint (CTuple [])     = PP.empty
}
