-- ~/thesis/FPTutor/trunk/src$ ~/.cabal/bin/uuagc -dcfswH --module="Domain.FP.CodeGeneration.CodeGeneration" Domain/FP/CodeGeneration/CodeGeneration.ag

-- Include simplified syntax used by Ask-Elle
include "Domain/FP/SyntaxWithRanges.ag"

-- Include code to collect local identifiers, as well as uncontracted code
include "Domain/FP/CodeGeneration/CollectLocalIdents.ag"

-- Include Utils.ag
include "Domain/FP/CodeGeneration/Utils.ag"

-- Include code for generating Helium types for all function bindings and let bindings.
include "Domain/FP/CodeGeneration/CollectAllTypes.ag"

-- Include code to generate contracts for all function bindings and let bindings.
include "Domain/FP/CodeGeneration/GenerateContracts.ag"

-- Include code to apply substitutions
include "Domain/FP/ContractInferencing/Substitution.ag"

-- Include debug statement generating code
include "Domain/FP/CodeGeneration/DebugCode.ag"

imports
{
import qualified Domain.FP.Helium as H
import qualified ModuleSystem.ImportEnvironment as IE
import qualified Domain.FP.HeliumImportEnvs as HIE
import qualified Data.Map as DM
import qualified Data.Set as DS
import qualified Data.Maybe as DJ
import qualified Data.List as DL
}

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn copy                                                     :: self


{-

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
  chn varcnt   :: {Int}

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn copy                                             :: self

  -- We get this from the Helium compiler.
  inh topLevelTypes                                     :: {ImportEnvironment}

  -- Identifiers that shadow the top-level identifiers.
  inh localIdentifiers                                  :: {[NameR]}

  -- The 'main' function, the top-level point of entry. We'll start contract generation here.
  inh entryFunction                                     :: {String}

  -- We induce a contract from the type.
  inh contract                                          :: {Contract}

  -- Arity of parameters of a function. Example: foldr = [2,0,0]
  inh parameterArity                                    :: {ParameterArityEnvironment}

  -- Arity of function itself. Example: foldr = 3
  inh identifierArity                                   :: {FunctionArityEnvironment}

attr ExprR
  -- Function with contract applied to it.
  -- Used when passing a contracted function to higher-order function.
  -- Example: __ctrt_insert = __contracted_insert CONTRACT
  syn functionWithContract                              :: FunBindR

  -- The function identifier in contract wrappers.
  -- Used in the non-contracted function call if it's not part of a higher-order function.
  -- Example: __contracted_insert ctrt = assert "insert" ctrt funs
  --           where funs = fun (\x -> fun (\xs -> insert x xs))
  syn contractedFunction                                :: FunBindR

  -- It's possible a parameter is higher-order. In that case, we need to generate a
  -- higher-order version of it.
  syn higherOrderParameter                             :: [FunBindR]

  -- The applied contracted function identifier.
  -- Used to replace the non-contracted function call if it's not part of a higher-order function.
  -- Example: __app_insert (posx,x) (posxs,xs) = app (app __ctrt_insert posx x) posxs xs
  syn appliedContractedFunction                         :: FunBindR




attr ModuleR BodyR DeclR ExprR PatR AltR FunBindR GuardedExprR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR
  -- The contracted version of the code.
  syn contractedCode                                    :: self

-- TODO: We can add this after generating the contracted code?
{-
sem DeclR
   | DPatBindR
      -- We need to replace the original point of entry with a call to the contracted version.
      -- That's what we do here.
      lhs  .contractedCode      = case @pat.copy of
                                   (PVarR (IdentR x ri) rv) | x == @lhs.entryFunction -> DPatBindR (PVarR (IdentR x ri) rv) @loc.rhs @range.copy
                                   otherwise -> @self.copy
      loc  .rhs                 = RhsR @lhs.functionWithContract [] noRange
-}

-- TODO: Change functionWithContract, etc... to MaybeFunBindR and not FunBindR.
-- TODO: We need to take into account anonymous functions as well. We could contract those, too.
-- TODO: This will get generated for each and every function application, so there may be doubles. Perhaps an env?
sem ExprR
  | AppR
      -- TODO: Would this be necessary or even wanted? What if insert is called twice, like in (insert x xs,insert y ys) ?
      -- Example: __ctrt_insert = __contracted_insert CONTRACT
      lhs  .functionWithContract        = FunBindR Nothing @loc.name [] @loc.rhs noRange

      -- LHS
      -- (IdentR "insert" _) goes in, (IdentR "__ctrt_insert" _) goes out
      loc  .name                        = (IdentR (prefixFunctionWithContract @loc.functionIdentifier) noRange)
      loc  .isFunction                  = elem @loc.functionIdentifier @lhs.localIdentifiers || isInToplevel @loc.functionIdentifier
      loc  .functionIdentifier          = case @expr.copy of
                                           (VarR x _) -> x
                                           otherwise -> IdentR "_" noRange

      -- RHS --
      loc  .rhs                         = RhsR @loc.app [] noRange
      loc  .app                         = AppR @loc.rhsAppIdent [@loc.contract] noRange
      loc  .rhsAppIdent                 = VarR (prefixcontractedFunction @loc.functionIdentifier) noRange
      loc  .contract                    = @lhs.contract

      -- Example: __contracted_insert ctrt = assert "insert" ctrt funs
      --           where funs = fun (\x -> fun (\xs -> insert x xs))
      lhs  .contractedFunction          = FunBindR Nothing @loc.contractedName [makePVar "ctrt"] @loc.contractedRhs noRange

      -- LHS --
      -- (IdentR "insert" _) goes in, (IdentR "__contracted_insert" _) goes out
      loc  .contractedName              = (IdentR (prefixcontractedFunction @loc.functionIdentifier) noRange)

      -- RHS --
      loc  .contractedRhs               = RhsR @loc.assertApp [ makeVar "assert" 
                                                              , LStringR @loc.functionIdent noRange
                                                              , makeVar "ctrt"
                                                              , makeVar "funs" ]
      loc  .functionIdent               = (\(IdentR x _) -> x) @loc.functionIdentifier
      loc  .whereClause                 = DFunBindsR [FunBindR Nothing (IdentR "funs" noRange) [] @loc.whereRhs noRange] noRange
      loc  .whereRhs                    = RhsR (makeFuns @loc.funsPatterns @loc.funsBase) [] noRange
      loc  .funsPatterns                = [ "__x" ++ @loc.num ++ show x | [1..@loc.parameterArity] ]
      loc  .arityEnv                    = calculateArity @lhs.localType -- TODO: Generate localType. -- TODO: Implement calculateArity.
      loc  .funsBase                    = AppR (makeVar @loc.functionIdent) (map makeVar @loc.funsPatterns) noRange

      loc  .num     ::  uniqueref varcnt

-}



{-
-- Higher-order param generation
sem ExprR
  | AppR
      -- First, get the types.
      loc  .onlyTypes                   = (\(IE.ImportEnvironment _ _ typeEnv _ _ _) -> typeEnv) @lhs.topLevelTypes

       -- Then, generate arity of these types.
      loc  .arityEnv                    = calculateArity @loc.onlyTypes
      
      -- Get the type of the function that is being applied.
      loc  .functionType                = case @fun.copy of
                                           (VarR x _) -> maybe (error $ "Couldn't find this function in env: " ++ show x) id (DM.lookup x @loc.onlyTypes)
                                           x          -> error $ "Tried to get function identifier from this expression: " ++ show x -- TODO: Might want to get the actual type for this thing if it's not a simple VarR.

      -- Look up 
      lhs  .functionWithContract        = FunBindR Nothing @loc.name [] @loc.rhs noRange
-}

{
-- Given a list of patterns and a base value, generate a chain of 'fun' applications.
-- Example: funs = fun (\x -> fun (\xs -> insert x xs))
makeFuns :: [PatsR] -> ExprR -> ExprR
makeFuns xs b = foldr f b xs
  where f pat rest = AppR (makeVar "fun") [LambdaR pat rest noRangeR] noRangeR

makePVar :: String -> PatR
makePVar s = PVarR (IdentR s noRangeR) noRangeR

makeVar :: String -> ExprR
makeVar s = VarR (IdentR s noRangeR) noRangeR

prefixFunctionWithContract :: NameR -> NameR
prefixFunctionWithContract (IdentR name r)    = (IdentR ("__ctrt_"++name) r)
prefixFunctionWithContract (OperatorR name r) = (OperatorR ("---"++name++"---") r)
prefixFunctionWithContract _ = error "prefixFunctionWithContract: Haven't defined anything yet for SpecialR."

prefixcontractedFunction :: NameR -> NameR
prefixcontractedFunction (IdentR name r)    = (IdentR ("__contracted_"++name) r)
prefixcontractedFunction (OperatorR name r) = (OperatorR ("+++"++name++"+++") r)
prefixcontractedFunction _ = error "prefixcontractedFunction: Haven't defined anything yet for SpecialR."
}
