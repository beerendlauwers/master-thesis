-- ~/thesis/FPTutor/trunk/src$ ~/.cabal/bin/uuagc -dcfswH --module="Domain.FP.CodeGeneration.CodeGeneration" Domain/FP/CodeGeneration/CodeGeneration.ag

-- Include simplified syntax used by Ask-Elle
include "Domain/FP/SyntaxWithRanges.ag"

-- Include code to collect local identifiers, as well as uncontracted code
include "Domain/FP/CodeGeneration/CollectLocalIdents.ag"

-- Include Utils.ag
include "Domain/FP/CodeGeneration/Utils.ag"

-- Include code for generating Helium types for all function bindings and let bindings.
include "Domain/FP/CodeGeneration/CollectAllTypes.ag"

-- Include code to apply substitutions
include "Domain/FP/ContractInferencing/Substitution.ag"

-- Include debug statement generating code
include "Domain/FP/CodeGeneration/DebugCode.ag"

-- DEBUG: Inferencing code
include "Domain/FP/ContractInferencing/InferenceExprR.ag"
include "Domain/FP/ContractInferencing/InferenceFunBindR.ag"
include "Domain/FP/ContractInferencing/InferenceRhsR.ag"
include "Domain/FP/ContractInferencing/InferenceDeclR.ag"
include "Domain/FP/ContractInferencing/InferenceModuleR.ag"
include "Domain/FP/ContractInferencing/InferenceAltR.ag"
include "Domain/FP/ContractInferencing/InferenceBodyR.ag"

include "Domain/FP/ContractInferencing/Tests.ag"



-- Include syntax transformations
include "Domain/FP/ContractInferencing/SyntaxTransformations.ag"

imports
{
import qualified Domain.FP.Helium as H
import qualified ModuleSystem.ImportEnvironment as IE
import qualified Domain.FP.HeliumImportEnvs as HIE
import qualified Data.Map as DM
import qualified Data.Set as DS
import qualified Data.Maybe as DJ
import qualified Data.List as DL
import qualified Control.Monad as CM
}

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR MaybeConst
   syn copy                                                     :: self

-- Semantics for contracted version of function.
attr FunBindR
   syn contractedFunction                                       :: {Maybe FunBindR}

sem FunBindR
  | FBHoleR
      lhs  .contractedFunction          = Nothing
  | FunBindR
      -- Example: __contracted_insert ctrt posinfo = assertPos "name info" (generatePositionData posinfo) ctrt funs
      --           where funs = fun (\x -> fun (\xs -> __final_insert x xs))
      lhs  .contractedFunction          = Just @loc.contractedFunction
      loc  .contractedFunction          = mkFunbind @loc.contractedName [mkPVar "ctrt", mkPVar "posinfo"] @loc.contractedRhs

      -- LHS --
      loc  .functionIdentifier          = @name.copy 
      loc  .functionIdent               = getVar @loc.functionIdentifier
      loc  .finalFunctionIdent          = VarR (prefixFinalFunction @loc.functionIdentifier) (getRange @loc.functionIdentifier)
      loc  .contractedName              = prefixcontractedFunction @loc.functionIdentifier 

      -- RHS --
      loc  .posInfo                     = generatePositionText (any (>0) @loc.parameterArity) @loc.functionIdent
      loc  .assertApp                   = mkApp [mkVar "assertPos"
                                                ,(mkLit.mkStrLit) ("At " ++ @loc.posInfo)
                                                ,mkAppParens [mkVar "generatePositionData", mkVar "posinfo"]
                                                ,mkVar "ctrt"
                                                ,mkVar "funs"]
      loc  .contractedRhs               = mkRhs @loc.assertApp [@loc.whereClause]

      -- WHERE CLAUSE --
      loc  .whereClause                 = mkDFunbinds [mkFunbind (mkIdent "funs") [] @loc.whereRhs]
      loc  .whereRhs                    = mkRhs (makeFuns (map mkPVar @loc.funsPatterns) @loc.funsBase) []
      loc  .funsPatterns                = ["__x" ++ show @loc.num ++ show x | x <- [1.. @loc.arity]]
      loc  .arity                       = @loc.typeTreeArity
      loc  .parameterArity              = @loc.typeTreeParameterArity
      loc  .patsWithArity               = zip3 (take @loc.arity [1..]) @loc.parameterArity @loc.funsPatterns
      loc  .expandedFunsPatterns        = map (expandHigherOrderParams @loc.posInfo @loc.functionIdent) @loc.patsWithArity
      loc  .funsBase                    = mkApp $ @loc.finalFunctionIdent : @loc.expandedFunsPatterns

      loc  .num     ::  uniqueref varcnt

-- Semantics for app version of function.
attr FunBindR
   syn appFunction                                              :: {Maybe FunBindR}

sem FunBindR
  | FBHoleR
      lhs  .appFunction                 = Nothing
  | FunBindR
      -- Example: __app_insert ctrt posinfo (posx,x) (posxs,xs) = 
      --           appParam (appParam (__contracted_insert ctrt posinfo) (generatePositionData posx) x) (generatePositionData posxs) xs
      lhs  .appFunction                 = Just @loc.appFunction
      loc  .appFunction                 = mkFunbind @loc.appedName (@loc.ctrtParam : mkPVar "posinfo" : @loc.paramTuples) (mkRhs @loc.appedRhs [])

      -- LHS --
      loc  .appedName                   = prefixAppFunction @loc.functionIdentifier
      loc  .patternVars                 = map (:[]) ['a'..'z']
      loc  .posPatternVars              = map (\x -> "pos" ++ x) @loc.patternVars
      loc  .paramList                   = take @loc.arity $ zip @loc.posPatternVars @loc.patternVars
      loc  .paramTuples                 = map (\(pos,v) -> mkPTuple [mkPVar pos, mkPVar v]) @loc.paramList
      loc  .ctrtParam                   = mkPVar "ctrt"
      
      -- RHS --
      loc  .appedRhs                    = insertApps "appParam" @loc.appedRhsBase (map (\(p,v) -> ( mkAppParens [ mkVar "show", mkVar v, mkVar "++", mkVar "generatePositionData", mkVar p],mkVar v)) (reverse @loc.paramList)) 
      loc  .appedRhsBase                = mkAppParens [VarR @loc.contractedName noRangeR, mkVar "ctrt", mkVar "posinfo"]


-- Semantics for final version of function.
attr FunBindR
   syn finalFunction                                            :: {Maybe FunBindR}

sem FunBindR
  | FBHoleR
      lhs  .finalFunction               = Nothing
  | FunBindR
      -- Example: f x = g x could become
      -- __final_f x = __app_g ctrt (posx,x)
      lhs  .finalFunction               = Just @loc.finalFunction
      loc  .finalFunction               = FunBindR @feedback @loc.finalName @pats.copy @rhs.functionAppSelf @range.copy
      loc  .finalName                   = prefixFinalFunction @loc.functionIdentifier
      

-- Pass new definitions upwards to DeclR node.
attr FunBindsR
   syn contractedFunction use {:} {[]}                         :: {[Maybe FunBindR]}
   syn appFunction        use {:} {[]}                         :: {[Maybe FunBindR]}
   syn finalFunction      use {:} {[]}                         :: {[Maybe FunBindR]}




-- TODO: Put the contracts on their appropriate places in place of the VarRs.

attr ExprR
   -- Is this VarR a locally-known identifier (from patterns, or where-clause, or let)
   -- or a top-level function identifier?
   -- We use this information to determine what kind of transformation is necessary.
   syn isLocalParameter                                         :: {Bool}

attr ExprR ExprsR MaybeExprR ListExprR TupleExprR RangeR PositionR LiteralR AltR AltsR NameR MaybeNameR PatR PatsR ListPatsR TuplePatsR DeclR DeclsR RhsR FunBindR FunBindsR GuardedExprR GuardedExprsR BodyR
   -- A transformation that transforms all function applications from f to __app_f or __contracted_f (whichever applies).
   syn functionAppSelf                                            :: self

sem DeclR
   | DFunBindsR
      lhs  .functionAppSelf             = DFunBindsR @loc.allFunctions @range.copy
      loc  .allFunctions                = @funbinds.functionAppSelf ++ @loc.generatedFunctions
      loc  .generatedFunctions          = concatMap DJ.catMaybes [@funbinds.finalFunction, @funbinds.contractedFunction, @funbinds.appFunction]

sem ExprR
   | VarR ConR
      loc  .localType                   = maybeErr (show @loc.typeTreeCode) @loc.typeTreeType
      loc  .arity                       = S.arityOfTpScheme @loc.localType
      loc  .isFunction                  = @loc.arity > 0 

      -- 1 = prefixContract, 2 = id (but gets more information added), 3 = prefixApp, 4 = id, 5 = 1 + 2
      loc  .updateType                  = if @lhs.isBaseFunction
                                           -- Base function
                                           then if @loc.isLocalParameter
                                                 then 4 -- id, it's already been contracted
                                                 else 3 -- prefix __app, always prefix app to base function
                                           -- An argument
                                           else if @lhs.isAppliedToLocalFunction
                                                 -- Argument is applied to a local function
                                                 then if @loc.isFunction
                                                       -- Argument itself is a function
                                                       then if @loc.isLocalParameter
                                                             -- Argument is a locally-known function
                                                             then 4 -- id, it's already been contracted
                                                             -- Argument is a non-local function
                                                             else 1 -- prefix __contract, because it is not yet contracted
                                                       -- Argument itself it not a function
                                                       else 4 -- id, it does not have to be contracted
                                                 -- Argument is applied to a non-local function
                                                 else if @loc.isFunction
                                                       -- Argument itself is a function
                                                       then if @loc.isLocalParameter
                                                             -- Argument is a locally-known function
                                                             then 2 -- add information to give to the non-local function
                                                             -- Argument is a non-local function
                                                             else 5 -- prefix __contract and add information
                                                       -- Argument itself it not a function
                                                       else 6 -- id + position, it's for an app'ed version


      -- TODO: INSERT ACTUAL CONTRACT IN HERE, CURRENTLY It'S JUST THE GENERALIZED VERSION
      -- OR PASS AROUND SUBSTITUTIONS 
      loc  .inferencedContract          = subst @lhs.globalSubsts @loc.varContract
      loc  .contractAsExprR             = makeContract_Syn_Contract $ wrap_Contract ( sem_Contract @loc.inferencedContract ) Inh_Contract   

      loc  .updateFunction              = DJ.fromJust $ DL.lookup @loc.updateType [(1,prefixcontractedFunction),(2,id),(3,prefixAppFunction),(4,id),(5,prefixcontractedFunction),(6,id)]
      loc  .updatedVar                  = VarR (@loc.updateFunction @name.copy) @range.copy

      loc  .updateAsAppOrContracted     = mkAppParens [ @loc.updatedVar, @loc.contractAsExprR, @loc.posInfoAsLiterals ]

      loc  .posInfo                     = extractPositionData @range.copy
      loc  .posInfoAsLiterals           = posDataAsLiterals @loc.posInfo
      loc  .updateAsIdExtraInfo         = mkTuple [ @loc.posInfoAsLiterals, @loc.updatedVar ]
      loc  .updateAsCtrtExtraInfo       = mkTuple [ @loc.posInfoAsLiterals, mkApp [@loc.updatedVar, @loc.contractAsExprR] ]

      loc  .updateAsId                  = @loc.updatedVar
      loc  .updateAsIdWithPos           = mkTuple [ @loc.posInfoAsLiterals, @loc.updatedVar ]

      lhs  .functionAppSelf             = case @loc.updateType of
                                                1 -> @loc.updateAsAppOrContracted
                                                2 -> @loc.updateAsIdExtraInfo
                                                3 -> @loc.updateAsAppOrContracted
                                                4 -> @loc.updateAsId
                                                5 -> @loc.updateAsCtrtExtraInfo
                                                6 -> @loc.updateAsIdWithPos

sem ExprR
   | VarR 
      loc  .varContract                 = snd $ envLU @lhs.freshContractVariable @name.copy @lhs.env

   | ConR
      loc  .varContract                 = snd @loc.conversionResults
      loc  .conversionResults           = convertTopTypeToContract @lhs.freshContractVariable @loc.localType
      lhs .freshContractVariable        = fst @loc.conversionResults



attr ExprR ExprsR GuardedExprsR ListExprR TupleExprR MaybeConst
   -- (AppR) We fetch the value of @fun.isLocalParameter and pass this down to its arguments.
   inh isAppliedToLocalFunction                                 :: {Bool}

sem ExprR
   | VarR
      lhs  .isLocalParameter            = @loc.isLocalParameter
      loc  .isLocalParameter            = DL.elem (getVar @name.copy) @lhs.localIdentifiers
   | AppR
      lhs  .isLocalParameter            = @loc.isLocalParameter
      loc  .isLocalParameter            = @fun.isLocalParameter
   | HoleR TupleR ListR ConR LitR
      lhs  .isLocalParameter            = @loc.isLocalParameter
      loc  .isLocalParameter            = False

attr ExprR ExprsR ListExprR TupleExprR GuardedExprsR MaybeConst
   inh isBaseFunction                                           :: {Bool} -- Is the most deeply nested function being applied

sem MaybeExprR
   | JustExprR
      expr.isAppliedToLocalFunction     = False
      expr.isBaseFunction               = True
sem RhsR
   | RhsR
      expr.isAppliedToLocalFunction     = False
      expr.isBaseFunction               = True
   | GRhsR
      gexprs.isAppliedToLocalFunction   = False
      gexprs.isBaseFunction             = True
sem GuardedExprR
   | GExprR
      expr.isAppliedToLocalFunction     = False
      expr.isBaseFunction               = True
      guard.isAppliedToLocalFunction    = False
      guard.isBaseFunction              = True

sem ExprR
   | AppR
      -- Determine the base function. example: f is the base function in (((f (g x)) y) z)
      fun  .isBaseFunction              = @lhs.isBaseFunction
      args .isBaseFunction              = False

      -- Are the arguments being applied to a local identifier?
      args .isAppliedToLocalFunction    = @fun.isLocalParameter


attr Contract
   -- Converts a Contract datatype into an ExprR datatype ready for use in the AST.
   syn makeContract                                             :: ExprR

sem Contract
  |  CArr        lhs.makeContract = mkParens $ mkApp [ @c1.makeContract, mkVar ">->", @c2.makeContract ]
  |  CProp       lhs.makeContract = mkVar @p
  |  CFunctor    lhs.makeContract = mkParens $ mkApp [ @o.makeContract, mkVar "<@>", @i.makeContract ]
  |  CBifunctor  lhs.makeContract = mkParens $ mkApp [ @o.makeContract, mkVar "<@@>", mkTuple [ @il.makeContract, @ir.makeContract ] ]
  |  CVar        lhs.makeContract = mkVar @v -- TODO: Default contract etc.
--  |  CVar        lhs.makeContract = mkVar (replaceTrueContract @v) -- TODO: Default contract etc.
  |  CQuant      lhs.makeContract = @cs.makeContract
  |  CTuple      lhs.makeContract = error $ "The following CTuple got into contract inferencing: " ++ show @li


attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn removeFreeLambdas                                        :: self
   syn allReplacedLambdas    use {(++)} {[]}                    :: {[DeclR]}

attr ExprR ExprsR ListExprR TupleExprR GuardedExprR GuardedExprsR
   inh availablePatterns                                        :: {PatsR}
   inh patternAliases                                           :: {[NameR]}

sem ExprR
   | LambdaR
     -- We copy over the range of the original lambda so when further code is generated, it refers
     -- to the original lambda's location. 
     lhs  .removeFreeLambdas            = case length @lhs.patternAliases of
                                           0 -> VarR @loc.uniqueLambdaVar @range.copy
                                           _ -> AppR (VarR @loc.uniqueLambdaVar @range.copy) @loc.patternAliasesAsVars @range.copy
--     lhs  .removeFreeLambdas            = VarR @loc.uniqueLambdaVar @range.copy
     loc  .patternAliasesAsVars         = map (\n -> VarR n (getRange n)) @lhs.patternAliases

     -- We'll generate a function binding in the gist of "__lam1 = (original lambda)" and put those in a where-clause.
     lhs  .allReplacedLambdas           = [@loc.lambdaFunbind]
     loc  .lambdaWithRHS                = (mkRhs @loc.removeFreeLambdas @expr.allReplacedLambdas)
     loc  .lambdaFunbind                = case length @lhs.availablePatterns of
                                           0 -> DPatBindR (PVarR @loc.uniqueLambdaVar @range.copy) @loc.lambdaWithRHS @range.copy
                                           _ -> DFunBindsR [FunBindR Nothing @loc.uniqueLambdaVar @lhs.availablePatterns @loc.lambdaWithRHS @range.copy] noRangeR
--     loc  .lambdaFunbind                = DPatBindR (PVarR @loc.uniqueLambdaVar @range.copy) @loc.lambdaWithRHS @range.copy
     loc  .removeFreeLambdas            = LambdaR @pats.addAliasToPats @expr.removeFreeLambdas @range.copy
     loc  .uniqueLambdaVar              = IdentR ("__lam" ++ show @loc.num) @range.copy
     loc  .num                          ::  uniqueref varcnt

     -- Nested lambdas will need to be applied to the captured variables.
     expr .patternAliases               = @pats.usedAliases

     -- Nested lambdas need access to the variables that this lambda captured.
     expr .availablePatterns            = @pats.copy ++ @lhs.availablePatterns

sem RhsR
   | RhsR
     expr .availablePatterns            = []
     expr .patternAliases               = []
     loc  .newWhereClause               = case length @loc.funbindclause of 
                                           0 -> []
                                           _ -> @loc.funbindclause
     loc  .funbindclause                = @expr.allReplacedLambdas
     loc  .updatedRhsR                  = RhsR @expr.removeFreeLambdas (@loc.newWhereClause ++ @where.removeFreeLambdas) @range.copy
     lhs  .removeFreeLambdas            = @loc.updatedRhsR
     lhs  .allReplacedLambdas           = []
   | GRhsR
     gexprs.availablePatterns           = []
     gexprs.patternAliases              = []
     loc  .newWhereClause               = case length @loc.funbindclause of 
                                           0 -> []
                                           _ -> @loc.funbindclause
     loc  .funbindclause                = @gexprs.allReplacedLambdas
     loc  .updatedRhsR                  = GRhsR @gexprs.removeFreeLambdas (@loc.newWhereClause ++ @where.removeFreeLambdas) @range.copy
     lhs  .removeFreeLambdas            = @loc.updatedRhsR
     lhs  .allReplacedLambdas           = []

attr NameR RangeR PositionR LiteralR PatR PatsR ListPatsR TuplePatsR
   syn addAliasToPats                                           :: self

attr PatsR ListPatsR TuplePatsR
   syn usedAliases                                              :: {[NameR]}

sem PatsR ListPatsR TuplePatsR
   | Cons
     lhs  .addAliasToPats               = PAsR (mkIdent @loc.patternAlias) (PParenR @hd.copy (getRange @hd.copy)) (getRange @hd.copy) : @tl.addAliasToPats
     loc  .patternAlias                 = "__lAs" ++ show @loc.num
     lhs  .usedAliases                  = (IdentR @loc.patternAlias (getRange @hd.copy)) : @tl.usedAliases
     loc  .num                          ::  uniqueref varcnt
 
  | Nil
     lhs  .usedAliases                  = []



-- Convert all DPatBindR that are actually functions to DFunBindsR so we don't have to duplicate our code.
attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn patBindToFunBind                                         :: self

attr RhsR GuardedExprsR GuardedExprR
   -- When converting from DPatBindR to DFunBindsR, we'll generate a few new patterns that correspond to our
   -- arguments. We need to pass these down to RhsR so we can apply the expression to them.
   inh argumentsToBeAddedToExpr                                 :: {[String]}

sem DeclR
   | DPatBindR
     lhs  .patBindToFunBind             = @loc.conversion
     loc  .conversion                   = case @loc.arity > 0 of
                                           True  -> DFunBindsR [@loc.funBindFromPatBind] @range.copy
                                           False -> DPatBindR @pat.copy @rhs.copy @range.copy

     -- Get function name
     loc  .arity                        = calculateTypeArity (maybeErr @loc.typeTreeCode @loc.typeTreeType)
     loc  .functionNameFromPatBind      = case @pat.copy of
                                           (PVarR nm _) -> nm
                                           x            -> error $ "DPatBindR that defines a function, but does not bind it to a name! Code: " ++ show x

      -- Generate new patterns for our FunBindR
      loc  .uncaughtPatternVars         = ["__" ++ x : show y | x <- ['a'..'z'], y <- [0..9]]
      loc  .newPatternVars              = take @loc.arity @loc.uncaughtPatternVars


     -- Update RHS with new patterns
     rhs  .argumentsToBeAddedToExpr     = @loc.newPatternVars
     loc  .funBindFromPatBind           = FunBindR Nothing @loc.functionNameFromPatBind (map mkPVar @loc.newPatternVars) @rhs.patBindToFunBind @range.copy

sem RhsR
   | RhsR
     lhs  .patBindToFunBind             = case @loc.newPatternVars of
                                           [] -> RhsR @expr.patBindToFunBind @where.patBindToFunBind @range.copy
                                           _  -> RhsR (mkApp (mkParens @expr.patBindToFunBind : @loc.newPatternVars)) @where.patBindToFunBind @range.copy
     loc  .newPatternVars               = map mkVar @lhs.argumentsToBeAddedToExpr

   | GRhsR
     lhs  .patBindToFunBind             = GRhsR @gexprs.patBindToFunBind @where.patBindToFunBind @range.copy

sem GuardedExprR
   | GExprR
     lhs  .patBindToFunBind             = case @loc.newPatternVars of
                                           [] -> GExprR @guard.patBindToFunBind @expr.patBindToFunBind @range.copy
                                           _  -> GExprR @guard.patBindToFunBind (mkApp (mkParens @expr.patBindToFunBind : @loc.newPatternVars)) @range.copy
     loc  .newPatternVars               = map mkVar @lhs.argumentsToBeAddedToExpr


sem FunBindR
   | FunBindR
     rhs  .argumentsToBeAddedToExpr     = [] -- This is already a function binding, nothing to be added here.
sem AltR
   | AltR
     rhs  .argumentsToBeAddedToExpr     = [] -- An AltR pattern binding isn't going to be a function that we need to contract.


attr Contract 
  syn  copy                                             :: self

-- Synthesize free type variables for contract substutions.
attr Contract 
  syn  fcv       use {`DS.union`}  {DS.empty}           :: {DS.Set Contract}

-- Semantics for obtaining free contract variables.
sem Contract
  | CQuant
      lhs.fcv                   = DS.delete @cv.copy @cs.fcv

  | CVar
      lhs.fcv                   = DS.singleton @loc.copy
   

{

getFreeContractVars :: Contract -> DS.Set Contract
getFreeContractVars ctrt = synthesizeAttribute fcv_Syn_Contract ctrt

synthesizeAttribute :: (Syn_Contract -> a) -> Contract -> a
synthesizeAttribute attr ctrt = attr $ wrap_Contract (sem_Contract ctrt) Inh_Contract

nextUnique :: Int -> (Int, Int)
nextUnique u = (u + 1, u)

}


{
-- Given a list of patterns and a base value, generate a chain of 'fun' applications.
-- Example: funs = fun (\x -> fun (\xs -> insert x xs))
makeFuns :: PatsR -> ExprR -> ExprR
makeFuns xs b = foldr f b xs
  where f pat rest = mkAppParens $ (mkVar "fun") : [mkParens $ mkLambda [pat] rest]


prefixFunctionWithContract :: NameR -> NameR
prefixFunctionWithContract (IdentR name r)    = (IdentR ("__ctrt_"++name) r)
prefixFunctionWithContract (OperatorR name r) = (OperatorR ("---"++name++"---") r)
prefixFunctionWithContract _ = error "prefixFunctionWithContract: Haven't defined anything yet for SpecialR."

prefixcontractedFunction :: NameR -> NameR
prefixcontractedFunction (IdentR name r)    = (IdentR ("__contracted_"++name) r)
prefixcontractedFunction (OperatorR name r) = (OperatorR ("+++"++name++"+++") r)
prefixcontractedFunction x = x --SpecialR is used for the empty list, tuple constructors and unit. Nothing you can usefully contract.

prefixAppFunction :: NameR -> NameR
prefixAppFunction (IdentR name r)    = (IdentR ("__app_"++name) r)
prefixAppFunction (OperatorR name r) = (OperatorR ("___"++name++"___") r)
prefixAppFunction x = x --SpecialR is used for the empty list, tuple constructors and unit. Nothing you can usefully contract.

prefixFinalFunction :: NameR -> NameR
prefixFinalFunction (IdentR name r)    = (IdentR ("__final_"++name) r)
prefixFinalFunction (OperatorR name r) = (OperatorR ("___"++name++"___") r)
prefixFinalFunction _ = error "prefixAppFunction: Haven't defined anything yet for SpecialR."
}
