-- ~/thesis/FPTutor/trunk/src$ ~/.cabal/bin/uuagc -dcfswH --module="Domain.FP.CodeGeneration.CodeGeneration" Domain/FP/CodeGeneration/CodeGeneration.ag

-- Include simplified syntax used by Ask-Elle
include "Domain/FP/SyntaxWithRanges.ag"

-- Include code to collect local identifiers, as well as uncontracted code
include "Domain/FP/CodeGeneration/CollectLocalIdents.ag"

-- Include Utils.ag
include "Domain/FP/CodeGeneration/Utils.ag"

-- Include code for generating Helium types for all function bindings and let bindings.
include "Domain/FP/CodeGeneration/CollectAllTypes.ag"

-- Include code to generate contracts for all function bindings and let bindings.
include "Domain/FP/CodeGeneration/GenerateContracts.ag"

-- Include code to apply substitutions
include "Domain/FP/ContractInferencing/Substitution.ag"

-- Include debug statement generating code
include "Domain/FP/CodeGeneration/DebugCode.ag"

imports
{
import qualified Domain.FP.Helium as H
import qualified ModuleSystem.ImportEnvironment as IE
import qualified Domain.FP.HeliumImportEnvs as HIE
import qualified Data.Map as DM
import qualified Data.Set as DS
import qualified Data.Maybe as DJ
import qualified Data.List as DL
import qualified Control.Monad as CM
}

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn copy                                                     :: self
   chn varcnt                                                   :: {Int}

-- Semantics for contracted version of function.
attr FunBindR
   syn contractedFunction                                       :: FunBindR

sem FunBindR
  | FBHoleR
      lhs  .contractedFunction          = undefined
  | FunBindR
      -- Example: __contracted_insert ctrt posinfo argStrings = assertPos "name info" (generatePositionData posinfo) ctrt funs
      --           where funs = fun (\x -> fun (\xs -> __final_insert (x,head argstrings) (xs,head.tail argstrings)))
      lhs  .contractedFunction          = @loc.contractedFunction
      loc  .contractedFunction          = mkFunbind @loc.contractedName [mkPVar "ctrt", mkPVar "posinfo", mkPVar "argstrings"] @loc.contractedRhs

      -- LHS --
      loc  .functionIdentifier          = @name.copy 
      loc  .functionIdent               = getVar @loc.functionIdentifier
      loc  .finalName                   = VarR (prefixFinalFunction @loc.functionIdentifier) (getRange @loc.functionIdentifier)
      loc  .contractedName              = prefixcontractedFunction @loc.functionIdentifier 

      -- RHS --
      loc  .posInfo                     = generatePositionText (any (>0) @loc.parameterArity) @loc.functionIdent
      loc  .assertApp                   = mkApp [mkVar "assertPos"
                                                ,(mkLit.mkStrLit) @loc.posInfo
                                                ,mkAppParens [mkVar "generatePositionData", mkVar "posinfo"]
                                                ,mkVar "ctrt"
                                                ,mkVar "funs"]
      loc  .contractedRhs               = mkRhs @loc.assertApp [@loc.whereClause]

      -- WHERE CLAUSE --
      loc  .whereClause                 = mkDFunbinds [mkFunbind (mkIdent "funs") [] @loc.whereRhs]
      loc  .whereRhs                    = mkRhs (makeFuns (map mkPVar @loc.funsPatterns) @loc.funsBase) []
      loc  .funsPatterns                = ["__x" ++ show @loc.num ++ show x | x <- [1.. @loc.arity]]
      loc  .arityEnv                    = calculateArity $ getTypeEnv @lhs.topLevelTypes
      loc  .arity                       = maybe (error $ "Tried to look up " ++ @loc.functionIdent ++ " in arity env!") id (DM.lookup @loc.functionIdent @loc.arityEnv)
      loc  .heliumType                  = maybe (error $ "Tried to look up " ++ @loc.functionIdent ++ " in arity env!") id (DM.lookup (toHeliumWithRanges @loc.functionIdentifier) (getTypeEnv @lhs.topLevelTypes))
      loc  .parameterArityEnv           = calculateParameterArity $ getTypeEnv @lhs.topLevelTypes
      loc  .parameterArity              = maybe (error $ "Tried to look up " ++ @loc.functionIdent ++ " in parameterArity env!") id (DM.lookup @loc.functionIdent @loc.parameterArityEnv)
      loc  .patsWithArity               = zip3 (take @loc.arity [1..]) @loc.parameterArity @loc.funsPatterns
      loc  .expandedFunsPatterns        = map (expandHigherOrderParams @loc.functionIdent) @loc.patsWithArity
      loc  .argumentLookups             = map (\i -> mkInfixApp (mkVar "argstrings") (VarR (mkOp "!!") noRangeR) (mkLit $ mkIntLit i) ) [0.. @loc.arity] 
      loc  .argumentsWithStr            = map (\(e,p) -> mkTuple [e,p]) (zip @loc.expandedFunsPatterns @loc.argumentLookups)
      loc  .funsBase                    = mkApp $ @loc.finalName : @loc.argumentsWithStr

      loc  .num     ::  uniqueref varcnt

-- Semantics for app version of function.
attr FunBindR
   syn appFunction                                              :: FunBindR

sem FunBindR
  | FBHoleR
      lhs  .appFunction                 = undefined
  | FunBindR
      -- Example: __app_insert ctrt posinfo (posx,x) (posxs,xs) = 
      --           appParam (appParam (__contracted_insert ctrt posinfo) (generatePositionData posx) x) (generatePositionData posxs) xs
      lhs  .appFunction                 = @loc.appFunction
      loc  .appFunction                 = mkFunbind @loc.appedName (@loc.ctrtParam : mkPVar "posinfo" : @loc.paramTuples) (mkRhs @loc.appedRhs [])

      -- LHS --
      loc  .appedName                   = prefixAppFunction @loc.functionIdentifier
      loc  .patternVars                 = map (:[]) ['a'..'z']
      loc  .posPatternVars              = map (\x -> "pos" ++ x) @loc.patternVars
      loc  .strPatternVars              = map (\x -> "str" ++ x) @loc.patternVars
      loc  .paramList                   = take @loc.arity $ zip3 @loc.strPatternVars @loc.posPatternVars @loc.patternVars
      loc  .paramTuples                 = map (\(str,pos,v) -> mkPTuple [mkPVar str, mkPVar pos, mkPVar v]) @loc.paramList
      loc  .ctrtParam                   = mkPVar "ctrt"
      
      -- RHS --
      loc  .appedRhs                    = insertApps "appParam" @loc.appedRhsBase (map (\(s,p,v) -> ( mkAppParens [ mkVar s, mkVar "++", mkVar "generatePositionData", mkVar p],mkVar v)) (reverse @loc.paramList)) 
      loc  .appedRhsBase                = mkAppParens [VarR @loc.contractedName noRangeR, mkVar "ctrt", mkVar "posinfo"]

{-
-- Semantics for final version of function.
attr FunBindR
   syn finalFunction                                            :: FunBindR

sem FunBindR
  | FBHoleR
      lhs  .finalFunction               = undefined
  | FunBindR
      -- Example: f x = g x  becomes
      -- __final_f x = __app_g ctrt (posx,x)
      lhs  .finalFunction               = @loc.finalFunction

      -- LHS --
      loc  .finalName                   = prefixFinalFunction @loc.functionIdentifier
-}

-- Identify all function applications, convert from f to __app_f.
--attr ExprR
   --syn appedApplication                                         :: ExprR

-- TODO: Put the contracts on their appropriate places in place of the VarRs.

attr ExprR
   -- Is this VarR a locally-known identifier (from patterns, or where-clause, or let)
   -- or a top-level function identifier?
   -- We use this information to determine what kind of transformation is necessary.
   syn isLocalParameter                                         :: {Bool}

attr ExprR ExprsR GuardedExprsR
   -- (AppR) We fetch the value of @fun.isLocalParameter and pass this down to its arguments.
   inh isAppliedToLocalFunction                                 :: {Bool}

sem ExprR
   | VarR
      lhs  .isLocalParameter            = @loc.isLocalParameter
      loc  .isLocalParameter            = DL.elem (getVar @name.copy) @lhs.localIdentifiers
   | AppR
      lhs  .isLocalParameter            = @loc.isLocalParameter
      loc  .isLocalParameter            = @fun.isLocalParameter
   | HoleR TupleR ListR ConR
      lhs  .isLocalParameter            = False

attr ExprR ExprsR MaybeExprR ListExprR TupleExprR RangeR PositionR LiteralR AltR AltsR NameR MaybeNameR PatR PatsR ListPatsR TuplePatsR DeclR DeclsR RhsR FunBindR FunBindsR GuardedExprR GuardedExprsR
   -- A transformation that transforms all function applications from f to __app_f or __contracted_f (whichever applies).
   syn functionAppSelf                                            :: self

sem ExprR
   | VarR
      loc  .localType                   = fromJustMsg ("Could not find a type for variable " ++ getVar @name.copy) @loc.functionType
      loc  .arity                       = S.arityOfTpScheme @loc.localType
      loc  .isFunction                  = DJ.isJust $ lookupHeliumTypeMaybe @name.copy (getTypeEnv @lhs.topLevelTypes)

{-
      -- 1 = prefixContract, 2 = id (but gets more information added), 3 = prefixApp, 4 = id
      loc  .updateType                  = if @lhs.isBaseFunction
                                           -- Base function
                                           then if @loc.isLocalParameter
                                                 then 4 -- id, it's already been contracted
                                                 else 3 -- prefix __app, always prefix app to base function
                                           -- An argument
                                           else if @lhs.isAppliedToLocalFunction
                                                 -- Argument is applied to a local function
                                                 then if @loc.isFunction
                                                       -- Argument itself is a function
                                                       then if @loc.isLocalParameter
                                                             -- Argument is a non-local function
                                                             then 1 -- prefix __contract, because it is not yet contracted
                                                             -- Argument is a locally-known function
                                                             else 4 -- id, it's already been contracted
                                                       -- Argument itself it not a function
                                                       else 4 -- id, it does not have to be contracted

 @loc.isLocalParameter
                                                       then 

                                                 -- Argument is a local identifier
                                                 then if @loc.isFunction
                                                       then 4 --id, it's already been contracted
                                                       else 1 -- prefix __ctrt, because it's a function argument
                                                 -- Argument is a non-local identifier
                                                 else 3 -- prefix __app


-}
      loc  .updateType                  = determineUpdateFunction @loc.copy @lhs.isArgument (@loc.arity > 0) @lhs.isFullyApplied @lhs.isArgumentToFullyAppliedFunc @lhs.functionIsParameter @loc.isLocalParameter

      -- TODO: make this work for InfixAppR too!

      -- TODO: INSERT ACTUAL CONTRACT IN HERE, CURRENTLY It'S JUST THE GENERALIZED VERSION
      -- OR PASS AROUND SUBSTITUTIONS 
      loc  .varContract                 = maybe proptrue id (DM.lookup (getVar @name.copy) @lhs.heliumGeneratedContracts)
      loc  .contractAsExprR             = makeContract_Syn_Contract $ wrap_Contract ( sem_Contract @loc.varContract ) Inh_Contract   

      loc  .updateFunction              = DJ.fromJust $ DL.lookup @loc.updateType [(1,prefixcontractedFunction),(2,id),(3,prefixAppFunction),(4,id)]
      loc  .updatedVar                  = VarR (@loc.updateFunction @name.copy) @range.copy

      loc  .updateAsAppOrContracted     = mkAppParens [ @loc.updatedVar, @loc.contractAsExprR, @loc.posInfoAsLiterals ]

      loc  .posInfo                     = extractPositionData @range.copy
      loc  .posInfoAsLiterals           = posDataAsLiterals @loc.posInfo
      loc  .updateAsIdExtraInfo         = mkTuple [ (mkLit.mkStrLit.show) @name.copy, @loc.posInfoAsLiterals, @loc.updatedVar  ]

      loc  .updateAsId                  = @loc.updatedVar


      
      lhs  .functionAppSelf             = case @loc.updateType of
                                                1 -> @loc.updateAsAppOrContracted
                                                2 -> @loc.updateAsIdExtraInfo
                                                3 -> @loc.updateAsAppOrContracted
                                                4 -> @loc.updateAsId

      loc  .isArgument                  = @lhs.isArgument -- For debug purposes
      loc  .isFullyApplied              = @lhs.isFullyApplied -- For debug purposes

{-
attr ExprR ExprsR MaybeExprR ListExprR TupleExprR RangeR PositionR LiteralR AltR AltsR NameR MaybeNameR PatR PatsR ListPatsR TuplePatsR DeclR DeclsR RhsR FunBindR FunBindsR GuardedExprR GuardedExprsR
   -- Transformations that transforms all function applications from f to __app_f or __contracted_f (whichever applies).
   syn varAsApp                                                 :: self
   syn varAsCtrt                                                :: self
   syn varAsExtraInfo                                           :: self
   syn varAsId                                                  :: self

sem ExprR
   | VarR
      lhs  .varAsId                     = @loc.copy

      loc  .updatedVarToCtrt            = VarR (prefixcontractedFunction @name.copy) @range.copy
      loc  .varContract                 = maybe proptrue id (DM.lookup (getVar @name.copy) @lhs.heliumGeneratedContracts)
      loc  .contractAsExprR             = makeContract_Syn_Contract $ wrap_Contract ( sem_Contract @loc.varContract )
      loc  .posInfoAsLiterals           = posDataAsLiterals $ extractPositionData @range.copy
      lhs  .varAsCtrt                   = mkAppParens [ @loc.updatedVarToCtrt, @loc.contractAsExprR, @loc.posInfoAsLiterals ]

      loc  .updatedVarToApp             = VarR (prefixAppFunction @name.copy) @range.copy
      lhs  .varAsApp                    = mkAppParens [ @loc.updatedVarToCtrt, @loc.contractAsExprR, @loc.posInfoAsLiterals ]

      lhs  .varAsExtraInfo              = mkTuple [ (mkLit.mkStrLit.show) @name.copy, @loc.posInfoAsLiterals, @loc.copy ]

sem ExprR
  | AppR

      -- If the function being applied is a parameter, it means it has already been contracted, 
      -- so we don't need to prefix it with anything.
      loc  .isFunctionVarR              = isVarR @fun.copy
      loc  .functionAsVarR              = case @fun.copy of
                                           (VarR s r) -> Just $ VarR s r
                                           otherwise  -> Nothing                
      loc  .functionIsParameter         = DJ.isJust $ DL.lookup @loc.functionAsVarR @lhs.localIdentifiers

      loc  .tranformedApp               = @loc.copy
-}

{-
sem ExprR
   | VarR
      loc  .localType                   = fromJustMsg ("Could not find a type for variable " ++ getVar @name.copy) @loc.functionType
      loc  .arity                       = S.arityOfTpScheme @loc.localType
      loc  .identifierIsFunction        = DJ.isJust $ lookupHeliumTypeMaybe @name.copy (getTypeEnv @lhs.topLevelTypes)
      loc  .updateType                  = determineUpdateFunction @loc.copy @lhs.isArgument (@loc.arity > 0) @lhs.isFullyApplied @lhs.isArgumentToFullyAppliedFunc



      -- TODO: INSERT ACTUAL CONTRACT IN HERE, CURRENTLY It'S JUST THE GENERALIZED VERSION
      -- OR PASS AROUND SUBSTITUTIONS 
      loc  .varContract            = maybe proptrue id (DM.lookup (getVar @name.copy) @lhs.heliumGeneratedContracts)
      loc  .contractAsExprR             = makeContract_Syn_Contract $ wrap_Contract ( sem_Contract @loc.varContract ) Inh_Contract   

      loc  .updateFunction              = DJ.fromJust $ DL.lookup @loc.updateType [(1,prefixcontractedFunction),(2,id),(3,prefixAppFunction),(4,id)]
      loc  .updatedVar                  = VarR (@loc.updateFunction @name.copy) @range.copy

      loc  .updateAsAppOrContracted     = mkAppParens [ @loc.updatedVar, @loc.contractAsExprR, @loc.posInfoAsLiterals ]

      loc  .posInfo                     = extractPositionData @range.copy
      loc  .posInfoAsLiterals           = posDataAsLiterals @loc.posInfo
      loc  .updateAsIdExtraInfo         = mkTuple [ (mkLit.mkStrLit.show) @name.copy, @loc.posInfoAsLiterals, @loc.updatedVar  ]

      loc  .updateAsId                  = @loc.updatedVar


      
      lhs  .functionAppSelf             = case @loc.updateType of
                                                1 -> @loc.updateAsAppOrContracted
                                                2 -> @loc.updateAsIdExtraInfo
                                                3 -> @loc.updateAsAppOrContracted
                                                4 -> @loc.updateAsId

      loc  .isArgument                  = @lhs.isArgument -- For debug purposes
      loc  .isFullyApplied              = @lhs.isFullyApplied -- For debug purposes
-}

attr ExprR ExprsR ListExprR TupleExprR GuardedExprsR
   inh isArgument                                               :: {Bool}
   inh isFullyApplied                                           :: {Bool}
   inh isArgumentToFullyAppliedFunc                             :: {Bool}
   inh functionIsParameter                                      :: {Bool}
   syn functionIsParameter                                      :: {Bool}
   inh isBaseFunction                                           :: {Bool} -- Is the most deeply nested function being applied

sem MaybeExprR
   | JustExprR
      expr.isAppliedToLocalFunction     = False
      expr.isArgument                   = False
      expr.isFullyApplied               = False
      expr.isArgumentToFullyAppliedFunc = False
      expr.functionIsParameter          = False
      expr.isBaseFunction               = True
sem RhsR
   | RhsR
      expr.isAppliedToLocalFunction     = False
      expr.isArgument                   = False
      expr.isFullyApplied               = False
      expr.isArgumentToFullyAppliedFunc = False
      expr.functionIsParameter          = False
      expr.isBaseFunction               = True
   | GRhsR
      gexprs.isAppliedToLocalFunction   = False
      gexprs.isArgument                 = False
      gexprs.isFullyApplied             = False
      gexprs.isArgumentToFullyAppliedFunc = False
      gexprs.functionIsParameter        = False
      gexprs.isBaseFunction             = True

sem ExprR
   | AppR
      -- Determine the base function. example: f is the base function in (((f (g x)) y) z)
      fun  .isBaseFunction              = @lhs.isBaseFunction
      args .isBaseFunction              = False

      -- Are the arguments being applied to a local identifier?
      args .isAppliedToLocalFunction    = @fun.isLocalParameter

      -- Inform each argument that they are, in fact, an argument.
      
      args .isArgument                  = True
      fun  .isArgument                  = False
      fun  .isFullyApplied              = @loc.isFullyApplied
      args .isFullyApplied              = False
      args .isArgumentToFullyAppliedFunc = @loc.isFullyApplied
      loc  .isFullyApplied              = @loc.arity == 0
      loc  .errorMsgFunctionType        = "Could not fetch function type of expression " ++ show @loc.copy
      loc  .arity                       = S.arityOfTpScheme $ fromJustMsg @loc.errorMsgFunctionType @loc.functionType

      loc  .functionAsVarR              = case @fun.copy of
                                           (VarR s r) -> Just (getVar s)
                                           otherwise  -> Nothing                
      loc  .functionIsParameter         = maybe False (\a -> DL.elem a @lhs.localIdentifiers) @loc.functionAsVarR
      lhs  .functionIsParameter         = @loc.functionIsParameter
      args .functionIsParameter         = @fun.functionIsParameter || @loc.functionIsParameter

      loc  .isArgument                  = @lhs.isArgument -- For debug purposes

attr Contract
   -- Converts a Contract datatype into an ExprR datatype ready for use in the AST.
   syn makeContract                                             :: ExprR

sem Contract
  |  CArr        lhs.makeContract = mkParens $ mkApp [ @c1.makeContract, mkVar ">->", @c2.makeContract ]
  |  CProp       lhs.makeContract = mkVar @p
  |  CFunctor    lhs.makeContract = mkParens $ mkApp [ @o.makeContract, mkVar "<@>", @i.makeContract ]
  |  CBifunctor  lhs.makeContract = mkParens $ mkApp [ @o.makeContract, mkVar "<@@>", mkTuple [ @il.makeContract, @ir.makeContract ] ]
  |  CVar        lhs.makeContract = mkVar (replaceTrueContract @v) -- TODO: Default contract etc.
  |  CQuant      lhs.makeContract = @cs.makeContract
  |  CTuple      lhs.makeContract = error $ "The following CTuple got into contract inferencing: " ++ show @li


{-

      -- Example: f x y z becomes __app_f ctrt posinfo (posx,x) (posy,y) (posz,z)
      lhs  .appedApplication            = @loc.appedApplication

      -- Arguments --
      loc  .rangeData                   = @exprs.rangeData
      loc  .arguments                   = @exprs.copy

      -- Make tuples of known arguments with position information.
      loc  .knownArgs                   = map (\(pos,arg) -> mkTuple [arg,pos]) $ zip @loc.arguments (posDataAsLiterals $ extractPositionData @loc.rangeData)

      -- Position information of the function application itself.
      loc  .posInfo                     = extractPositionData @range.copy
      loc  .posInfoAsLiterals           = posDataAsLiterals @loc.posInfo

      -- TODO: Is this still necessary?
      -- Check type of function that is being applied, perhaps it's partial.
      -- In that case, we'll have to make it a lambda function to capture the rest of the arguments.
      loc  .arity                       = S.arityOfTpScheme @loc.functionType
      loc  .functionType                = fromJustMsg @loc.errorMsgFunctionType @fun.functionType
      loc  .errorMsgFunctionType        = "Could not fetch function type of expression " ++ show @loc.copy
      loc  .isFullyApplied              = @loc.arity > 1

      -- Ensure the function being applied is replaced with its __app version.
      loc  .functionApped               = @fun.functionApp

      -- Replace arguments that are functions with their __contracted version, as higher-order functions expect
      -- contracted functions.
      loc  .argumentTypes               = @exprs.functionType
      loc  .argumentAsApp               = @exprs.functionApp
      loc  .argumentAsCtrt              = @exprs.functionCtrt
      loc  .replacedArguments           = replaceArguments $ DL.zip4 @exprs.copy @loc.argumentTypes @loc.argumentAsApp @loc.argumentAsCtrt

      -}

      -- Construct new expression.
      --loc  .appedApplication            = 

-- Identify all function applications, convert from f x to __app_f x, even if the f is nested.
-- (Lambdas will have been given a name and put in the where-clause by now.)

{-
attr ExprR
   syn functionApp                                              :: {Maybe ExprR}
sem ExprR
   | AppR
      lhs  .functionApp                 = Just $ mkApp [ @fun.functionApp : @args.copy ]
   | VarR
      lhs  .functionApp                 = Just $ VarR (prefixAppFunction @name.copy) @range.copy
   | * - AppR VarR
      lhs  .functionApp                 = Nothing

attr ExprsR
   syn functionApp      use {(++)} {[]}                        :: {Maybe ExprsR}
sem ExprsR
   | Cons
      lhs  .functionApp                 = @hd.functionApp : @tl.functionApp
   | Nil
      lhs  .functionApp                 = []

-- Similar to above, but now convert f x to __contracted_f x.
attr ExprR
   syn functionCtrt                                            :: {Maybe ExprR}
sem ExprR
   | AppR
      lhs  .functionCtrt                = Just $ mkApp [ @fun.functionCtrt : @args.copy ]
   | VarR
      lhs  .functionCtrt                = Just $ VarR (prefixcontractedFunction @name.copy) @range.copy
   | * - AppR VarR
      lhs  .functionCtrt                = Nothing

attr ExprsR
   syn functionCtrt      use {(++)} {[]}                        :: {Maybe ExprsR}
sem ExprsR
   | Cons
      lhs  .functionCtrt                = @hd.functionCtrt : @tl.functionCtrt
   | Nil
      lhs  .functionCtrt                = []
-}

-- Collect range information
attr ExprR
   syn rangeData        use {(++)} {[]}                         :: {[RangeR]}
sem ExprR
   | *
     lhs  .rangeData                    = [@range.copy]


attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn removeFreeLambdas                                        :: self
   syn allReplacedLambdas    use {(++)} {[]}                    :: {[FunBindR]}

sem ExprR
   | LambdaR
     -- We copy over the range of the original lambda so when further code is generated, it refers
     -- to the original lambda's location. 
     lhs  .removeFreeLambdas            = VarR @loc.uniqueLambdaVar @range.copy

     -- We'll generate a function binding in the gist of "__lam1 = (original lambda)" and put those in a where-clause.
     lhs  .allReplacedLambdas           = [ mkFunbind @loc.uniqueLambdaVar [] (mkRhs @loc.removeFreeLambdas []) ]
     loc  .uniqueLambdaVar              = IdentR ("__lam" ++ show @loc.num) @range.copy
     loc  .num                          ::  uniqueref varcnt

sem RhsR
   | RhsR
     loc  .newWhereClause               = DFunBindsR @expr.allReplacedLambdas noRangeR : @where.removeFreeLambdas
     loc  .updatedRhsR                  = RhsR @expr.removeFreeLambdas @loc.newWhereClause @range.copy
     lhs  .removeFreeLambdas            = @loc.updatedRhsR
   | GRhsR
     loc  .newWhereClause               = DFunBindsR @gexprs.allReplacedLambdas noRangeR : @where.removeFreeLambdas
     loc  .updatedRhsR                  = GRhsR @gexprs.removeFreeLambdas @loc.newWhereClause @range.copy
     lhs  .removeFreeLambdas            = @loc.updatedRhsR


{-

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
  chn varcnt   :: {Int}

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn copy                                             :: self

  -- We get this from the Helium compiler.
  inh topLevelTypes                                     :: {ImportEnvironment}

  -- Identifiers that shadow the top-level identifiers.
  inh localIdentifiers                                  :: {[NameR]}

  -- The 'main' function, the top-level point of entry. We'll start contract generation here.
  inh entryFunction                                     :: {String}

  -- We induce a contract from the type.
  inh contract                                          :: {Contract}

  -- Arity of parameters of a function. Example: foldr = [2,0,0]
  inh parameterArity                                    :: {ParameterArityEnvironment}

  -- Arity of function itself. Example: foldr = 3
  inh identifierArity                                   :: {FunctionArityEnvironment}

attr ExprR
  -- Function with contract applied to it.
  -- Used when passing a contracted function to higher-order function.
  -- Example: __ctrt_insert = __contracted_insert CONTRACT
  syn functionWithContract                              :: FunBindR

  -- The function identifier in contract wrappers.
  -- Used in the non-contracted function call if it's not part of a higher-order function.
  -- Example: __contracted_insert ctrt = assert "insert" ctrt funs
  --           where funs = fun (\x -> fun (\xs -> insert x xs))
  syn contractedFunction                                :: FunBindR

  -- It's possible a parameter is higher-order. In that case, we need to generate a
  -- higher-order version of it.
  syn higherOrderParameter                             :: [FunBindR]

  -- The applied contracted function identifier.
  -- Used to replace the non-contracted function call if it's not part of a higher-order function.
  -- Example: __app_insert (posx,x) (posxs,xs) = app (app __ctrt_insert posx x) posxs xs
  syn appliedContractedFunction                         :: FunBindR




attr ModuleR BodyR DeclR ExprR PatR AltR FunBindR GuardedExprR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR
  -- The contracted version of the code.
  syn contractedCode                                    :: self

-- TODO: We can add this after generating the contracted code?
{-
sem DeclR
   | DPatBindR
      -- We need to replace the original point of entry with a call to the contracted version.
      -- That's what we do here.
      lhs  .contractedCode      = case @pat.copy of
                                   (PVarR (IdentR x ri) rv) | x == @lhs.entryFunction -> DPatBindR (PVarR (IdentR x ri) rv) @loc.rhs @range.copy
                                   otherwise -> @self.copy
      loc  .rhs                 = RhsR @lhs.functionWithContract [] noRange
-}

-- TODO: Change functionWithContract, etc... to MaybeFunBindR and not FunBindR.
-- TODO: We need to take into account anonymous functions as well. We could contract those, too.
-- TODO: This will get generated for each and every function application, so there may be doubles. Perhaps an env?
sem ExprR
  | AppR
      -- TODO: Would this be necessary or even wanted? What if insert is called twice, like in (insert x xs,insert y ys) ?
      -- Example: __ctrt_insert = __contracted_insert CONTRACT
      lhs  .functionWithContract        = FunBindR Nothing @loc.name [] @loc.rhs noRange

      -- LHS
      -- (IdentR "insert" _) goes in, (IdentR "__ctrt_insert" _) goes out
      loc  .name                        = (IdentR (prefixFunctionWithContract @loc.functionIdentifier) noRange)
      loc  .isFunction                  = elem @loc.functionIdentifier @lhs.localIdentifiers || isInToplevel @loc.functionIdentifier
      loc  .functionIdentifier          = case @expr.copy of
                                           (VarR x _) -> x
                                           otherwise -> IdentR "_" noRange

      -- RHS --
      loc  .rhs                         = RhsR @loc.app [] noRange
      loc  .app                         = AppR @loc.rhsAppIdent [@loc.contract] noRange
      loc  .rhsAppIdent                 = VarR (prefixcontractedFunction @loc.functionIdentifier) noRange
      loc  .contract                    = @lhs.contract

      -- Example: __contracted_insert ctrt = assert "insert" ctrt funs
      --           where funs = fun (\x -> fun (\xs -> insert x xs))
      lhs  .contractedFunction          = FunBindR Nothing @loc.contractedName [makePVar "ctrt"] @loc.contractedRhs noRange

      -- LHS --
      -- (IdentR "insert" _) goes in, (IdentR "__contracted_insert" _) goes out
      loc  .contractedName              = (IdentR (prefixcontractedFunction @loc.functionIdentifier) noRange)

      -- RHS --
      loc  .contractedRhs               = RhsR @loc.assertApp [ makeVar "assert" 
                                                              , LStringR @loc.functionIdent noRange
                                                              , makeVar "ctrt"
                                                              , makeVar "funs" ]
      loc  .functionIdent               = (\(IdentR x _) -> x) @loc.functionIdentifier
      loc  .whereClause                 = DFunBindsR [FunBindR Nothing (IdentR "funs" noRange) [] @loc.whereRhs noRange] noRange
      loc  .whereRhs                    = RhsR (makeFuns @loc.funsPatterns @loc.funsBase) [] noRange
      loc  .funsPatterns                = [ "__x" ++ @loc.num ++ show x | [1..@loc.parameterArity] ]
      loc  .arityEnv                    = calculateArity @lhs.localType -- TODO: Generate localType. -- TODO: Implement calculateArity.
      loc  .funsBase                    = AppR (makeVar @loc.functionIdent) (map makeVar @loc.funsPatterns) noRange

      loc  .num     ::  uniqueref varcnt

-}



{-
-- Higher-order param generation
sem ExprR
  | AppR
      -- First, get the types.
      loc  .onlyTypes                   = (\(IE.ImportEnvironment _ _ typeEnv _ _ _) -> typeEnv) @lhs.topLevelTypes

       -- Then, generate arity of these types.
      loc  .arityEnv                    = calculateArity @loc.onlyTypes
      
      -- Get the type of the function that is being applied.
      loc  .functionType                = case @fun.copy of
                                           (VarR x _) -> maybe (error $ "Couldn't find this function in env: " ++ show x) id (DM.lookup x @loc.onlyTypes)
                                           x          -> error $ "Tried to get function identifier from this expression: " ++ show x -- TODO: Might want to get the actual type for this thing if it's not a simple VarR.

      -- Look up 
      lhs  .functionWithContract        = FunBindR Nothing @loc.name [] @loc.rhs noRange
-}

{
-- Given a list of patterns and a base value, generate a chain of 'fun' applications.
-- Example: funs = fun (\x -> fun (\xs -> insert x xs))
makeFuns :: PatsR -> ExprR -> ExprR
makeFuns xs b = foldr f b xs
  where f pat rest = mkAppParens $ (mkVar "fun") : [mkParens $ mkLambda [pat] rest]


prefixFunctionWithContract :: NameR -> NameR
prefixFunctionWithContract (IdentR name r)    = (IdentR ("__ctrt_"++name) r)
prefixFunctionWithContract (OperatorR name r) = (OperatorR ("---"++name++"---") r)
prefixFunctionWithContract _ = error "prefixFunctionWithContract: Haven't defined anything yet for SpecialR."

prefixcontractedFunction :: NameR -> NameR
prefixcontractedFunction (IdentR name r)    = (IdentR ("__contracted_"++name) r)
prefixcontractedFunction (OperatorR name r) = (OperatorR ("+++"++name++"+++") r)
prefixcontractedFunction _ = error "prefixcontractedFunction: Haven't defined anything yet for SpecialR."

prefixAppFunction :: NameR -> NameR
prefixAppFunction (IdentR name r)    = (IdentR ("__app_"++name) r)
prefixAppFunction (OperatorR name r) = (OperatorR ("___"++name++"___") r)
prefixAppFunction _ = error "prefixAppFunction: Haven't defined anything yet for SpecialR."

prefixFinalFunction :: NameR -> NameR
prefixFinalFunction (IdentR name r)    = (IdentR ("__final_"++name) r)
prefixFinalFunction (OperatorR name r) = (OperatorR ("___"++name++"___") r)
prefixFinalFunction _ = error "prefixAppFunction: Haven't defined anything yet for SpecialR."
}
