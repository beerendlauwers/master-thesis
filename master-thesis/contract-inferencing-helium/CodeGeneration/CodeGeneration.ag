-- ~/thesis/FPTutor/trunk/src$ ~/.cabal/bin/uuagc -dcfswH --module="Domain.FP.CodeGeneration.CodeGeneration" Domain/FP/CodeGeneration/CodeGeneration.ag

-- Include simplified syntax used by Ask-Elle
include "Domain/FP/SyntaxWithRanges.ag"

-- Include code to collect local identifiers, as well as uncontracted code
include "Domain/FP/CodeGeneration/CollectLocalIdents.ag"

-- Include Utils.ag
include "Domain/FP/CodeGeneration/Utils.ag"

-- Include code for generating Helium types for all function bindings and let bindings.
include "Domain/FP/CodeGeneration/CollectAllTypes.ag"

-- Include code to generate contracts for all function bindings and let bindings.
include "Domain/FP/CodeGeneration/GenerateContracts.ag"

-- Include code to apply substitutions
include "Domain/FP/ContractInferencing/Substitution.ag"

-- Include debug statement generating code
include "Domain/FP/CodeGeneration/DebugCode.ag"

imports
{
import qualified Domain.FP.Helium as H
import qualified ModuleSystem.ImportEnvironment as IE
import qualified Domain.FP.HeliumImportEnvs as HIE
import qualified Data.Map as DM
import qualified Data.Set as DS
import qualified Data.Maybe as DJ
import qualified Data.List as DL
import qualified Control.Monad as CM
}

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR MaybeConst
   syn copy                                                     :: self
   chn varcnt                                                   :: {Int}

-- Semantics for contracted version of function.
attr FunBindR
   syn contractedFunction                                       :: {Maybe FunBindR}

sem FunBindR
  | FBHoleR
      lhs  .contractedFunction          = Nothing
  | FunBindR
      -- Example: __contracted_insert ctrt posinfo = assertPos "name info" (generatePositionData posinfo) ctrt funs
      --           where funs = fun (\x -> fun (\xs -> __final_insert x xs))
      lhs  .contractedFunction          = Just @loc.contractedFunction
      loc  .contractedFunction          = mkFunbind @loc.contractedName [mkPVar "ctrt", mkPVar "posinfo"] @loc.contractedRhs

      -- LHS --
      loc  .functionIdentifier          = @name.copy 
      loc  .functionIdent               = getVar @loc.functionIdentifier
      loc  .finalFunctionIdent          = VarR (prefixFinalFunction @loc.functionIdentifier) (getRange @loc.functionIdentifier)
      loc  .contractedName              = prefixcontractedFunction @loc.functionIdentifier 

      -- RHS --
      loc  .posInfo                     = generatePositionText (any (>0) @loc.parameterArity) @loc.functionIdent
      loc  .assertApp                   = mkApp [mkVar "assertPos"
                                                ,(mkLit.mkStrLit) ("At " ++ @loc.posInfo)
                                                ,mkAppParens [mkVar "generatePositionData", mkVar "posinfo"]
                                                ,mkVar "ctrt"
                                                ,mkVar "funs"]
      loc  .contractedRhs               = mkRhs @loc.assertApp [@loc.whereClause]

      -- WHERE CLAUSE --
      loc  .whereClause                 = mkDFunbinds [mkFunbind (mkIdent "funs") [] @loc.whereRhs]
      loc  .whereRhs                    = mkRhs (makeFuns (map mkPVar @loc.funsPatterns) @loc.funsBase) []
      loc  .funsPatterns                = ["__x" ++ show @loc.num ++ show x | x <- [1.. @loc.arity]]
      loc  .arityEnv                    = calculateArity $ getTypeEnv @lhs.topLevelTypes
      loc  .arity                       = maybe (error $ "Tried to look up " ++ @loc.functionIdent ++ " in arity env!") id (DM.lookup @loc.functionIdent @loc.arityEnv)
      loc  .heliumType                  = maybe (error $ "Tried to look up " ++ @loc.functionIdent ++ " in arity env!") id (DM.lookup (toHeliumWithRanges @loc.functionIdentifier) (getTypeEnv @lhs.topLevelTypes))
      loc  .parameterArityEnv           = calculateParameterArity $ getTypeEnv @lhs.topLevelTypes
      loc  .parameterArity              = maybe (error $ "Tried to look up " ++ @loc.functionIdent ++ " in parameterArity env!") id (DM.lookup @loc.functionIdent @loc.parameterArityEnv)
      loc  .patsWithArity               = zip3 (take @loc.arity [1..]) @loc.parameterArity @loc.funsPatterns
      loc  .expandedFunsPatterns        = map (expandHigherOrderParams @loc.posInfo @loc.functionIdent) @loc.patsWithArity
      loc  .funsBase                    = mkApp $ @loc.finalFunctionIdent : @loc.expandedFunsPatterns

      loc  .num     ::  uniqueref varcnt

-- Semantics for app version of function.
attr FunBindR
   syn appFunction                                              :: {Maybe FunBindR}

sem FunBindR
  | FBHoleR
      lhs  .appFunction                 = Nothing
  | FunBindR
      -- Example: __app_insert ctrt posinfo (posx,x) (posxs,xs) = 
      --           appParam (appParam (__contracted_insert ctrt posinfo) (generatePositionData posx) x) (generatePositionData posxs) xs
      lhs  .appFunction                 = Just @loc.appFunction
      loc  .appFunction                 = mkFunbind @loc.appedName (@loc.ctrtParam : mkPVar "posinfo" : @loc.paramTuples) (mkRhs @loc.appedRhs [])

      -- LHS --
      loc  .appedName                   = prefixAppFunction @loc.functionIdentifier
      loc  .patternVars                 = map (:[]) ['a'..'z']
      loc  .posPatternVars              = map (\x -> "pos" ++ x) @loc.patternVars
      loc  .paramList                   = take @loc.arity $ zip @loc.posPatternVars @loc.patternVars
      loc  .paramTuples                 = map (\(pos,v) -> mkPTuple [mkPVar pos, mkPVar v]) @loc.paramList
      loc  .ctrtParam                   = mkPVar "ctrt"
      
      -- RHS --
      loc  .appedRhs                    = insertApps "appParam" @loc.appedRhsBase (map (\(p,v) -> ( mkAppParens [ mkVar "show", mkVar v, mkVar "++", mkVar "generatePositionData", mkVar p],mkVar v)) (reverse @loc.paramList)) 
      loc  .appedRhsBase                = mkAppParens [VarR @loc.contractedName noRangeR, mkVar "ctrt", mkVar "posinfo"]


-- Semantics for final version of function.
attr FunBindR
   syn finalFunction                                            :: {Maybe FunBindR}

sem FunBindR
  | FBHoleR
      lhs  .finalFunction               = Nothing
  | FunBindR
      -- Example: f x = g x could become
      -- __final_f x = __app_g ctrt (posx,x)
      lhs  .finalFunction               = Just @loc.finalFunction
      loc  .finalFunction               = FunBindR @feedback @loc.finalName @pats.copy @rhs.functionAppSelf @range.copy
      loc  .finalName                   = prefixFinalFunction @loc.functionIdentifier
      

-- Pass new definitions upwards to DeclR node.
attr FunBindsR
   syn contractedFunction use {:} {[]}                         :: {[Maybe FunBindR]}
   syn appFunction        use {:} {[]}                         :: {[Maybe FunBindR]}
   syn finalFunction      use {:} {[]}                         :: {[Maybe FunBindR]}




-- TODO: Put the contracts on their appropriate places in place of the VarRs.

attr ExprR
   -- Is this VarR a locally-known identifier (from patterns, or where-clause, or let)
   -- or a top-level function identifier?
   -- We use this information to determine what kind of transformation is necessary.
   syn isLocalParameter                                         :: {Bool}

attr ExprR ExprsR MaybeExprR ListExprR TupleExprR RangeR PositionR LiteralR AltR AltsR NameR MaybeNameR PatR PatsR ListPatsR TuplePatsR DeclR DeclsR RhsR FunBindR FunBindsR GuardedExprR GuardedExprsR BodyR
   -- A transformation that transforms all function applications from f to __app_f or __contracted_f (whichever applies).
   syn functionAppSelf                                            :: self

sem DeclR
   | DFunBindsR
      lhs  .functionAppSelf             = DFunBindsR @loc.allFunctions @range.copy
      loc  .allFunctions                = @funbinds.functionAppSelf ++ @loc.generatedFunctions
      loc  .generatedFunctions          = concatMap DJ.catMaybes [@funbinds.finalFunction, @funbinds.contractedFunction, @funbinds.appFunction]

sem ExprR
   | VarR ConR
      loc  .localType                   = fromJustMsg ("Could not find a type for variable " ++ getVar @name.copy) @loc.functionType
      loc  .arity                       = S.arityOfTpScheme @loc.localType
      loc  .isFunction                  = @loc.arity > 0 

      -- 1 = prefixContract, 2 = id (but gets more information added), 3 = prefixApp, 4 = id, 5 = 1 + 2
      loc  .updateType                  = if @lhs.isBaseFunction
                                           -- Base function
                                           then if @loc.isLocalParameter
                                                 then 4 -- id, it's already been contracted
                                                 else 3 -- prefix __app, always prefix app to base function
                                           -- An argument
                                           else if @lhs.isAppliedToLocalFunction
                                                 -- Argument is applied to a local function
                                                 then if @loc.isFunction
                                                       -- Argument itself is a function
                                                       then if @loc.isLocalParameter
                                                             -- Argument is a locally-known function
                                                             then 4 -- id, it's already been contracted
                                                             -- Argument is a non-local function
                                                             else 1 -- prefix __contract, because it is not yet contracted
                                                       -- Argument itself it not a function
                                                       else 4 -- id, it does not have to be contracted
                                                 -- Argument is applied to a non-local function
                                                 else if @loc.isFunction
                                                       -- Argument itself is a function
                                                       then if @loc.isLocalParameter
                                                             -- Argument is a locally-known function
                                                             then 2 -- add information to give to the non-local function
                                                             -- Argument is a non-local function
                                                             else 5 -- prefix __contract and add information
                                                       -- Argument itself it not a function
                                                       else 6 -- id + position, it's for an app'ed version


      -- TODO: make this work for InfixAppR too!

      -- TODO: INSERT ACTUAL CONTRACT IN HERE, CURRENTLY It'S JUST THE GENERALIZED VERSION
      -- OR PASS AROUND SUBSTITUTIONS 
      loc  .varContract                 = maybe proptrue id (DM.lookup (getVar @name.copy) @lhs.heliumGeneratedContracts)
      loc  .contractAsExprR             = makeContract_Syn_Contract $ wrap_Contract ( sem_Contract @loc.varContract ) Inh_Contract   

      loc  .updateFunction              = DJ.fromJust $ DL.lookup @loc.updateType [(1,prefixcontractedFunction),(2,id),(3,prefixAppFunction),(4,id),(5,prefixcontractedFunction),(6,id)]
      loc  .updatedVar                  = VarR (@loc.updateFunction @name.copy) @range.copy

      loc  .updateAsAppOrContracted     = mkAppParens [ @loc.updatedVar, @loc.contractAsExprR, @loc.posInfoAsLiterals ]

      loc  .posInfo                     = extractPositionData @range.copy
      loc  .posInfoAsLiterals           = posDataAsLiterals @loc.posInfo
      loc  .updateAsIdExtraInfo         = mkTuple [ @loc.posInfoAsLiterals, @loc.updatedVar ]
      loc  .updateAsCtrtExtraInfo       = mkTuple [ @loc.posInfoAsLiterals, mkApp [@loc.updatedVar, @loc.contractAsExprR] ]

      loc  .updateAsId                  = @loc.updatedVar
      loc  .updateAsIdWithPos           = mkTuple [ @loc.posInfoAsLiterals, @loc.updatedVar ]

      lhs  .functionAppSelf             = case @loc.updateType of
                                                1 -> @loc.updateAsAppOrContracted
                                                2 -> @loc.updateAsIdExtraInfo
                                                3 -> @loc.updateAsAppOrContracted
                                                4 -> @loc.updateAsId
                                                5 -> @loc.updateAsCtrtExtraInfo
                                                6 -> @loc.updateAsIdWithPos

attr ExprR ExprsR GuardedExprsR ListExprR TupleExprR MaybeConst
   -- (AppR) We fetch the value of @fun.isLocalParameter and pass this down to its arguments.
   inh isAppliedToLocalFunction                                 :: {Bool}

sem ExprR
   | VarR
      lhs  .isLocalParameter            = @loc.isLocalParameter
      loc  .isLocalParameter            = DL.elem (getVar @name.copy) @lhs.localIdentifiers
   | AppR
      lhs  .isLocalParameter            = @loc.isLocalParameter
      loc  .isLocalParameter            = @fun.isLocalParameter
   | HoleR TupleR ListR ConR LitR
      lhs  .isLocalParameter            = @loc.isLocalParameter
      loc  .isLocalParameter            = False

attr ExprR ExprsR ListExprR TupleExprR GuardedExprsR MaybeConst
   inh isBaseFunction                                           :: {Bool} -- Is the most deeply nested function being applied

sem MaybeExprR
   | JustExprR
      expr.isAppliedToLocalFunction     = False
      expr.isBaseFunction               = True
sem RhsR
   | RhsR
      expr.isAppliedToLocalFunction     = False
      expr.isBaseFunction               = True
   | GRhsR
      gexprs.isAppliedToLocalFunction   = False
      gexprs.isBaseFunction             = True

sem ExprR
   | AppR
      -- Determine the base function. example: f is the base function in (((f (g x)) y) z)
      fun  .isBaseFunction              = @lhs.isBaseFunction
      args .isBaseFunction              = False

      -- Are the arguments being applied to a local identifier?
      args .isAppliedToLocalFunction    = @fun.isLocalParameter


attr Contract
   -- Converts a Contract datatype into an ExprR datatype ready for use in the AST.
   syn makeContract                                             :: ExprR

sem Contract
  |  CArr        lhs.makeContract = mkParens $ mkApp [ @c1.makeContract, mkVar ">->", @c2.makeContract ]
  |  CProp       lhs.makeContract = mkVar @p
  |  CFunctor    lhs.makeContract = mkParens $ mkApp [ @o.makeContract, mkVar "<@>", @i.makeContract ]
  |  CBifunctor  lhs.makeContract = mkParens $ mkApp [ @o.makeContract, mkVar "<@@>", mkTuple [ @il.makeContract, @ir.makeContract ] ]
  |  CVar        lhs.makeContract = mkVar (replaceTrueContract @v) -- TODO: Default contract etc.
  |  CQuant      lhs.makeContract = @cs.makeContract
  |  CTuple      lhs.makeContract = error $ "The following CTuple got into contract inferencing: " ++ show @li


attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn removeFreeLambdas                                        :: self
   syn allReplacedLambdas    use {(++)} {[]}                    :: {[FunBindR]}

sem ExprR
   | LambdaR
     -- We copy over the range of the original lambda so when further code is generated, it refers
     -- to the original lambda's location. 
     lhs  .removeFreeLambdas            = VarR @loc.uniqueLambdaVar @range.copy

     -- We'll generate a function binding in the gist of "__lam1 = (original lambda)" and put those in a where-clause.
     lhs  .allReplacedLambdas           = [ mkFunbind @loc.uniqueLambdaVar [] (mkRhs @loc.removeFreeLambdas []) ]
     loc  .uniqueLambdaVar              = IdentR ("__lam" ++ show @loc.num) @range.copy
     loc  .num                          ::  uniqueref varcnt

sem RhsR
   | RhsR
     loc  .newWhereClause               = case length @loc.funbindclause of 
                                           0 -> []
                                           _ -> [DFunBindsR @loc.funbindclause noRangeR]
     loc  .funbindclause                = @expr.allReplacedLambdas
     loc  .updatedRhsR                  = RhsR @expr.removeFreeLambdas (@loc.newWhereClause ++ @where.removeFreeLambdas) @range.copy
     lhs  .removeFreeLambdas            = @loc.updatedRhsR
   | GRhsR
     loc  .newWhereClause               = case length @loc.funbindclause of 
                                           0 -> []
                                           _ -> [DFunBindsR @loc.funbindclause noRangeR]
     loc  .funbindclause                = @gexprs.allReplacedLambdas
     loc  .updatedRhsR                  = GRhsR @gexprs.removeFreeLambdas (@loc.newWhereClause ++ @where.removeFreeLambdas) @range.copy
     lhs  .removeFreeLambdas            = @loc.updatedRhsR


-- Convert all DPatBindR that are actually functions to DFunBindsR so we don't have to duplicate our code.
attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn patBindToFunBind                                         :: self

attr RhsR GuardedExprsR GuardedExprR
   -- When converting from DPatBindR to DFunBindsR, we'll generate a few new patterns that correspond to our
   -- arguments. We need to pass these down to RhsR so we can apply the expression to them.
   inh argumentsToBeAddedToExpr                                 :: {[String]}

sem DeclR
   | DPatBindR
     lhs  .patBindToFunBind             = @loc.conversion
     loc  .conversion                   = case @loc.arity > 0 of
                                           True  -> DFunBindsR [@loc.funBindFromPatBind] @range.copy
                                           False -> DPatBindR @pat.copy @rhs.copy @range.copy

     -- Get function name
     loc  .arity                        = snd $ head $ DM.toList $ calculateArity @loc.heliumTypes
     loc  .functionNameFromPatBind      = case @pat.copy of
                                           (PVarR nm _) -> nm
                                           x            -> error $ "DPatBindR that defines a function, but does not bind it to a name! Code: " ++ show x

      -- Generate new patterns for our FunBindR
      loc  .uncaughtPatternVars         = ["__" ++ x : show y | x <- ['a'..'z'], y <- [0..9]]
      loc  .newPatternVars              = take @loc.arity @loc.uncaughtPatternVars


     -- Update RHS with new patterns
     rhs  .argumentsToBeAddedToExpr     = @loc.newPatternVars
     loc  .funBindFromPatBind           = FunBindR Nothing @loc.functionNameFromPatBind (map mkPVar @loc.newPatternVars) @rhs.patBindToFunBind @range.copy

sem RhsR
   | RhsR
     lhs  .patBindToFunBind             = RhsR (mkApp (mkParens @expr.patBindToFunBind : @loc.newPatternVars)) @where.patBindToFunBind @range.copy
     loc  .newPatternVars               = map mkVar @lhs.argumentsToBeAddedToExpr

   | GRhsR
     lhs  .patBindToFunBind             = GRhsR @gexprs.patBindToFunBind @where.patBindToFunBind @range.copy

sem GuardedExprR
   | GExprR
     lhs  .patBindToFunBind             = GExprR @guard.patBindToFunBind (mkApp (mkParens @expr.patBindToFunBind : @loc.newPatternVars)) @range.copy
     loc  .newPatternVars               = map mkVar @lhs.argumentsToBeAddedToExpr



{-
data GuardedExprR
   | GExprR
      guard    :: ExprR
      expr     :: ExprR
      range    :: RangeR

type GuardedExprsR = [GuardedExprR]

-- | Right hand side
data RhsR
   | RhsR
      expr     :: ExprR
      where    :: DeclsR
      range    :: RangeR
   | GRhsR
      gexprs   :: GuardedExprsR
      where    :: DeclsR
      range    :: RangeR
-}

{
-- Given a list of patterns and a base value, generate a chain of 'fun' applications.
-- Example: funs = fun (\x -> fun (\xs -> insert x xs))
makeFuns :: PatsR -> ExprR -> ExprR
makeFuns xs b = foldr f b xs
  where f pat rest = mkAppParens $ (mkVar "fun") : [mkParens $ mkLambda [pat] rest]


prefixFunctionWithContract :: NameR -> NameR
prefixFunctionWithContract (IdentR name r)    = (IdentR ("__ctrt_"++name) r)
prefixFunctionWithContract (OperatorR name r) = (OperatorR ("---"++name++"---") r)
prefixFunctionWithContract _ = error "prefixFunctionWithContract: Haven't defined anything yet for SpecialR."

prefixcontractedFunction :: NameR -> NameR
prefixcontractedFunction (IdentR name r)    = (IdentR ("__contracted_"++name) r)
prefixcontractedFunction (OperatorR name r) = (OperatorR ("+++"++name++"+++") r)
prefixcontractedFunction _ = error "prefixcontractedFunction: Haven't defined anything yet for SpecialR."

prefixAppFunction :: NameR -> NameR
prefixAppFunction (IdentR name r)    = (IdentR ("__app_"++name) r)
prefixAppFunction (OperatorR name r) = (OperatorR ("___"++name++"___") r)
prefixAppFunction _ = error "prefixAppFunction: Haven't defined anything yet for SpecialR."

prefixFinalFunction :: NameR -> NameR
prefixFinalFunction (IdentR name r)    = (IdentR ("__final_"++name) r)
prefixFinalFunction (OperatorR name r) = (OperatorR ("___"++name++"___") r)
prefixFinalFunction _ = error "prefixAppFunction: Haven't defined anything yet for SpecialR."
}
