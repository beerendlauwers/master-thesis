-- ~/thesis/FPTutor/trunk/src$ ~/.cabal/bin/uuagc -dcfswH --module="Domain.FP.CodeGeneration.CodeGeneration" Domain/FP/CodeGeneration/CodeGeneration.ag

-- Include simplified syntax used by Ask-Elle
include "Domain/FP/SyntaxWithRanges.ag"

-- Include code to collect local identifiers, as well as uncontracted code
include "Domain/FP/CodeGeneration/CollectLocalIdents.ag"

-- Include Utils.ag
include "Domain/FP/CodeGeneration/Utils.ag"

-- Include code for generating Helium types for all function bindings and let bindings.
include "Domain/FP/CodeGeneration/CollectAllTypes.ag"

-- Include code to generate contracts for all function bindings and let bindings.
include "Domain/FP/CodeGeneration/GenerateContracts.ag"

-- Include code to apply substitutions
include "Domain/FP/ContractInferencing/Substitution.ag"

-- Include debug statement generating code
include "Domain/FP/CodeGeneration/DebugCode.ag"

imports
{
import qualified Domain.FP.Helium as H
import qualified ModuleSystem.ImportEnvironment as IE
import qualified Domain.FP.HeliumImportEnvs as HIE
import qualified Data.Map as DM
import qualified Data.Set as DS
import qualified Data.Maybe as DJ
import qualified Data.List as DL
import qualified Control.Monad as CM
}

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn copy                                                     :: self
   chn varcnt                                                   :: {Int}

-- Semantics for contracted version of function.
attr FunBindR
   syn contractedFunction                                       :: FunBindR

sem FunBindR
  | FBHoleR
      lhs  .contractedFunction          = undefined
  | FunBindR
      -- Example: __contracted_insert ctrt posinfo = assertPos "name info" (generatePositionData posinfo) ctrt funs
      --           where funs = fun (\x -> fun (\xs -> insert x xs))
      lhs  .contractedFunction          = @loc.contractedFunction
      loc  .contractedFunction          = mkFunbind @loc.contractedName [mkPVar "ctrt", mkPVar "posinfo"] @loc.contractedRhs

      -- LHS --
      loc  .functionIdentifier          = @name.copy 
      loc  .functionIdent               = getVar @loc.functionIdentifier
      loc  .contractedName              = prefixcontractedFunction @loc.functionIdentifier

      -- RHS --
      loc  .posInfo                     = generatePositionText (any (>1) @loc.parameterArity) @loc.functionIdent
      loc  .assertApp                   = mkApp [mkVar "assertPos"
                                                ,(mkLit.mkStrLit) @loc.posInfo
                                                ,mkAppParens [mkVar "generatePositionData", mkVar "posinfo"]
                                                ,mkVar "ctrt"
                                                ,mkVar "funs"]
      loc  .contractedRhs               = mkRhs @loc.assertApp [@loc.whereClause]

      -- WHERE CLAUSE --
      loc  .whereClause                 = mkDFunbinds [mkFunbind (mkIdent "funs") [] @loc.whereRhs]
      loc  .whereRhs                    = mkRhs (makeFuns (map mkPVar @loc.funsPatterns) @loc.funsBase) []
      loc  .funsPatterns                = ["__x" ++ show @loc.num ++ show x | x <- [1.. @loc.arity]]
      loc  .arityEnv                    = calculateArity $ getTypeEnv @lhs.topLevelTypes
      loc  .arity                       = maybe (error $ "Tried to look up " ++ @loc.functionIdent ++ " in arity env!") id (DM.lookup @loc.functionIdent @loc.arityEnv)
      loc  .parameterArityEnv           = calculateParameterArity $ getTypeEnv @lhs.topLevelTypes
      loc  .parameterArity              = maybe (error $ "Tried to look up " ++ @loc.functionIdent ++ " in parameterArity env!") id (DM.lookup @loc.functionIdent @loc.parameterArityEnv)
      loc  .patsWithArity               = zip3 (take @loc.arity [1..]) @loc.parameterArity @loc.funsPatterns
      loc  .expandedFunsPatterns        = map (expandHigherOrderParams @loc.functionIdent) @loc.patsWithArity
      loc  .funsBase                    = mkApp $ mkVar @loc.functionIdent : @loc.expandedFunsPatterns

      loc  .num     ::  uniqueref varcnt

-- Semantics for app version of function.
attr FunBindR
   syn appFunction                                              :: FunBindR

sem FunBindR
  | FBHoleR
      lhs  .appFunction                 = undefined
  | FunBindR
      -- Example: __app_insert ctrt posinfo (posx,x) (posxs,xs) = 
      --           appParam (appParam (__contracted_insert ctrt posinfo) (generatePositionData posx) x) (generatePositionData posxs) xs
      lhs  .appFunction                 = @loc.appFunction
      loc  .appFunction                 = mkFunbind @loc.appedName (@loc.ctrtParam : mkPVar "posinfo" : @loc.paramTuples) (mkRhs @loc.appedRhs [])

      -- LHS --
      loc  .appedName                   = prefixAppFunction @loc.functionIdentifier
      loc  .patternVars                 = map (:[]) ['a'..'z']
      loc  .posPatternVars              = map (\x -> "pos" ++ x) @loc.patternVars
      loc  .paramList                   = take @loc.arity $ zip @loc.posPatternVars @loc.patternVars
      loc  .paramTuples                 = map (\(pos,v) -> mkPTuple [mkPVar pos, mkPVar v]) @loc.paramList
      loc  .ctrtParam                   = mkPVar "ctrt"
      
      -- RHS --
      loc  .appedRhs                    = insertApps "appParam" @loc.appedRhsBase (map (\(p,v) -> ( mkAppParens [mkVar "generatePositionData", mkVar p],mkVar v)) @loc.paramList) 
      loc  .appedRhsBase                = mkAppParens [VarR @loc.contractedName noRangeR, mkVar "ctrt", mkVar "posinfo"]

{-
-- Semantics for final version of function.
attr FunBindR
   syn finalFunction                                            :: FunBindR

sem FunBindR
  | FBHoleR
      lhs  .finalFunction               = undefined
  | FunBindR
      -- Example: f x = g x  becomes
      -- __final_f x = __app_g ctrt (posx,x)
      lhs  .finalFunction               = @loc.finalFunction

      -- LHS --
      loc  .finalName                   = prefixFinalFunction @loc.functionIdentifier
-}

-- TODO: Generate location information of function being applied, pass it through __app and through __contracted so
-- there it says the correct location information!!!!

-- Identify all function applications, convert from f to __app_f.
--attr ExprR
   --syn appedApplication                                         :: ExprR

-- TODO: Put the contracts on their appropriate places in place of the VarRs.

attr ExprR ExprsR MaybeExprR ListExprR TupleExprR RangeR PositionR LiteralR AltR AltsR NameR MaybeNameR PatR PatsR ListPatsR TuplePatsR DeclR DeclsR RhsR FunBindR FunBindsR GuardedExprR GuardedExprsR
   -- A transformation that transforms all function applications from f to __app_f or __contracted_f (whichever applies).
   syn functionAppSelf                                            :: self

sem ExprR
   | VarR
      loc  .localType                   = fromJustMsg ("Could not find a type for variable " ++ getVar @name.copy) @loc.functionType
      loc  .arity                       = S.arityOfTpScheme @loc.localType
      loc  .identifierIsFunction        = DJ.isJust $ lookupHeliumTypeMaybe @name.copy (getTypeEnv @lhs.topLevelTypes)
      loc  .update                      = if @lhs.isArgument && @loc.arity > 0 && not @lhs.isFullyApplied
                                           then prefixcontractedFunction -- Partially applied function argument
                                           else if @loc.arity > 0 && @lhs.isFullyApplied
                                                 then prefixAppFunction -- Fully applied argument or top-level function
                                                 else id -- Just a value

      loc  .functionAppSelf             = VarR (@loc.update @name.copy) @range.copy
      lhs  .functionAppSelf             = @loc.functionAppSelf

      loc  .isArgument                  = @lhs.isArgument -- For debug purposes
      loc  .isFullyApplied              = @lhs.isFullyApplied -- For debug purposes

attr ExprR ExprsR ListExprR TupleExprR GuardedExprsR
   inh isArgument                                               :: {Bool}
   inh isFullyApplied                                           :: {Bool}


sem MaybeExprR
   | JustExprR
      expr.isArgument                   = False
      expr.isFullyApplied               = False
sem RhsR
   | RhsR
      expr.isArgument                   = False
      expr.isFullyApplied               = False
   | GRhsR
      gexprs.isArgument                 = False
      gexprs.isFullyApplied             = False

sem ExprR
   | AppR
      -- Inform each argument that they are, in fact, an argument.
      args .isArgument                  = True
      fun  .isFullyApplied              = @loc.isFullyApplied
      args .isFullyApplied              = False
      loc  .isFullyApplied              = @loc.arity == 0
      loc  .errorMsgFunctionType        = "Could not fetch function type of expression " ++ show @loc.copy
      loc  .arity                       = S.arityOfTpScheme $ fromJustMsg @loc.errorMsgFunctionType @loc.functionType

      loc  .isArgument                  = @lhs.isArgument -- For debug purposes



{-

      -- Example: f x y z becomes __app_f ctrt posinfo (posx,x) (posy,y) (posz,z)
      lhs  .appedApplication            = @loc.appedApplication

      -- Arguments --
      loc  .rangeData                   = @exprs.rangeData
      loc  .arguments                   = @exprs.copy

      -- Make tuples of known arguments with position information.
      loc  .knownArgs                   = map (\(pos,arg) -> mkTuple [arg,pos]) $ zip @loc.arguments (posDataAsLiterals $ extractPositionData @loc.rangeData)

      -- Position information of the function application itself.
      loc  .posInfo                     = extractPositionData @range.copy
      loc  .posInfoAsLiterals           = posDataAsLiterals @loc.posInfo

      -- TODO: Is this still necessary?
      -- Check type of function that is being applied, perhaps it's partial.
      -- In that case, we'll have to make it a lambda function to capture the rest of the arguments.
      loc  .arity                       = S.arityOfTpScheme @loc.functionType
      loc  .functionType                = fromJustMsg @loc.errorMsgFunctionType @fun.functionType
      loc  .errorMsgFunctionType        = "Could not fetch function type of expression " ++ show @loc.copy
      loc  .isFullyApplied              = @loc.arity > 1

      -- Ensure the function being applied is replaced with its __app version.
      loc  .functionApped               = @fun.functionApp

      -- Replace arguments that are functions with their __contracted version, as higher-order functions expect
      -- contracted functions.
      loc  .argumentTypes               = @exprs.functionType
      loc  .argumentAsApp               = @exprs.functionApp
      loc  .argumentAsCtrt              = @exprs.functionCtrt
      loc  .replacedArguments           = replaceArguments $ DL.zip4 @exprs.copy @loc.argumentTypes @loc.argumentAsApp @loc.argumentAsCtrt

      -}

      -- Construct new expression.
      --loc  .appedApplication            = 

-- Identify all function applications, convert from f x to __app_f x, even if the f is nested.
-- (Lambdas will have been given a name and put in the where-clause by now.)

{-
attr ExprR
   syn functionApp                                              :: {Maybe ExprR}
sem ExprR
   | AppR
      lhs  .functionApp                 = Just $ mkApp [ @fun.functionApp : @args.copy ]
   | VarR
      lhs  .functionApp                 = Just $ VarR (prefixAppFunction @name.copy) @range.copy
   | * - AppR VarR
      lhs  .functionApp                 = Nothing

attr ExprsR
   syn functionApp      use {(++)} {[]}                        :: {Maybe ExprsR}
sem ExprsR
   | Cons
      lhs  .functionApp                 = @hd.functionApp : @tl.functionApp
   | Nil
      lhs  .functionApp                 = []

-- Similar to above, but now convert f x to __contracted_f x.
attr ExprR
   syn functionCtrt                                            :: {Maybe ExprR}
sem ExprR
   | AppR
      lhs  .functionCtrt                = Just $ mkApp [ @fun.functionCtrt : @args.copy ]
   | VarR
      lhs  .functionCtrt                = Just $ VarR (prefixcontractedFunction @name.copy) @range.copy
   | * - AppR VarR
      lhs  .functionCtrt                = Nothing

attr ExprsR
   syn functionCtrt      use {(++)} {[]}                        :: {Maybe ExprsR}
sem ExprsR
   | Cons
      lhs  .functionCtrt                = @hd.functionCtrt : @tl.functionCtrt
   | Nil
      lhs  .functionCtrt                = []
-}

-- Collect range information
attr ExprR
   syn rangeData        use {(++)} {[]}                         :: {[RangeR]}
sem ExprR
   | *
     lhs  .rangeData                    = [@range.copy]


{-

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
  chn varcnt   :: {Int}

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn copy                                             :: self

  -- We get this from the Helium compiler.
  inh topLevelTypes                                     :: {ImportEnvironment}

  -- Identifiers that shadow the top-level identifiers.
  inh localIdentifiers                                  :: {[NameR]}

  -- The 'main' function, the top-level point of entry. We'll start contract generation here.
  inh entryFunction                                     :: {String}

  -- We induce a contract from the type.
  inh contract                                          :: {Contract}

  -- Arity of parameters of a function. Example: foldr = [2,0,0]
  inh parameterArity                                    :: {ParameterArityEnvironment}

  -- Arity of function itself. Example: foldr = 3
  inh identifierArity                                   :: {FunctionArityEnvironment}

attr ExprR
  -- Function with contract applied to it.
  -- Used when passing a contracted function to higher-order function.
  -- Example: __ctrt_insert = __contracted_insert CONTRACT
  syn functionWithContract                              :: FunBindR

  -- The function identifier in contract wrappers.
  -- Used in the non-contracted function call if it's not part of a higher-order function.
  -- Example: __contracted_insert ctrt = assert "insert" ctrt funs
  --           where funs = fun (\x -> fun (\xs -> insert x xs))
  syn contractedFunction                                :: FunBindR

  -- It's possible a parameter is higher-order. In that case, we need to generate a
  -- higher-order version of it.
  syn higherOrderParameter                             :: [FunBindR]

  -- The applied contracted function identifier.
  -- Used to replace the non-contracted function call if it's not part of a higher-order function.
  -- Example: __app_insert (posx,x) (posxs,xs) = app (app __ctrt_insert posx x) posxs xs
  syn appliedContractedFunction                         :: FunBindR




attr ModuleR BodyR DeclR ExprR PatR AltR FunBindR GuardedExprR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR
  -- The contracted version of the code.
  syn contractedCode                                    :: self

-- TODO: We can add this after generating the contracted code?
{-
sem DeclR
   | DPatBindR
      -- We need to replace the original point of entry with a call to the contracted version.
      -- That's what we do here.
      lhs  .contractedCode      = case @pat.copy of
                                   (PVarR (IdentR x ri) rv) | x == @lhs.entryFunction -> DPatBindR (PVarR (IdentR x ri) rv) @loc.rhs @range.copy
                                   otherwise -> @self.copy
      loc  .rhs                 = RhsR @lhs.functionWithContract [] noRange
-}

-- TODO: Change functionWithContract, etc... to MaybeFunBindR and not FunBindR.
-- TODO: We need to take into account anonymous functions as well. We could contract those, too.
-- TODO: This will get generated for each and every function application, so there may be doubles. Perhaps an env?
sem ExprR
  | AppR
      -- TODO: Would this be necessary or even wanted? What if insert is called twice, like in (insert x xs,insert y ys) ?
      -- Example: __ctrt_insert = __contracted_insert CONTRACT
      lhs  .functionWithContract        = FunBindR Nothing @loc.name [] @loc.rhs noRange

      -- LHS
      -- (IdentR "insert" _) goes in, (IdentR "__ctrt_insert" _) goes out
      loc  .name                        = (IdentR (prefixFunctionWithContract @loc.functionIdentifier) noRange)
      loc  .isFunction                  = elem @loc.functionIdentifier @lhs.localIdentifiers || isInToplevel @loc.functionIdentifier
      loc  .functionIdentifier          = case @expr.copy of
                                           (VarR x _) -> x
                                           otherwise -> IdentR "_" noRange

      -- RHS --
      loc  .rhs                         = RhsR @loc.app [] noRange
      loc  .app                         = AppR @loc.rhsAppIdent [@loc.contract] noRange
      loc  .rhsAppIdent                 = VarR (prefixcontractedFunction @loc.functionIdentifier) noRange
      loc  .contract                    = @lhs.contract

      -- Example: __contracted_insert ctrt = assert "insert" ctrt funs
      --           where funs = fun (\x -> fun (\xs -> insert x xs))
      lhs  .contractedFunction          = FunBindR Nothing @loc.contractedName [makePVar "ctrt"] @loc.contractedRhs noRange

      -- LHS --
      -- (IdentR "insert" _) goes in, (IdentR "__contracted_insert" _) goes out
      loc  .contractedName              = (IdentR (prefixcontractedFunction @loc.functionIdentifier) noRange)

      -- RHS --
      loc  .contractedRhs               = RhsR @loc.assertApp [ makeVar "assert" 
                                                              , LStringR @loc.functionIdent noRange
                                                              , makeVar "ctrt"
                                                              , makeVar "funs" ]
      loc  .functionIdent               = (\(IdentR x _) -> x) @loc.functionIdentifier
      loc  .whereClause                 = DFunBindsR [FunBindR Nothing (IdentR "funs" noRange) [] @loc.whereRhs noRange] noRange
      loc  .whereRhs                    = RhsR (makeFuns @loc.funsPatterns @loc.funsBase) [] noRange
      loc  .funsPatterns                = [ "__x" ++ @loc.num ++ show x | [1..@loc.parameterArity] ]
      loc  .arityEnv                    = calculateArity @lhs.localType -- TODO: Generate localType. -- TODO: Implement calculateArity.
      loc  .funsBase                    = AppR (makeVar @loc.functionIdent) (map makeVar @loc.funsPatterns) noRange

      loc  .num     ::  uniqueref varcnt

-}



{-
-- Higher-order param generation
sem ExprR
  | AppR
      -- First, get the types.
      loc  .onlyTypes                   = (\(IE.ImportEnvironment _ _ typeEnv _ _ _) -> typeEnv) @lhs.topLevelTypes

       -- Then, generate arity of these types.
      loc  .arityEnv                    = calculateArity @loc.onlyTypes
      
      -- Get the type of the function that is being applied.
      loc  .functionType                = case @fun.copy of
                                           (VarR x _) -> maybe (error $ "Couldn't find this function in env: " ++ show x) id (DM.lookup x @loc.onlyTypes)
                                           x          -> error $ "Tried to get function identifier from this expression: " ++ show x -- TODO: Might want to get the actual type for this thing if it's not a simple VarR.

      -- Look up 
      lhs  .functionWithContract        = FunBindR Nothing @loc.name [] @loc.rhs noRange
-}

{
-- Given a list of patterns and a base value, generate a chain of 'fun' applications.
-- Example: funs = fun (\x -> fun (\xs -> insert x xs))
makeFuns :: PatsR -> ExprR -> ExprR
makeFuns xs b = foldr f b xs
  where f pat rest = mkAppParens $ (mkVar "fun") : [LambdaR [pat] rest noRangeR]


prefixFunctionWithContract :: NameR -> NameR
prefixFunctionWithContract (IdentR name r)    = (IdentR ("__ctrt_"++name) r)
prefixFunctionWithContract (OperatorR name r) = (OperatorR ("---"++name++"---") r)
prefixFunctionWithContract _ = error "prefixFunctionWithContract: Haven't defined anything yet for SpecialR."

prefixcontractedFunction :: NameR -> NameR
prefixcontractedFunction (IdentR name r)    = (IdentR ("__contracted_"++name) r)
prefixcontractedFunction (OperatorR name r) = (OperatorR ("+++"++name++"+++") r)
prefixcontractedFunction _ = error "prefixcontractedFunction: Haven't defined anything yet for SpecialR."

prefixAppFunction :: NameR -> NameR
prefixAppFunction (IdentR name r)    = (IdentR ("__app_"++name) r)
prefixAppFunction (OperatorR name r) = (OperatorR ("___"++name++"___") r)
prefixAppFunction _ = error "prefixAppFunction: Haven't defined anything yet for SpecialR."

prefixFinalFunction :: NameR -> NameR
prefixFinalFunction (IdentR name r)    = (IdentR ("__final_"++name) r)
prefixFinalFunction (OperatorR name r) = (OperatorR ("___"++name++"___") r)
prefixFinalFunction _ = error "prefixAppFunction: Haven't defined anything yet for SpecialR."
}
