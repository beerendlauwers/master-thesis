-- Some very basic debugging code that is useful for finding where exactly in the code something went wrong.
attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
  syn  simpledebug     use {++}         {[]}      :: {String}

-- simpledebug info synthesis
sem ModuleR
  | ModuleR     lhs   .simpledebug                       = "ModuleR\n" ++ show @loc.types ++ "\n" ++ @body.simpledebug

sem BodyR
  | BodyR       lhs   .simpledebug                       = "BodyR\n" ++ @decls.simpledebug
  | BHoleR      lhs   .simpledebug                       = "BHoleR\n"

sem RhsR
  | RhsR        lhs   .simpledebug                       = "RhsR\n      Code that will be compiled: " ++ (show $ show @loc.asModuleR) ++ "\n      Type tree:" ++ show @lhs.typeTree ++ @where.simpledebug ++ @expr.simpledebug
  | GRhsR       lhs   .simpledebug                       = "GRhsR\n      Code that will be compiled: " ++ (show $ show @loc.asModuleR) ++ "\n      Type tree:" ++ show @lhs.typeTree ++ "\n GExprRs length:" ++ show @loc.numGexprs ++ "\n" ++ @where.simpledebug ++ @gexprs.simpledebug

sem DeclR
  | DHoleR      lhs   .simpledebug                       = "DHoleR\n"
  | DEmptyR     lhs   .simpledebug                       = "DEmptyR\n"
  | DFunBindsR  lhs   .simpledebug                       = "DFunBindsR\n      Type tree:" ++ show @lhs.typeTree ++ @funbinds.simpledebug
  | DPatBindR   lhs   .simpledebug                       = "DPatBindR\n      Type tree:" ++ show @lhs.typeTree ++ @pat.simpledebug ++ @rhs.simpledebug

sem ExprR
  | HoleR       lhs   .simpledebug                       = "HoleR\n"
  | FeedbackR   lhs   .simpledebug                       = @expr.simpledebug
  | MustUseR    lhs   .simpledebug                       = @expr.simpledebug
  | CaseR       lhs   .simpledebug                       = "CaseR\n" ++ "Helium types available: " ++ show @lhs.topLevelTypes ++ "\n      Type tree:" ++ show @lhs.typeTree  ++ @expr.simpledebug ++ @alts.simpledebug
  | ConR        lhs   .simpledebug                       = "ConR\n" ++ @name.simpledebug
  | IfR         lhs   .simpledebug                       = "IfR\n" ++ @cond.simpledebug ++ @then.simpledebug ++ @else.simpledebug
  | InfixAppR   lhs   .simpledebug                       = "InfixAppR\n" ++ @left.simpledebug ++ @op.simpledebug ++ @right.simpledebug
  | LambdaR     lhs   .simpledebug                       = "LambdaR\n   Code that will be compiled: " ++ show @loc.lambdaAsModule ++ "\n      Type tree:" ++ show @lhs.typeTree  ++ @pats.simpledebug ++ @expr.simpledebug
  | LetR        lhs   .simpledebug                       = "LetR\n      Code that will be compiled:" ++ show @loc.asModuleR ++ "\n" ++ @decls.simpledebug ++ @expr.simpledebug
  | LitR        lhs   .simpledebug                       = "LitR\n" ++ @lit.simpledebug
  | AppR        lhs   .simpledebug                       = "AppR\n" ++ @fun.simpledebug ++ @args.simpledebug
  | ParenR      lhs   .simpledebug                       = @expr.simpledebug
  | TupleR      lhs   .simpledebug                       = "TupleR\n" ++ @exprs.simpledebug
  | VarR        lhs   .simpledebug                       = "VarR\n" ++ "Helium types available: " ++ show @lhs.topLevelTypes ++ "\n" ++ "    Variable type:" ++ show @loc.functionType ++ "\n"
  | EnumR       lhs   .simpledebug                       = "EnumR\n" ++ @from.simpledebug ++ @then.simpledebug ++ @to.simpledebug
  | ListR       lhs   .simpledebug                       = "ListR\n" ++ @exprs.simpledebug

sem MaybeExprR
  | NoExprR     lhs   .simpledebug                       = "NoExprR\n"
  | JustExprR   lhs   .simpledebug                       = "JustExprR\n" ++ @expr.simpledebug

sem AltR
  | AHoleR      lhs   .simpledebug                       = "AHoleR\n"
  | AltEmptyR   lhs   .simpledebug                       = "AltEmptyR\n"
  | AltR        lhs   .simpledebug                       = "AltR\n" ++ @pat.simpledebug ++ @rhs.simpledebug

sem FunBindR
  | FBHoleR     lhs   .simpledebug                       = "FBHoleR\n"
  | FunBindR    lhs   .simpledebug                       = "FunBindR\n   Type tree:" ++ show @lhs.typeTree ++ @name.simpledebug ++ @pats.simpledebug ++ @rhs.simpledebug

sem PatR
  | PHoleR      lhs   .simpledebug                       = "PHoleR\n"
  | PConR       lhs   .simpledebug                       = "PConR\n" ++ @name.simpledebug ++ @pats.simpledebug
  | PInfixConR  lhs   .simpledebug                       = "PInfixConR\n" ++ @left.simpledebug ++ @name.simpledebug ++ @right.simpledebug
  | PListR      lhs   .simpledebug                       = "PListR\n" ++ @pats.simpledebug
  | PLitR       lhs   .simpledebug                       = "PLitR\n" ++ @lit.simpledebug
  | PTupleR     lhs   .simpledebug                       = "PTupleR\n" ++ @pats.simpledebug
  | PVarR       lhs   .simpledebug                       = "PVarR\n" ++ @name.simpledebug
  | PAsR        lhs   .simpledebug                       = "PAsR\n" ++ @name.simpledebug ++ @pat.simpledebug
  | PWildcardR  lhs   .simpledebug                       = "PWildrCardR\n"

sem LiteralR
  | LCharR LFloatR LIntR LStringR
     lhs   .simpledebug                                  = show @val

sem GuardedExprR
  | GExprR      lhs   .simpledebug                       = "GExprR      Type tree:" ++ show @lhs.typeTree  ++ "\n" ++ @guard.simpledebug ++ @expr.simpledebug

sem FunBindsR
  | Cons        lhs   .simpledebug                       = "Cons FunBindsR\n" ++ "      Type tree:" ++ show @lhs.typeTree ++ "\n" ++ @hd.simpledebug ++ @tl.simpledebug

sem DeclsR
  | Cons        lhs   .simpledebug                       = "Cons DeclsR\n" ++ "      Type tree:" ++ show @lhs.typeTree ++ "\n" ++ @hd.simpledebug ++ @tl.simpledebug   

sem NameR
  | IdentR      lhs   .simpledebug                       = "IdentR\n" ++ show @name
  | OperatorR   lhs   .simpledebug                       = "OperatoR\n" ++ show @name
  | SpecialR    lhs   .simpledebug                       = "SpecialR\n" ++ show @name
