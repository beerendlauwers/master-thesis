-- Convert types to contracts.

-- Thread fresh contract vars accordingly.
-- LetR and RhsR/GRhsR are the nodes in the AST where the Helium types are generated,
-- so it makes sense to generate the contracts here immediately and store them in a shadowed environment.

sem ExprR
  | LetR
     loc.identifiers            = map fst $ DM.toList @loc.types
     loc.onlyTypes              = map snd $ DM.toList @loc.types
     loc.conversionResults      = mapConvertTopTypeToContract @lhs.freshContractVariable @loc.onlyTypes
     loc.freshContractVariable  = fst @loc.conversionResults
     loc.contracts              = snd @loc.conversionResults

     -- Add these contracts to the contract environment.
     loc.heliumIdents           = map (getVar.fromHeliumWithRanges) @loc.identifiers
     loc.newContracts           = DM.fromList $ zip @loc.heliumIdents @loc.contracts
     loc.newContractEnv         = DM.union @loc.newContracts @lhs.heliumGeneratedContracts
     decls.heliumGeneratedContracts = @loc.newContractEnv
     expr.heliumGeneratedContracts  = @loc.newContractEnv

     -- Route fresh contract variables.
     decls.freshContractVariable = @loc.freshContractVariable
     expr.freshContractVariable  = @decls.freshContractVariable

sem RhsR
  | RhsR GRhsR 
     loc.identifiers            = map fst $ DM.toList @loc.types
     loc.onlyTypes              = map snd $ DM.toList @loc.types
     loc.conversionResults      = mapConvertTopTypeToContract @lhs.freshContractVariable @loc.onlyTypes
     loc.freshContractVariable  = fst @loc.conversionResults
     loc.contracts              = snd @loc.conversionResults

     -- Add these contracts to the contract environment.
     loc.heliumIdents           = map (getVar.fromHeliumWithRanges) @loc.identifiers
     loc.newContracts           = DM.fromList $ zip @loc.heliumIdents @loc.contracts
     loc.newContractEnv         = DM.union @loc.newContracts @lhs.heliumGeneratedContracts
     where.heliumGeneratedContracts = @loc.newContractEnv

sem RhsR
  | RhsR
     -- Add these contracts to the contract environment.
     expr.heliumGeneratedContracts  = @loc.newContractEnv

     -- Route fresh contract variables.
     where.freshContractVariable = @loc.freshContractVariable
     expr.freshContractVariable  = @where.freshContractVariable

  | GRhsR
     -- Add these contracts to the contract environment.
     gexprs.heliumGeneratedContracts  = @loc.newContractEnv

     -- Route fresh contract variables.
     where.freshContractVariable = @loc.freshContractVariable
     gexprs.freshContractVariable  = @where.freshContractVariable

attr Contract MaybeConst
  syn  copy                                             :: self

-- Synthesize free type variables for contract substutions.
attr Contract
  syn  fcv       use {`DS.union`}  {DS.empty}           :: {DS.Set Contract}

-- Semantics for obtaining free contract variables.
sem Contract
  | CQuant
      lhs.fcv                   = DS.delete @cv.copy @cs.fcv

  | CVar
      lhs.fcv                   = DS.singleton @loc.copy
   

{

getFreeContractVars :: Contract -> DS.Set Contract
getFreeContractVars ctrt = synthesizeAttribute fcv_Syn_Contract ctrt

synthesizeAttribute :: (Syn_Contract -> a) -> Contract -> a
synthesizeAttribute attr ctrt = attr $ wrap_Contract (sem_Contract ctrt) Inh_Contract

nextUnique :: Int -> (Int, Int)
nextUnique u = (u + 1, u)

}
