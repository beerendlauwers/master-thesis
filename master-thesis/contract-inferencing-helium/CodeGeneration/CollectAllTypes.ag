-- ~/thesis/FPTutor/trunk/src$ ~/.cabal/bin/uuagc -dcfswH --module="Domain.FP.CodeGeneration.CollectAllTypes" Domain/FP/CodeGeneration/CollectAllTypes.ag

-- Include simplified syntax used by Ask-Elle
include "Domain/FP/SyntaxWithRanges.ag"

include "Domain/FP/CodeGeneration/CollectLocalIdents.ag"

include "Domain/FP/CodeGeneration/Utils.ag"

include "Domain/FP/CodeGeneration/GenerateContracts.ag"

include "Domain/FP/ContractInferencing/Substitution.ag"

include "Domain/FP/CodeGeneration/DebugCode.ag"

imports
{
import qualified Domain.FP.Helium as H
import qualified ModuleSystem.ImportEnvironment as IE
import qualified Domain.FP.HeliumImportEnvs as HIE
import qualified Data.Map as DM
import qualified Data.Set as DS
import qualified Data.Maybe as DJ
import qualified Data.List as DL
}

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn copy                                                     :: self

  -- We get this from the Helium compiler.
  inh topLevelTypes                                             :: {IE.ImportEnvironment}

  -- We need to be able to synthesize these for LambdaR.
  syn functionHeliumTypes   use {DM.union}    {DM.empty}        :: {IE.TypeEnvironment}

attr BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR MaybeExprR ListExprR TupleExprR ListPatsR TuplePatsR
   -- Highest integer used in a Helium type. We'll use this as an offset when generating
   -- fresh contracts; we don't want to accidentally clash with an existing type variable! 
   syn contractVariableOffset use {max} {(0::Int)}              :: {Int}

   -- First integer available for fresh contracts.
   chn freshContractVariable                                    :: {Int}

  -- These contracts are generated and populated from the types Helium provides us.
  inh heliumGeneratedContracts                                  :: {DM.Map String Contract}

--{
--data NestedEnv a = WithLocalDefinitions (Map NameR a) (NestedEnv a) |
--                   NoLocalDefinitions
--}

{- *** Start of semantics to get integer for fresh contract variables. *** -}
sem ModuleR
   | ModuleR
      -- At the top of the AST, we just convert the types that are given to us from the top level.
      loc  .types                  = getTypeEnv @lhs.topLevelTypes
      loc  .identifiers            = map fst $ DM.toList @loc.types
      loc  .onlyTypes              = map snd $ DM.toList @loc.types
      loc  .conversionResults      = mapConvertTopTypeToContract (@body.contractVariableOffset + 1) @loc.onlyTypes
      loc  .freshContractVariable  = fst @loc.conversionResults
      loc  .contracts              = snd @loc.conversionResults

      -- Add these contracts to the contract environment.
      -- Strip ranges information, this can cause duplicates.
      loc  .heliumIdents           = map (getVar.fromHeliumWithRanges) @loc.identifiers
      loc  .newContracts           = DM.fromList $ zip @loc.heliumIdents @loc.contracts
      body .heliumGeneratedContracts    = @loc.newContracts

      -- The first integer that is available for fresh contracts is one more than the highest one used by Helium.
      body .freshContractVariable       = max (@loc.freshContractVariable + 1) (maximum' $ map getMaxVariable HIE.importEnvs)
{- *** End of semantics to get integer for fresh contract variables. *** -}

{- *** Start of semantics to get the types of functions and let-definitions *** -}
-- Every node that has a (list of) declaration(s) has those declarations compiled
-- by the Helium compiler to get their types.
sem ExprR
   | LetR
    -- Generate types for this group of bindings.
      loc  .asModuleR           = makeModuleR @decls.copy
      loc  .heliumResults       = H.compileWithExtraEnv (render $ pprint @loc.asModuleR) @lhs.topLevelTypes
      loc  .types               = extractTypeNoRange @loc.heliumResults

      -- Generate an import environment with the top-level types from Helium.
      loc  .typesImportEnv      = generateImportEnv @loc.types
                                    
    -- Pass types down to decls and assign them to each definition, so everyone knows their type.
      decls.heliumTypes         = @loc.types

    -- Combine environment and pass it down to children.
      loc  .newEnv              = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes
      decls.topLevelTypes       = @loc.newEnv
      expr .topLevelTypes       = @loc.newEnv

sem RhsR
  | RhsR
    -- Generate types for this group of bindings.
      loc  .asModuleR           = makeModuleR @where.copy
      loc  .heliumResults       = H.compileWithExtraEnv (render $ pprint @loc.asModuleR) @lhs.topLevelTypes
      loc  .types               = extractTypeNoRange @loc.heliumResults

      -- Generate an import environment with the top-level types from Helium.
      loc  .typesImportEnv      = generateImportEnv @loc.types

    -- Pass types down to decls and assign them to each definition, so everyone knows their type.
      where.heliumTypes         = @loc.types

    -- Overwrite environment and pass it down to children.
      loc  .newEnv              = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes --IE.combineImportEnvironments @loc.importEnv @lhs.topLevelTypes
      where.topLevelTypes       = @loc.newEnv
      expr .topLevelTypes       = @loc.newEnv

  | GRhsR
    -- Generate types for this group of bindings.
      loc  .asModuleR           = makeModuleR @where.copy
      loc  .heliumResults       = H.compileWithExtraEnv (render $ pprint @loc.asModuleR) @lhs.topLevelTypes
      loc  .types               = extractTypeNoRange @loc.heliumResults

      -- Generate an import environment with the top-level types from Helium.
      loc  .typesImportEnv      = generateImportEnv @loc.types

    -- Pass types down to decls and assign them to each definition, so everyone knows their type.
      where.heliumTypes         = @loc.types

    -- Overwrite environment and pass it down to children.
      loc  .newEnv              = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes --IE.combineImportEnvironments @loc.importEnv @lhs.topLevelTypes
      where.topLevelTypes       = @loc.newEnv
      gexprs.topLevelTypes      = @loc.newEnv
{- *** End of semantics to get the types of functions and let-definitions *** -}

{- *** Start of semantics to get highest type variable integer. *** -}
sem ExprR
   | LetR   
     lhs.contractVariableOffset = max @loc.topLevelTypesMax @loc.newEnvMax
     loc.topLevelTypesMax       = getMaxVariable @lhs.topLevelTypes
     loc.newEnvMax              = getMaxVariable @loc.newEnv

sem RhsR
   | RhsR GRhsR
     lhs.contractVariableOffset = max @loc.topLevelTypesMax @loc.newEnvMax
     loc.topLevelTypesMax       = getMaxVariable @lhs.topLevelTypes
     loc.newEnvMax              = getMaxVariable @loc.newEnv
{- *** End of semantics to get highest type variable integer. *** -}

{- *** Start of semantics to pass down types to individual function definition node. *** -}
-- We now have the types of the declarations, pass those down to each individual definition.
attr DeclsR DeclR FunBindsR FunBindR
  inh heliumTypes                                       :: {IE.TypeEnvironment}

sem BodyR
  | BodyR
      decls.heliumTypes         = (\(IE.ImportEnvironment _ _ typeEnv _ _ _) -> typeEnv) @lhs.topLevelTypes

sem FunBindR
  | FunBindR
      -- We need to get the types of all variables, too. Pass the function type to the pattern list.
      pats.patType              = Just $ lookupHeliumType @name.copy @lhs.heliumTypes

      -- The contracts of each variable is also handy information to know.
      pats.patContract          = DM.lookup (getVar @name.copy) @lhs.heliumGeneratedContracts
      loc.patternContracts      = @pats.patternContracts

      -- Synthesize the list of patterns with their types, we'll add those to the import environment.
      loc.patternTypes          = scrubRangeInfo @pats.patternTypes

      -- Add synthesized list of patterns with types to import environment.
      rhs.topLevelTypes         = overwriteImportEnv (generateImportEnv @loc.patternTypes) @lhs.topLevelTypes
      

sem DeclR
  | DPatBindR
      -- Don't know if we'll need the contracts of patterns defined in tuples, but we might as well collect it, it's not too hard.
      loc.heliumType            = map (\name -> lookupHeliumType name @lhs.heliumTypes) @pat.localPatterns
      loc.heliumDebug           = @lhs.heliumTypes
{- *** End of of semantics to pass down types to individual function definition node. *** -}

{- *** Start of semantics to get types from patterns of anonymous lambda functions *** -}
sem ExprR
  | LambdaR
     --We need to get the types of the patterns inside a lambda, too.
     --We'll convert it to a function and then do the usual synthesis on it.
     loc.lambda                 = LambdaR @pats.copy @expr.copy @range.copy
     loc.lambdaAsFunbind        = convertExprToFunBind @loc.lambda
     loc.lambdaAsModule         = makeModuleR [DFunBindsR [@loc.lambdaAsFunbind] noRangeR]

     loc.heliumResults          = H.compileWithExtraEnv (render $ pprint @loc.lambdaAsModule) @lhs.topLevelTypes
     loc.types                  = extractTypeNoRange @loc.heliumResults
     loc.typesImportEnv         = generateImportEnv @loc.types
     loc.newEnv                 = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes

     loc.sem_ModuleR            = sem_ModuleR @loc.lambdaAsModule
     loc.inh_ModuleR            = Inh_ModuleR @lhs.entryFunction @lhs.localIdentifiers @loc.newEnv
     loc.wrap_ModuleR           = wrap_ModuleR @loc.sem_ModuleR @loc.inh_ModuleR
     loc.functionHeliumTypes    = functionHeliumTypes_Syn_ModuleR @loc.wrap_ModuleR

     -- Update the import environment.
     expr.topLevelTypes         = overwriteImportEnv (generateImportEnv @loc.functionHeliumTypes) @lhs.topLevelTypes

sem FunBindR
  | FunBindR
      lhs.functionHeliumTypes   = @loc.patternTypes
{- *** End of semantics to get types from patterns of anonymous lambda functions *** -}


{- *** Start of semantics to get the type of an expression in a case statement *** -}
sem ExprR
  | CaseR
     -- Need to convert the expression to a ModuleR, then do synthesis on it.
     loc.exprAsFunbind          = convertExprToFunBind @expr.copy
     loc.exprAsModule           = makeModuleR [DFunBindsR [@loc.exprAsFunbind] noRangeR]

     loc.heliumResults          = H.compileWithExtraEnv (render $ pprint @loc.exprAsModule) @lhs.topLevelTypes
     loc.types                  = extractTypeNoRange @loc.heliumResults

     -- Fetch the type, pass it to the AltR list.
     -- There, it will be used to type the patterns.
     loc.caseExpressionType     = lookupHeliumType (IdentR "__internalExpression__" noRangeR) @loc.types
     alts.altType               = @loc.caseExpressionType
{- *** End of semantics to get the type of an expression in a case statement *** -}

{- *** Start of semantics to get the types of patterns in an AltR. *** -}
attr AltsR AltR
  inh altType                                           :: {S.TpScheme}

sem AltR
  | AltR
      -- We need to get the types of the patterns. Pass the function type to the pattern list.
      pat.patType              = Just @lhs.altType

      -- Synthesize the list of patterns with their types, we'll add those to the import environment.
      loc.patternTypes          = scrubRangeInfo @pat.patternTypes

      -- Add synthesized list of patterns with types to import environment.
      rhs.topLevelTypes         = overwriteImportEnv (generateImportEnv @loc.patternTypes) @lhs.topLevelTypes
{- *** End of semantics to get the types of patterns in an AltR. *** -}


{- *** Start of semantics to calculate the type of a pattern. *** -}
attr PatsR PatR ListPatsR TuplePatsR
  inh patType                                           :: {Maybe S.TpScheme}
  inh tuplePatType                                      :: {Maybe [S.TpScheme]}
  inh patContract                                       :: {Maybe Contract}

  syn patternTypes                                      :: {IE.TypeEnvironment}
  syn patternContracts                                  :: {DM.Map String Contract}

-- Semantics for splitting up a function type and assigning it to a pattern.
sem PatsR
  | Cons
     -- Split up the type-generated contract and pass it to a pattern.
     loc.splitContract          = maybe Nothing (Just . splitFunctionContract) @lhs.patContract
     hd .patContract            = maybe Nothing (Just . fst) @loc.splitContract
     tl .patContract            = maybe Nothing (Just . snd) @loc.splitContract
     
     -- Split up the type and pass it to a pattern.
     loc.splitType              = maybe Nothing (Just . splitTopTypeScheme) @lhs.patType
     hd .patType                = maybe Nothing (Just . fst) @loc.splitType
     tl .patType                = maybe Nothing snd @loc.splitType

sem PatsR
  | Cons
     lhs.patternTypes           = DM.union @hd.patternTypes @tl.patternTypes
     lhs.patternContracts       = DM.union @hd.patternContracts @tl.patternContracts
  | Nil
     lhs.patternTypes           = DM.empty
     lhs.patternContracts       = DM.empty

sem PatR
  | PHoleR
     lhs.patternTypes           = DM.empty
     lhs.patternContracts       = DM.empty

  | PConR
     -- TODO: Expand this. We should use HIE.importEnvs.
     lhs.patternTypes           = DM.empty
     lhs.patternContracts       = DM.empty

  | PInfixConR
     -- TODO: Expand this. We should use HIE.importEnvs.

     -- Pattern stuff
     lhs.patternTypes           = DM.union @left.patternTypes @right.patternTypes
     loc.possibleResult         = DL.elemIndex True @loc.listOfConstructors
     loc.listOfConstructors     = [@loc.isListConstructor]

     loc.inhLeft                = [@loc.listToLeft]
     loc.inhright               = [@loc.listToRight]

     left.patType               = maybe Nothing ((!!) @loc.inhLeft ) @loc.possibleResult
     right.patType              = maybe Nothing ((!!) @loc.inhright) @loc.possibleResult

     -- Contract stuff
     lhs.patternContracts       = DM.union @left.patternContracts @right.patternContracts
     loc.ctrtLeft               = [@loc.listCtrtToLeft]
     loc.ctrtRight              = [@loc.listCtrtToRight]
     left.patContract           = maybe Nothing ((!!) @loc.ctrtLeft ) @loc.possibleResult
     right.patContract          = maybe Nothing ((!!) @loc.ctrtRight) @loc.possibleResult

     loc.infixConstructor       = getVar @name.copy

     -- List constructor
     loc.isListConstructor      = @loc.infixConstructor == ":"
     loc.listToLeft             = maybe Nothing (Just . getInnerListElem) @lhs.patType
     loc.listToRight            = @lhs.patType
     loc.listCtrtToLeft         = maybe Nothing (Just . getInnerListCtrt) @lhs.patContract
     loc.listCtrtToRight        = @lhs.patContract

  | PListR
     lhs.patternTypes           = @pats.patternTypes
     lhs.patternContracts       = @pats.patternContracts
  
  | PLitR
     lhs.patternTypes           = DM.empty
     lhs.patternContracts       = DM.empty

  | PParenR
     lhs.patternTypes           = @pat.patternTypes
     lhs.patternContracts       = @pat.patternContracts


  | PTupleR
     lhs.patternTypes           = @pats.patternTypes
     pats.tuplePatType          = if @loc.lengthCheck 
                                   then @loc.splitUpTuple
                                   else error $ "Size of tuple as a pattern differs from size of tuple as a type! " ++
                                                "Size of pattern tuple: " ++ (show @loc.lengthPats) ++ ", " ++ 
                                                "Size of type tuple: " ++ (show @loc.lengthPatType)
     loc.lengthCheck            = @loc.lengthPatType == @loc.lengthPats
     loc.splitUpTuple           = maybe Nothing (Just . splitUpTuple) @lhs.patType
     loc.lengthPatType          = maybe 0 length @loc.splitUpTuple
     loc.lengthPats             = length @pats.copy

     lhs.patternContracts       = @pats.patternContracts
     pats.patContract           = @lhs.patContract

  | PVarR
     lhs.patternTypes           = maybe DM.empty (DM.singleton (toHeliumWithRanges @name.copy)) @lhs.patType
     lhs.patternContracts       = maybe DM.empty (DM.singleton (getVar @name.copy)) @lhs.patContract
  | PAsR
     lhs.patternTypes           = DM.union @loc.pAs @pat.patternTypes
     lhs.patternContracts       = DM.union @loc.pAsCtrt @pat.patternContracts
     loc.pAs                    = maybe DM.empty (DM.singleton (toHeliumWithRanges @name.copy)) @lhs.patType
     loc.pAsCtrt                = maybe DM.empty (DM.singleton (getVar @name.copy)) @lhs.patContract
  | PWildcardR
     lhs.patternTypes           = DM.empty
     lhs.patternContracts       = DM.empty

sem TuplePatsR
  | Cons
     lhs.patternTypes           = DM.union @hd.patternTypes @tl.patternTypes
     hd .patType                = maybe Nothing (Just . head) @lhs.tuplePatType
     tl .tuplePatType           = maybe Nothing (Just . tail) @lhs.tuplePatType

     lhs.patternContracts       = DM.union @hd.patternContracts @tl.patternContracts
     hd .patContract            = maybe Nothing (Just . fst . splitTupleContract) @lhs.patContract
     tl .patContract            = maybe Nothing (Just . snd . splitTupleContract) @lhs.patContract
  | Nil
     lhs.patternTypes           = DM.empty
     lhs.patternContracts       = DM.empty

sem ListPatsR
  | Cons
     lhs.patternTypes           = DM.union @hd.patternTypes @tl.patternTypes
     lhs.patternContracts       = DM.union @hd.patternContracts @tl.patternContracts
     hd .patType                = maybe Nothing (Just . getInnerListElem) @lhs.patType
     tl .patType                = @lhs.patType
  | Nil
     lhs.patternTypes           = DM.empty
     lhs.patternContracts       = DM.empty
{- *** End of semantics to calculate the type of a pattern. *** -}

{- *** Start of semantics to suppress some warnings concerning patterns. *** -}
-- tuplePatType is populated inside the semantics above, so we can't give it a value from outside.
sem FunBindR
  | FunBindR
     pats.tuplePatType          = Nothing

-- Same as above.
sem AltR
  | AltR
     pat.tuplePatType           = Nothing

-- In a pattern binding, the Helium compiler automatically adds the patterns
-- with their type to the type environment.
sem DeclR
  | DPatBindR
     pat.tuplePatType           = Nothing
     pat.patType                = Nothing

-- We compile a lambda function using the Helium compiler as a named function,
-- so any pattern type synthesis stuff is done via the FunBindR way. 
sem ExprR
  | LambdaR
     pats.tuplePatType          = Nothing
     pats.patType               = Nothing


