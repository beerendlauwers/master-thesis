{-
-- For debugging, uncomment this block.
-- ~/thesis/FPTutor/trunk/src$ ~/.cabal/bin/uuagc -dcfswH --module="Domain.FP.CodeGeneration.CollectAllTypes" Domain/FP/CodeGeneration/CollectAllTypes.ag

-- Include simplified syntax used by Ask-Elle
include "Domain/FP/SyntaxWithRanges.ag"

include "Domain/FP/CodeGeneration/CollectLocalIdents.ag"

include "Domain/FP/CodeGeneration/Utils.ag"

include "Domain/FP/CodeGeneration/GenerateContracts.ag"

include "Domain/FP/ContractInferencing/Substitution.ag"

include "Domain/FP/CodeGeneration/DebugCode.ag"

imports
{
import qualified Domain.FP.Helium as H
import qualified ModuleSystem.ImportEnvironment as IE
import qualified Domain.FP.HeliumImportEnvs as HIE
import qualified Data.Map as DM
import qualified Data.Set as DS
import qualified Data.Maybe as DJ
import qualified Data.List as DL
}

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn copy                                                     :: self

-}

-- These imports are for getting the type tree from Helium.
imports
{
import StaticAnalysis.Miscellaneous.DoublyLinkedTree ( parent, attribute, children, DoublyLinkedTree(..) )
import StaticAnalysis.Miscellaneous.ConstraintInfo ( InfoTree, assignedType, self, LocalInfo(..) )
import qualified Main.Args as OPT ( Option ( Overloading, UseTutor ) )
import Top.Types.Substitution ( FixpointSubstitution )
import Top.Solver ( substitutionFromResult, qualifiersFromResult )
import StaticAnalysis.Inferencers.TypeInferencing ( sem_Module, Inh_Module(..), wrap_Module, importEnvironment_Inh_Module, options_Inh_Module, solveResult_Syn_Module, solveResult_Syn_Module, infoTree_Syn_Module, typeInferencing )
import qualified  StaticAnalysis.Miscellaneous.UHA_Source as UHASRC
import qualified  Top.Types.Substitution as TOPSUBST

}

{
type TypeTree = DoublyLinkedTree ((Maybe S.TpScheme,String,UHASRC.UHA_Source))
mkTypeTree p a c = DoublyLinkedTree p a c
mkTypeTreeWith tr f = DoublyLinkedTree (parent tr) (attribute tr) (f $ children tr)

emptyTree :: TypeTree
emptyTree = DoublyLinkedTree Nothing (Nothing,[],UHASRC.UHA_Def (Name_Identifier noRange [] [])) []


debugTypeInferencing :: [OPT.Option] -> IE.ImportEnvironment -> H.Module -> TypeTree
debugTypeInferencing options importEnv module_ =
   let res = wrap_Module (sem_Module module_) Inh_Module {
       	         importEnvironment_Inh_Module = importEnv,
		 options_Inh_Module = options }
       localTypeSchemes = typeSchemesAsInfoTree (substitutionFromResult $ solveResult_Syn_Module res)
                                                (qualifiersFromResult $ solveResult_Syn_Module res) 
                                                (infoTree_Syn_Module res)
   in localTypeSchemes

-- NOTES:
-- Expression VarR which refer to a function often appear to be incorrectly typed.
-- However, we do receive the correct types from the type inferencer, so perhaps
-- we could keep a shadowed environment of functions and look them up as necessary?
-- This system is still much more robust than what we have now, as we don't have to worry
-- about patterns getting the right types, those are done automatically and in one go.
-- Same goes for non-function expressions.

-- The good news is that we no longer have to split up the code and feed it to the compiler in bits, we can just get the type tree and top-level environment for the entire module and feed it to the AST appropriately.
-- H.compile' gives us the correct types for functions.
-- The type tree gives us the correct types for expressions.

-- TODO: Have FunBindR look up its identifier in the shadowed environment for its type.

-- TODO: Voorbeeld van Johan van een interessante functie
-- swap :: (a,b) -> (b,a)
-- cswap ;; cP ca cb >-> cP' cb ca
-- Is contract van cP en cP' hetzelfde? Eigenlijk zou het leuk zijn als dit kan gebeuren.




doDebugTypeInferencing s = 
 let result = either error id $ H.compile s
     topLevelEnv = (\(Right (_,i,_,_,_)) -> i) $ H.compile' False s
 in debugTypeInferencing [OPT.Overloading, OPT.UseTutor] topLevelEnv result

doHeliumTypeInferencing s = 
 let result = either error id $ H.compile s
     topLevelEnv = (\(Right (_,i,_,_,_)) -> i) $ H.compile' False s
 in typeInferencing [OPT.Overloading, OPT.UseTutor] topLevelEnv result

typeSchemesAsInfoTree :: FixpointSubstitution -> CLS.Predicates -> InfoTree -> TypeTree
typeSchemesAsInfoTree subst ps infoTree = 
 let local = attribute infoTree
     typedPar = case parent infoTree of
                      Just p -> Just $ typeSchemesAsInfoTree subst ps p
                      Nothing -> Nothing
     typedChildren = map (typeSchemesAsInfoTree subst ps) (children infoTree)
     typedLocal = case assignedType local of
                        Just tp -> let is     = TOPSUBST.ftv tp 
                                       ps'    = filter (any (`elem` is) . TOPSUBST.ftv) ps
                                       scheme = QN.generalizeAll (subst TOPSUBST.|-> (ps' QL..=>. tp))
                                   in Just scheme
                        Nothing -> Nothing
                        
 in DoublyLinkedTree typedPar (typedLocal,UHASRC.descriptionOfSource $ self local, self local) typedChildren

{-
-- For Proxima
typeSchemesInInfoTree :: FixpointSubstitution -> Predicates -> InfoTree -> [(Range, TpScheme)]
typeSchemesInInfoTree subst ps infoTree =
   let local = attribute infoTree
       rest  = concatMap (typeSchemesInInfoTree subst ps) (children infoTree)
   in case assignedType local of 
         Just tp -> let is     = ftv tp 
                        ps'    = filter (any (`elem` is) . ftv) ps
                        scheme = generalizeAll (subst |-> (ps' .=>. tp))
                    in (rangeOfSource (self local), scheme) : rest
         Nothing -> rest

-}
}

attr BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR MaybeConst
  -- We get this from the Helium compiler. It's a tree with types that resembles our AST.
  inh typeTree                                                  :: {TypeTree}

sem ModuleR
  | ModuleR
      body .typeTree            = doDebugTypeInferencing $ show @loc.copy -- Generate the type tree from our code.

-- Slice up the type tree we get from the Helium compiler.
sem DeclsR FunBindsR PatsR ListPatsR TuplePatsR TupleExprR ExprsR ListExprR
  | Cons
     hd    .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ children @lhs.typeTree
     tl    .typeTree            = mkTypeTreeWith @lhs.typeTree tail

sem DeclR
  | DPatBindR
     pat   .typeTree		= headErr (trMsg @lhs.typeTree $ show @loc.copy) $ children @lhs.typeTree
     rhs   .typeTree		= let newParent = (head.tail) $ children @lhs.typeTree
                                  in mkTypeTree (Just newParent) (attribute newParent) (children newParent)

sem FunBindR -- Need a type for this
  | FunBindR
     loc   .numPatterns         = length @pats.copy
     pats  .typeTree            = mkTypeTreeWith @lhs.typeTree (take @loc.numPatterns)
     rhs   .typeTree            = let newParent = (head.(drop @loc.numPatterns)) $ children @lhs.typeTree
                                  in mkTypeTree (Just newParent) (attribute newParent) (children newParent)

sem PatR -- Need a type for this
  | PInfixConR
     left  .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ children @lhs.typeTree
     right .typeTree            = let newParent = (head.tail) $ children @lhs.typeTree
                                  in mkTypeTree (Just newParent) (attribute newParent) (children newParent)
  | PAsR
     pat   .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ children @lhs.typeTree

sem RhsR
  | RhsR
     expr  .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ children @lhs.typeTree
     where .typeTree            = let newParent = (head.tail) $ children @lhs.typeTree
                                  in mkTypeTree (Just newParent) (attribute newParent) (children newParent)

  | GRhsR
      -- Odd format here; attribute list is of the form [guard,expr,guard,expr,...,wheredecls]
     loc   .numGexprs           = (length @gexprs.copy) * 2
     gexprs.typeTree            = mkTypeTreeWith @lhs.typeTree (take @loc.numGexprs)
     where .typeTree            = let newParent = (head.(drop @loc.numGexprs)) $ children @lhs.typeTree
                                  in mkTypeTree (Just newParent) (attribute newParent) (children newParent)

sem GuardedExprsR
  | Cons
     hd    .typeTree            = mkTypeTreeWith @lhs.typeTree (take 2)
     tl    .typeTree            = mkTypeTreeWith @lhs.typeTree (drop 2)

sem GuardedExprR
  | GExprR
     guard .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ children @lhs.typeTree
     expr  .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ tail $ children @lhs.typeTree

sem ExprR -- Need a type for this
  | LambdaR
     loc   .numPatterns         = length @pats.copy
     pats  .typeTree            = mkTypeTreeWith @lhs.typeTree (take @loc.numPatterns)
     expr  .typeTree            = let newParent = (head.(drop @loc.numPatterns)) $ children @lhs.typeTree
                                  in mkTypeTree (Just newParent) (attribute newParent) (children newParent)

  | IfR
     cond  .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ children @lhs.typeTree
     then  .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ drop 1 (children @lhs.typeTree)
     else  .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ drop 2 (children @lhs.typeTree)

  | CaseR
     expr  .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ children @lhs.typeTree
     -- An Alternative has two entries in the attribute list, one for the lhs, and one for the rhs.
     alts  .typeTree            = mkTypeTreeWith @lhs.typeTree tail

  | InfixAppR
     left  .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ children @lhs.typeTree
     op    .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ tail $ children @lhs.typeTree
     right .typeTree            = let newParent = (head.tail.tail) $ children @lhs.typeTree
                                  in mkTypeTree (Just newParent) (attribute newParent) (children newParent)

  | AppR
     fun   .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ children @lhs.typeTree
     args  .typeTree            = mkTypeTreeWith @lhs.typeTree tail

  | LetR
     decls .typeTree            = let newParent = head $ children @lhs.typeTree
                                  in mkTypeTree (Just newParent) (attribute newParent) (children newParent)
     expr  .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ tail $ children @lhs.typeTree

  -- FeedbackR and MustUseR (and NegR)?

  -- EnumR is a bit ugly, because the type tree is ambiguous:
  -- Both [1..2] and [1,2..] return the same type tree.
  -- We have to inspect the AST to determine where to send what types.
  | EnumR
     from  .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ children @lhs.typeTree
     then  .typeTree            = case @then.copy of
                                   NoExprR   -> emptyTree -- Dead end
                                   otherwise -> headErr (trMsg @lhs.typeTree $ show @loc.copy) $ tail $ children @lhs.typeTree
     to    .typeTree            = case @then.copy of
                                   NoExprR   -> headErr (trMsg @lhs.typeTree $ show @loc.copy) $ tail $ children @lhs.typeTree
                                   otherwise -> headErr (trMsg @lhs.typeTree $ show @loc.copy) $ drop 2 $ children @lhs.typeTree

sem AltsR
  | Cons
     hd    .typeTree            = mkTypeTreeWith @lhs.typeTree (take 2)
     tl    .typeTree            = mkTypeTreeWith @lhs.typeTree (drop 2)

sem AltR
  | AltR
     pat   .typeTree            = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ children @lhs.typeTree
     rhs   .typeTree            = let newParent = (head.tail) $ children @lhs.typeTree
                                  in mkTypeTree (Just newParent) (attribute newParent) (children newParent)
{-

  | DFunBindsR
     loc   .typeTreeType        = @funbinds.typeTreeType

attr FunBindsR FunBindR RhsR PatR
  -- A group of function bindings has the same type, we pass this upwards to the DeclR node.
  syn typeTreeType                                              :: {Maybe S.TpScheme}

attr PatsR
  syn typeTreeType            use {(++)}    {[]}                :: {[Maybe S.TpScheme]}

sem PatR
  | *
     lhs   .typeTreeType        = @loc.typeTreeType

sem FunBindsR
  | Cons
     lhs   .typeTreeType        = @hd.typeTreeType
  | Nil
     lhs   .typeTreeType        = Nothing

-- We can stitch together a type for every function binding that will serve our purposes of generating a contract.
sem FunBindR
  | FBHoleR
     lhs   .typeTreeType        = Nothing
  | FunBindR
     lhs   .typeTreeType        = @loc.typeTreeType
     loc   .typeTreeType        = 
     -- First, collect all the types from the patterns
     loc   .patSplitTypes       = map stripTypeScheme @pats.typeTreeType
     loc   .rhsSplitType        = stripTypeScheme @rhs.typeTreeType
     loc   .rhsSimpleType       = (\(ty,_,_) -> ty) @loc.rhsSplitType
     -- Get the type from RHS
     loc   .rhsType             = (\(mty,_,_) -> mty) $ attribute $ headErr (trMsg @loc.rhsTypeTree $ show @loc.copy) $ children @loc.rhsTypeTree
     loc   .rhsTypeTree         = headErr (trMsg @lhs.typeTree $ show @loc.copy) $ drop @loc.numPatterns $ children @lhs.typeTree
-}

-- Getting types from type tree
sem DeclR
  | DPatBindR -- a DPatBindR has a single pattern, which holds the type of the pattern binding. 
     loc   .typeTreeType        = (\(mty,_,_) -> mty) $ attribute $ headErr (trMsg @lhs.typeTree $ show @loc.copy) $ children @lhs.typeTree
     loc   .typeTreeCode        = (\(_,s,src) -> s ++ " " ++ show src) $ attribute @lhs.typeTree

sem FunBindR
  | FunBindR
     -- We can get the arity of a function binding by summing pattern count with arity count of the RHS.
     loc   .typeTreeArity       = @loc.numPatterns + @loc.rhsArity
     loc   .rhsArity            = calculateTypeArity (maybeErr @loc.typeTreeCode @rhs.typeTreeType)

     -- String to be used in case of an error message
     loc   .typeTreeCode        = (\(_,s,src) -> s ++ " " ++ show src) $ attribute @lhs.typeTree

     -- Parameter arity is similar.
     loc   .typeTreeParameterArity = @loc.fixedPatParamArity ++ @loc.rhsParameterArity
     -- Get parameter arity from patterns
     loc   .patsTreeTypes       = map (\x -> (\(mty,_,_) -> mty) $ attribute x) $ take @loc.numPatterns $ children @lhs.typeTree
     loc   .fixedPatParamArity  = map (head.emptyListToZero) @loc.patParameterArity
     loc   .patParameterArity   = map (\ty -> calculateTypeParameterArity $ maybeErr @loc.typeTreeCode ty) @loc.patsTreeTypes
     -- Get parameter arity from RHS
     loc   .rhsParameterArity   = calculateTypeParameterArity $ maybeErr @loc.typeTreeCode @rhs.typeTreeType

attr RhsR
  -- RhsR and GRhsR have a different structure to get to the full expression on the right-hand side
  syn typeTreeType                                              :: {Maybe S.TpScheme}

sem RhsR
  | RhsR
     lhs   .typeTreeType        = (\(mty,_,_) -> mty) $ attribute $ headErr (trMsg @lhs.typeTree $ show @loc.copy) $ children @lhs.typeTree
  | GRhsR
     lhs   .typeTreeType        = (\(mty,_,_) -> mty) $ attribute $ headErr (trMsg @lhs.typeTree $ show @loc.copy) $ tail $ children @lhs.typeTree

sem PatR ExprR AltR
  | *
     loc   .typeTreeType        = (\(mty,_,_) -> mty) $ attribute @lhs.typeTree
     loc   .typeTreeCode        = (\(_,_,src) -> src) $ attribute @lhs.typeTree

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR MaybeConst
  -- We get this from the Helium compiler. These only contain our own types.
  inh topLevelTypes                                             :: {IE.ImportEnvironment}

  -- We need to be able to synthesize these for LambdaR.
  syn functionHeliumTypes   use {DM.union}    {DM.empty}        :: {IE.TypeEnvironment}

attr BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR MaybeExprR ListExprR TupleExprR ListPatsR TuplePatsR MaybeConst
  -- These are the prelude types, currently equals HIE.importEnvs
  inh preludeTypes                                              :: {[IE.ImportEnvironment]}

   -- Highest integer used in a Helium type. We'll use this as an offset when generating
   -- fresh contracts; we don't want to accidentally clash with an existing type variable! 
   syn contractVariableOffset use {max} {(0::Int)}              :: {Int}

   -- First integer available for fresh contracts.
   chn freshContractVariable                                    :: {Int}

  -- These contracts are generated and populated from the types Helium provides us.
  inh heliumGeneratedContracts                                  :: {DM.Map String Contract}

attr ExprR
  -- This type is generated in ExprR nodes, and passed upwards to other ExprR nodes.
  syn functionType                                              :: {Maybe S.TpScheme}
attr ExprsR
  syn functionType             use {(++)}    {[]}               :: {[Maybe S.TpScheme]}



{- *** Start of semantics to get integer for fresh contract variables. *** -}
sem ModuleR
   | ModuleR
      -- At the top of the AST, we just convert the types that are given to us from the top level.
      loc  .types                  = getTypeEnv @lhs.topLevelTypes
      loc  .identifiers            = map fst $ DM.toList @loc.types
      loc  .onlyTypes              = map snd $ DM.toList @loc.types
      loc  .conversionResults      = mapConvertTopTypeToContract (@body.contractVariableOffset + 1) @loc.onlyTypes
      loc  .freshContractVariable  = fst @loc.conversionResults
      loc  .contracts              = snd @loc.conversionResults

      -- Add these contracts to the contract environment.
      -- Strip ranges information, this can cause duplicates.
      loc  .heliumIdents           = map (getVar.fromHeliumWithRanges) @loc.identifiers
      loc  .newContracts           = DM.fromList $ zip @loc.heliumIdents @loc.contracts
      body .heliumGeneratedContracts    = @loc.newContracts

      -- The first integer that is available for fresh contracts is one more than the highest one used by Helium.
      body .freshContractVariable       = max (@loc.freshContractVariable + 1) (maximum' $ map getMaxVariable HIE.importEnvs)

      body .preludeTypes                = HIE.importEnvs
{- *** End of semantics to get integer for fresh contract variables. *** -}

{- *** Start of semantics to get the types of functions and let-definitions *** -}
-- Every node that has a (list of) declaration(s) has those declarations compiled
-- by the Helium compiler to get their types.
sem ExprR
   | LetR
    -- Generate types for this group of bindings.
      loc  .asModuleR           = makeModuleR @decls.copy
      loc  .heliumResults       = H.compileWithExtraEnv (render $ pprint @loc.asModuleR) @lhs.topLevelTypes
      loc  .types               = extractTypeNoRange @loc.heliumResults

      -- Generate an import environment with the top-level types from Helium.
      loc  .typesImportEnv      = generateImportEnv @loc.types
                                    
    -- Pass types down to decls and assign them to each definition, so everyone knows their type.
      decls.heliumTypes         = @loc.types

    -- Combine environment and pass it down to children.
      loc  .newEnv              = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes
      decls.topLevelTypes       = @loc.newEnv
      expr .topLevelTypes       = @loc.newEnv

sem RhsR
  | RhsR
    -- Generate types for this group of bindings.
      loc  .asModuleR           = makeModuleR @where.copy
      loc  .heliumResults       = H.compileWithExtraEnv (render $ pprint @loc.asModuleR) @lhs.topLevelTypes
      loc  .types               = extractTypeNoRange @loc.heliumResults

      -- Generate an import environment with the top-level types from Helium.
      loc  .typesImportEnv      = generateImportEnv @loc.types

    -- Pass types down to decls and assign them to each definition, so everyone knows their type.
      where.heliumTypes         = @loc.types

    -- Overwrite environment and pass it down to children.
      loc  .newEnv              = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes --IE.combineImportEnvironments @loc.importEnv @lhs.topLevelTypes
      where.topLevelTypes       = @loc.newEnv
      expr .topLevelTypes       = @loc.newEnv

  | GRhsR
    -- Generate types for this group of bindings.
      loc  .asModuleR           = makeModuleR @where.copy
      loc  .heliumResults       = H.compileWithExtraEnv (render $ pprint @loc.asModuleR) @lhs.topLevelTypes
      loc  .types               = extractTypeNoRange @loc.heliumResults

      -- Generate an import environment with the top-level types from Helium.
      loc  .typesImportEnv      = generateImportEnv @loc.types

    -- Pass types down to decls and assign them to each definition, so everyone knows their type.
      where.heliumTypes         = @loc.types

    -- Overwrite environment and pass it down to children.
      loc  .newEnv              = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes --IE.combineImportEnvironments @loc.importEnv @lhs.topLevelTypes
      where.topLevelTypes       = @loc.newEnv
      gexprs.topLevelTypes      = @loc.newEnv
{- *** End of semantics to get the types of functions and let-definitions *** -}

{- *** Start of semantics to get highest type variable integer. *** -}
sem ExprR
   | LetR   
     lhs.contractVariableOffset = max @loc.topLevelTypesMax @loc.newEnvMax
     loc.topLevelTypesMax       = getMaxVariable @lhs.topLevelTypes
     loc.newEnvMax              = getMaxVariable @loc.newEnv

sem RhsR
   | RhsR GRhsR
     lhs.contractVariableOffset = max @loc.topLevelTypesMax @loc.newEnvMax
     loc.topLevelTypesMax       = getMaxVariable @lhs.topLevelTypes
     loc.newEnvMax              = getMaxVariable @loc.newEnv
{- *** End of semantics to get highest type variable integer. *** -}

{- *** Start of semantics to pass down types to individual function definition node. *** -}
-- We now have the types of the declarations, pass those down to each individual definition.
attr DeclsR DeclR FunBindsR FunBindR
  inh heliumTypes                                       :: {IE.TypeEnvironment}

sem BodyR
  | BodyR
      decls.heliumTypes         = getTypeEnv @lhs.topLevelTypes

sem FunBindR
  | FunBindR
      -- We need to get the types of all variables, too. Pass the function type to the pattern list.
      pats.patType              = Just $ lookupHeliumType @name.copy @lhs.heliumTypes

      -- The contracts of each variable is also handy information to know.
      pats.patContract          = DM.lookup (getVar @name.copy) @lhs.heliumGeneratedContracts
      loc.patternContracts      = @pats.patternContracts

      -- Synthesize the list of patterns with their types, we'll add those to the import environment.
      loc.patternTypes          = scrubRangeInfo @pats.patternTypes

      -- Add synthesized list of patterns with types to import environment.
      rhs.topLevelTypes         = overwriteImportEnv (generateImportEnv @loc.patternTypes) @lhs.topLevelTypes
      

sem DeclR
  | DPatBindR
      -- Don't know if we'll need the contracts of patterns defined in tuples, but we might as well collect it, it's not too hard.
      loc.heliumTypes           = DM.fromList $ map (\name -> (toHeliumWithRanges $ mkIdent name, lookupHeliumType (mkIdent name) @lhs.heliumTypes)) @pat.localPatterns
      loc.heliumDebug           = @lhs.heliumTypes
{- *** End of of semantics to pass down types to individual function definition node. *** -}

{- *** Start of semantics to get types from patterns of anonymous lambda functions *** -}
sem ExprR
  | LambdaR
     --We need to get the types of the patterns inside a lambda, too.
     --We'll convert it to a function and then do the usual synthesis on it.
     loc.lambda                 = LambdaR @pats.copy @expr.copy @range.copy
     loc.lambdaAsFunbind        = convertExprToFunBind @loc.lambda
     loc.lambdaAsModule         = makeModuleR [DFunBindsR [@loc.lambdaAsFunbind] noRangeR]

     loc.heliumResults          = H.compileWithExtraEnv (render $ pprint @loc.lambdaAsModule) @lhs.topLevelTypes
     loc.types                  = extractTypeNoRange @loc.heliumResults
     loc.typesImportEnv         = generateImportEnv @loc.types
     loc.newEnv                 = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes

     loc.sem_ModuleR            = sem_ModuleR @loc.lambdaAsModule
     loc.inh_ModuleR            = Inh_ModuleR @lhs.entryFunction @lhs.localIdentifiers @loc.newEnv 0
     loc.wrap_ModuleR           = wrap_ModuleR @loc.sem_ModuleR @loc.inh_ModuleR
     loc.functionHeliumTypes    = functionHeliumTypes_Syn_ModuleR @loc.wrap_ModuleR

     -- Update the import environment.
     expr.topLevelTypes         = overwriteImportEnv (generateImportEnv @loc.functionHeliumTypes) @lhs.topLevelTypes

sem FunBindR
  | FunBindR
      lhs.functionHeliumTypes   = @loc.patternTypes
{- *** End of semantics to get types from patterns of anonymous lambda functions *** -}

{- *** Start of semantics to get the type of an of anonymous lambda function *** -}
sem ExprR
  | LambdaR
      lhs.functionType          = lookupHeliumTypeMaybe (IdentR "__internalExpression__" noRangeR) @loc.types
{- *** End of semantics to get the type of an of anonymous lambda function *** -}
  | AppR
      -- The type of the entire AppR is the type of function being applied minus the arguments it's been applied to. 
      loc.argumentCount         = length @args.copy
      loc.splitTypes            = iterate (maybe Nothing (snd . splitTopTypeScheme)) @fun.functionType
      loc.functionType          = @loc.splitTypes !! @loc.argumentCount
      lhs.functionType          = @loc.functionType
  | VarR ConR
      -- Look up type in type env. Could also be a prelude type!
      loc.functionType          = searchTypeEnvs @name.copy (@lhs.topLevelTypes : @lhs.preludeTypes)
      lhs.functionType          = @loc.functionType
  | ParenR FeedbackR MustUseR NegR
      lhs.functionType          = @expr.functionType
  | HoleR
      lhs.functionType          = Nothing
  | IfR
      lhs.functionType          = @then.functionType
  | ListR
      lhs.functionType          = searchTypeEnvs (OperatorR "[]" noRangeR) (@lhs.topLevelTypes : @lhs.preludeTypes)

  

sem ExprsR
  | Cons
      lhs.functionType          = @hd.functionType : @tl.functionType
  | Nil
      lhs.functionType          = []


{- *** Start of semantics to get the type of an expression in a case statement *** -}
sem ExprR
  | CaseR
     -- Need to convert the expression to a ModuleR, then do synthesis on it.
     loc.exprAsFunbind          = convertExprToFunBind @expr.copy
     loc.exprAsModule           = makeModuleR [DFunBindsR [@loc.exprAsFunbind] noRangeR]

     loc.heliumResults          = H.compileWithExtraEnv (render $ pprint @loc.exprAsModule) @lhs.topLevelTypes
     loc.types                  = extractTypeNoRange @loc.heliumResults

     -- Fetch the type, pass it to the AltR list.
     -- There, it will be used to type the patterns.
     loc.caseExpressionType     = lookupHeliumType (IdentR "__internalExpression__" noRangeR) @loc.types
     lhs.functionType           = lookupHeliumTypeMaybe (IdentR "__internalExpression__" noRangeR) @loc.types
     alts.altType               = @loc.caseExpressionType
{- *** End of semantics to get the type of an expression in a case statement *** -}

{- *** Start of semantics to get the types of patterns in an AltR. *** -}
attr AltsR AltR
  inh altType                                           :: {S.TpScheme}

sem AltR
  | AltR
      -- We need to get the types of the patterns. Pass the function type to the pattern list.
      pat.patType              = Just @lhs.altType

      -- Synthesize the list of patterns with their types, we'll add those to the import environment.
      loc.patternTypes          = scrubRangeInfo @pat.patternTypes

      -- Add synthesized list of patterns with types to import environment.
      rhs.topLevelTypes         = overwriteImportEnv (generateImportEnv @loc.patternTypes) @lhs.topLevelTypes
{- *** End of semantics to get the types of patterns in an AltR. *** -}


{- *** Start of semantics to calculate the type of a pattern. *** -}
attr PatsR PatR ListPatsR TuplePatsR
  inh patType                                           :: {Maybe S.TpScheme}
  inh tuplePatType                                      :: {Maybe [S.TpScheme]}
  inh patContract                                       :: {Maybe Contract}

  syn patternTypes                                      :: {IE.TypeEnvironment}
  syn patternContracts                                  :: {DM.Map String Contract}

-- Semantics for splitting up a function type and assigning it to a pattern.
sem PatsR
  | Cons
     -- Split up the type-generated contract and pass it to a pattern.
     loc.splitContract          = maybe Nothing (Just . splitFunctionContract) @lhs.patContract
     hd .patContract            = maybe Nothing (Just . fst) @loc.splitContract
     tl .patContract            = maybe Nothing (Just . snd) @loc.splitContract
     
     -- Split up the type and pass it to a pattern.
     loc.splitType              = maybe Nothing (Just . splitTopTypeScheme) @lhs.patType
     hd .patType                = maybe Nothing (Just . fst) @loc.splitType
     tl .patType                = maybe Nothing snd @loc.splitType

sem PatsR
  | Cons
     lhs.patternTypes           = DM.union @hd.patternTypes @tl.patternTypes
     lhs.patternContracts       = DM.union @hd.patternContracts @tl.patternContracts
  | Nil
     lhs.patternTypes           = DM.empty
     lhs.patternContracts       = DM.empty

sem PatR
  | PHoleR
     lhs.patternTypes           = DM.empty
     lhs.patternContracts       = DM.empty

  | PConR
     -- TODO: Expand this. We should use HIE.importEnvs.
     lhs.patternTypes           = DM.empty
     lhs.patternContracts       = DM.empty

  | PInfixConR
     -- TODO: Expand this. We should use HIE.importEnvs.

     -- Pattern stuff
     lhs.patternTypes           = DM.union @left.patternTypes @right.patternTypes
     loc.possibleResult         = DL.elemIndex True @loc.listOfConstructors
     loc.listOfConstructors     = [@loc.isListConstructor]

     loc.inhLeft                = [@loc.listToLeft]
     loc.inhright               = [@loc.listToRight]

     left.patType               = maybe Nothing (indexMsg @loc.inhLeft ) @loc.possibleResult
     right.patType              = maybe Nothing (indexMsg @loc.inhright) @loc.possibleResult

     -- Contract stuff
     lhs.patternContracts       = DM.union @left.patternContracts @right.patternContracts
     loc.ctrtLeft               = [@loc.listCtrtToLeft]
     loc.ctrtRight              = [@loc.listCtrtToRight]
     left.patContract           = maybe Nothing (indexMsg @loc.ctrtLeft ) @loc.possibleResult
     right.patContract          = maybe Nothing (indexMsg @loc.ctrtRight) @loc.possibleResult

     loc.infixConstructor       = getVar @name.copy

     -- List constructor
     loc.isListConstructor      = @loc.infixConstructor == ":"
     loc.listToLeft             = maybe Nothing (Just . getInnerListElem) @lhs.patType
     loc.listToRight            = @lhs.patType
     loc.listCtrtToLeft         = maybe Nothing (Just . getInnerListCtrt) @lhs.patContract
     loc.listCtrtToRight        = @lhs.patContract

  | PListR
     lhs.patternTypes           = @pats.patternTypes
     lhs.patternContracts       = @pats.patternContracts
  
  | PLitR
     lhs.patternTypes           = DM.empty
     lhs.patternContracts       = DM.empty

  | PParenR
     lhs.patternTypes           = @pat.patternTypes
     lhs.patternContracts       = @pat.patternContracts


  | PTupleR
     lhs.patternTypes           = @pats.patternTypes
     pats.tuplePatType          = if @loc.lengthCheck 
                                   then @loc.splitUpTuple
                                   else error $ "Size of tuple as a pattern differs from size of tuple as a type! " ++
                                                "Size of pattern tuple: " ++ (show @loc.lengthPats) ++ ", " ++ 
                                                "Size of type tuple: " ++ (show @loc.lengthPatType)
     loc.lengthCheck            = @loc.lengthPatType == @loc.lengthPats
     loc.splitUpTuple           = maybe Nothing (Just . splitUpTuple) @lhs.patType
     loc.lengthPatType          = maybe 0 length @loc.splitUpTuple
     loc.lengthPats             = length @pats.copy

     lhs.patternContracts       = @pats.patternContracts
     pats.patContract           = @lhs.patContract

  | PVarR
     lhs.patternTypes           = maybe DM.empty (DM.singleton (toHeliumWithRanges @name.copy)) @lhs.patType
     lhs.patternContracts       = maybe DM.empty (DM.singleton (getVar @name.copy)) @lhs.patContract
  | PAsR
     lhs.patternTypes           = DM.union @loc.pAs @pat.patternTypes
     lhs.patternContracts       = DM.union @loc.pAsCtrt @pat.patternContracts
     loc.pAs                    = maybe DM.empty (DM.singleton (toHeliumWithRanges @name.copy)) @lhs.patType
     loc.pAsCtrt                = maybe DM.empty (DM.singleton (getVar @name.copy)) @lhs.patContract
  | PWildcardR
     lhs.patternTypes           = DM.empty
     lhs.patternContracts       = DM.empty

sem TuplePatsR
  | Cons
     lhs.patternTypes           = DM.union @hd.patternTypes @tl.patternTypes
     hd .patType                = maybe Nothing (Just . head) @lhs.tuplePatType
     tl .tuplePatType           = maybe Nothing (Just . tail) @lhs.tuplePatType

     lhs.patternContracts       = DM.union @hd.patternContracts @tl.patternContracts
     hd .patContract            = maybe Nothing (Just . fst . splitTupleContract) @lhs.patContract
     tl .patContract            = maybe Nothing (Just . snd . splitTupleContract) @lhs.patContract
  | Nil
     lhs.patternTypes           = DM.empty
     lhs.patternContracts       = DM.empty

sem ListPatsR
  | Cons
     lhs.patternTypes           = DM.union @hd.patternTypes @tl.patternTypes
     lhs.patternContracts       = DM.union @hd.patternContracts @tl.patternContracts
     hd .patType                = maybe Nothing (Just . getInnerListElem) @lhs.patType
     tl .patType                = @lhs.patType
  | Nil
     lhs.patternTypes           = DM.empty
     lhs.patternContracts       = DM.empty
{- *** End of semantics to calculate the type of a pattern. *** -}

{- *** Start of semantics to suppress some warnings concerning patterns. *** -}
-- tuplePatType is populated inside the semantics above, so we can't give it a value from outside.
sem FunBindR
  | FunBindR
     pats.tuplePatType          = Nothing

-- Same as above.
sem AltR
  | AltR
     pat.tuplePatType           = Nothing
     pat.patContract            = Nothing

-- In a pattern binding, the Helium compiler automatically adds the patterns
-- with their type to the type environment.
sem DeclR
  | DPatBindR
     pat.tuplePatType           = Nothing
     pat.patType                = Nothing

-- We compile a lambda function using the Helium compiler as a named function,
-- so any pattern type synthesis stuff is done via the FunBindR way. 
sem ExprR
  | LambdaR
     pats.tuplePatType          = Nothing
     pats.patType               = Nothing
     pats.patContract           = Nothing


