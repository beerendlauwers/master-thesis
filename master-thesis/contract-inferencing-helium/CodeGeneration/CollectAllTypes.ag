-- ~/thesis/FPTutor/trunk/src$ ~/.cabal/bin/uuagc -dcfswH --module="Domain.FP.CodeGeneration.CollectAllTypes" Domain/FP/CodeGeneration/CollectAllTypes.ag

-- Include simplified syntax used by Ask-Elle
include "Domain/FP/SyntaxWithRanges.ag"

include "Domain/FP/CodeGeneration/CollectLocalIdents.ag"

include "Domain/FP/CodeGeneration/Utils.ag"

include "Domain/FP/CodeGeneration/GenerateContracts.ag"

include "Domain/FP/ContractInferencing/Substitution.ag"

include "Domain/FP/CodeGeneration/DebugCode.ag"

imports
{
import qualified Domain.FP.Helium as H
import qualified ModuleSystem.ImportEnvironment as IE
import qualified Data.Map as DM
import qualified Data.Set as DS
import qualified Data.Maybe as DJ
import qualified Data.List as DL
}

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn copy                                             :: self

  -- We get this from the Helium compiler.
  inh topLevelTypes                                     :: {IE.ImportEnvironment}

   -- We need to be able to synthesize these for LambdaR.
   syn functionHeliumTypes   use {DM.union}    {DM.empty}       :: {IE.TypeEnvironment}

--{
--data NestedEnv a = WithLocalDefinitions (Map NameR a) (NestedEnv a) |
--                   NoLocalDefinitions
--}

{- *** Start of semantics to get the types of functions and let-definitions *** -}
-- Every node that has a (list of) declaration(s) has those declarations compiled
-- by the Helium compiler to get their types.
sem ExprR
   | LetR
    -- Generate types for this group of bindings.
      loc  .asModuleR           = makeModuleR @decls.copy
      loc  .heliumResults       = H.compileWithExtraEnv (render $ pprint @loc.asModuleR) @lhs.topLevelTypes
      loc  .types               = H.extractTypes @loc.heliumResults

      -- Generate an import environment with the top-level types from Helium.
      loc  .typesImportEnv      = generateImportEnv @loc.types
                                    
    -- Pass types down to decls and assign them to each definition, so everyone knows their type.
      decls.heliumTypes         = @loc.types

    -- Combine environment and pass it down to children.
      loc  .newEnv              = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes
      decls.topLevelTypes       = @loc.newEnv
      expr .topLevelTypes       = @loc.newEnv

sem RhsR
  | RhsR
    -- Generate types for this group of bindings.
      loc  .asModuleR           = makeModuleR @where.copy
      loc  .heliumResults       = H.compileWithExtraEnv (render $ pprint @loc.asModuleR) @lhs.topLevelTypes
      loc  .types               = H.extractTypes @loc.heliumResults

      -- Generate an import environment with the top-level types from Helium.
      loc  .typesImportEnv      = generateImportEnv @loc.types

    -- Pass types down to decls and assign them to each definition, so everyone knows their type.
      where.heliumTypes         = @loc.types

    -- Overwrite environment and pass it down to children.
      loc  .newEnv              = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes --IE.combineImportEnvironments @loc.importEnv @lhs.topLevelTypes
      where.topLevelTypes       = @loc.newEnv
      expr .topLevelTypes       = @loc.newEnv

  | GRhsR
    -- Generate types for this group of bindings.
      loc  .asModuleR           = makeModuleR @where.copy
      loc  .heliumResults       = H.compileWithExtraEnv (render $ pprint @loc.asModuleR) @lhs.topLevelTypes
      loc  .types               = H.extractTypes @loc.heliumResults

      -- Generate an import environment with the top-level types from Helium.
      loc  .typesImportEnv      = generateImportEnv @loc.types

    -- Pass types down to decls and assign them to each definition, so everyone knows their type.
      where.heliumTypes         = @loc.types

    -- Overwrite environment and pass it down to children.
      loc  .newEnv              = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes --IE.combineImportEnvironments @loc.importEnv @lhs.topLevelTypes
      where.topLevelTypes       = @loc.newEnv
      gexprs.topLevelTypes      = @loc.newEnv
{- *** End of semantics to get the types of functions and let-definitions *** -}

{- *** Start of semantics to generate contracts for functions and let-definitions *** -}
-- We now have the types of the declarations, pass those down to each individual definition.
attr DeclsR DeclR FunBindsR FunBindR
  inh heliumTypes                                       :: {IE.TypeEnvironment}

sem BodyR
  | BodyR
      decls.heliumTypes         = (\(IE.ImportEnvironment _ _ typeEnv _ _ _) -> typeEnv) @lhs.topLevelTypes

sem FunBindR
  | FunBindR
      -- We'll use this local variable to generate contracts and contracted code.
      loc.heliumType            = lookupHeliumType @name.copy @lhs.heliumTypes

      -- We need to get the types of all variables, too. Pass the function type to the pattern list.
      pats.patType              = Just @loc.heliumType

      -- Synthesize the list of patterns with their types, we'll add those to the import environment.
      loc.patternTypes          = @pats.patternTypes

      -- Add synthesized list of patterns with types to import environment.
      rhs.topLevelTypes         = overwriteImportEnv (generateImportEnv @loc.patternTypes) @lhs.topLevelTypes
      

sem DeclR
  | DPatBindR
      -- Don't know if we'll need the contracts of patterns defined in tuples, but we might as well collect it, it's not too hard.
      loc.heliumType            = map (\name -> lookupHeliumType name @lhs.heliumTypes) @pat.localPatterns
      loc.heliumDebug           = @lhs.heliumTypes
{- *** End of semantics to generate contracts for functions and let-definitions *** -}

{- *** Start of semantics to get types from patterns of anonymous lambda functions *** -}
sem ExprR
  | LambdaR
     --We need to get the types of the patterns inside a lambda, too.
     --We'll convert it to a function and then do the usual synthesis on it.
     loc.lambda                 = LambdaR @pats.copy @expr.copy @range.copy
     loc.lambdaAsFunbind        = convertExprToFunBind @loc.lambda
     loc.lambdaAsModule         = makeModuleR [DFunBindsR [@loc.lambdaAsFunbind] noRangeR]

     loc.heliumResults          = H.compileWithExtraEnv (render $ pprint @loc.lambdaAsModule) @lhs.topLevelTypes
     loc.types                  = H.extractTypes @loc.heliumResults
     loc.typesImportEnv         = generateImportEnv @loc.types
     loc.newEnv                 = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes

     loc.sem_ModuleR            = sem_ModuleR @loc.lambdaAsModule
     loc.inh_ModuleR            = Inh_ModuleR @lhs.entryFunction @lhs.localIdentifiers @loc.newEnv
     loc.wrap_ModuleR           = wrap_ModuleR @loc.sem_ModuleR @loc.inh_ModuleR
     loc.functionHeliumTypes    = functionHeliumTypes_Syn_ModuleR @loc.wrap_ModuleR

     -- Update the import environment.
     expr.topLevelTypes         = overwriteImportEnv (generateImportEnv @loc.functionHeliumTypes) @lhs.topLevelTypes

sem FunBindR
  | FunBindR
      lhs.functionHeliumTypes   = @loc.patternTypes
{- *** End of semantics to get types from patterns of anonymous lambda functions *** -}


{- *** Start of semantics to get the type of an expression in a case statement *** -}
sem ExprR
  | CaseR
     -- Need to convert the expression to a ModuleR, then do synthesis on it.
     loc.exprAsFunbind          = convertExprToFunBind @expr.copy
     loc.exprAsModule           = makeModuleR [DFunBindsR [@loc.exprAsFunbind] noRangeR]

     loc.heliumResults          = H.compileWithExtraEnv (render $ pprint @loc.exprAsModule) @lhs.topLevelTypes
     loc.types                  = H.extractTypes @loc.heliumResults

     -- Fetch the type, pass it to the AltR list.
     -- There, it will be used to type the patterns.
     loc.caseExpressionType     = lookupHeliumType (IdentR "__internalExpression__" noRangeR) @loc.types
     alts.altType               = @loc.caseExpressionType
{- *** End of semantics to get the type of an expression in a case statement *** -}

{- *** Start of semantics to get the types of patterns in an AltR. *** -}
attr AltsR AltR
  inh altType                                           :: {S.TpScheme}

sem AltR
  | AltR
      -- We need to get the types of the patterns. Pass the function type to the pattern list.
      pat.patType              = Just @lhs.altType

      -- Synthesize the list of patterns with their types, we'll add those to the import environment.
      loc.patternTypes          = @pat.patternTypes

      -- Add synthesized list of patterns with types to import environment.
      rhs.topLevelTypes         = overwriteImportEnv (generateImportEnv @loc.patternTypes) @lhs.topLevelTypes
{- *** End of semantics to get the types of patterns in an AltR. *** -}


{- *** Start of semantics to calculate the type of a pattern. *** -}
attr PatsR PatR ListPatsR TuplePatsR
  inh patType                                           :: {Maybe S.TpScheme}
  inh tuplePatType                                      :: {Maybe [S.TpScheme]}
  inh patContract                                       :: {Contract}
  syn patternTypes                                      :: {IE.TypeEnvironment}

-- Semantics for splitting up a function type and assigning it to a pattern.
sem PatsR
  | Cons
     -- Split up the type-generated contract and pass it to a pattern.
     loc.splitContract          = splitFunctionContract @lhs.patContract
     hd .patContract            = fst @loc.splitContract
     tl .patContract            = snd @loc.splitContract
     
     -- Split up the type and pass it to a pattern.
     loc.splitType              = maybe Nothing (Just . splitTopTypeScheme) @lhs.patType
     hd .patType                = maybe Nothing (Just . fst) @loc.splitType
     tl .patType                = maybe Nothing snd @loc.splitType

sem PatsR
  | Cons
     lhs.patternTypes           = DM.union @hd.patternTypes @tl.patternTypes
  | Nil
     lhs.patternTypes           = DM.empty

sem PatR
  | PHoleR
     lhs.patternTypes           = DM.empty

  | PConR
     -- TODO: Expand this.
     lhs.patternTypes           = DM.empty 

  | PInfixConR
     -- TODO: Expand this.
     lhs.patternTypes           = DM.union @left.patternTypes @right.patternTypes
     loc.possibleResult         = DL.elemIndex True @loc.listOfConstructors
     loc.listOfConstructors     = [@loc.isListConstructor]

     loc.inhLeft                = [@loc.listToLeft]
     loc.inhright               = [@loc.listToRight]
     loc.sendToleft             = case @loc.possibleResult of
                                   (Just n) -> @loc.inhLeft !! n
                                   _        -> Nothing
     loc.sendToRight            = case @loc.possibleResult of
                                   (Just n) -> @loc.inhright !! n
                                   _        -> Nothing
     left.patType               = @loc.sendToleft
     right.patType              = @loc.sendToRight

     loc.infixConstructor       = getVar @name.copy

     -- List constructor
     loc.isListConstructor      = @loc.infixConstructor == ":"
     loc.listToLeft             = maybe Nothing (Just . getInnerListElem) @lhs.patType
     loc.listToRight            = @lhs.patType

  | PListR
     lhs.patternTypes           = @pats.patternTypes
  
  | PLitR
     lhs.patternTypes           = DM.empty

  | PParenR
     lhs.patternTypes           = @pat.patternTypes

  | PTupleR
     lhs.patternTypes           = @pats.patternTypes
     pats.tuplePatType          = if @loc.lengthCheck 
                                   then @loc.splitUpTuple
                                   else error $ "Size of tuple as a pattern differs from size of tuple as a type! " ++
                                                "Size of pattern tuple: " ++ (show @loc.lengthPats) ++ ", " ++ 
                                                "Size of type tuple: " ++ (show @loc.lengthPatType)
     loc.lengthCheck            = @loc.lengthPatType == @loc.lengthPats
     loc.splitUpTuple           = maybe Nothing (Just . splitUpTuple) @lhs.patType
     loc.lengthPatType          = maybe 0 length @loc.splitUpTuple
     loc.lengthPats             = length @pats.copy

  | PVarR
     lhs.patternTypes           = case @lhs.patType of
                                   (Just x) -> DM.singleton (toHeliumWithRanges @name.copy) x
                                   Nothing  -> DM.empty
  | PAsR
     lhs.patternTypes           = DM.union @loc.pAs @pat.patternTypes
     loc.pAs                    = case @lhs.patType of
                                   (Just x) -> DM.singleton (toHeliumWithRanges @name.copy) x
                                   Nothing  -> DM.empty
  | PWildcardR
     lhs.patternTypes           = DM.empty

sem TuplePatsR
  | Cons
     lhs.patternTypes           = DM.union @hd.patternTypes @tl.patternTypes
     hd .patType                = maybe Nothing (Just . head) @lhs.tuplePatType
     tl .tuplePatType           = maybe Nothing (Just . tail) @lhs.tuplePatType
  | Nil
     lhs.patternTypes           = DM.empty

sem ListPatsR
  | Cons
     lhs.patternTypes           = DM.union @hd.patternTypes @tl.patternTypes
     hd .patType                = maybe Nothing (Just . getInnerListElem) @lhs.patType
     tl .patType                = @lhs.patType
  | Nil
     lhs.patternTypes           = DM.empty
{- *** End of semantics to calculate the type of a pattern. *** -}
