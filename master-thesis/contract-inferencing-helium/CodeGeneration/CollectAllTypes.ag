-- ~/thesis/FPTutor/trunk/src$ ~/.cabal/bin/uuagc -dcfswH --module="Domain.FP.CodeGeneration.CollectAllTypes" Domain/FP/CodeGeneration/CollectAllTypes.ag

-- Include simplified syntax used by Ask-Elle
include "Domain/FP/SyntaxWithRanges.ag"

include "Domain/FP/CodeGeneration/CollectLocalIdents.ag"

include "Domain/FP/CodeGeneration/Utils.ag"

include "Domain/FP/CodeGeneration/GenerateContracts.ag"

include "Domain/FP/ContractInferencing/Substitution.ag"

include "Domain/FP/CodeGeneration/DebugCode.ag"

imports
{
import qualified Domain.FP.Helium as H
import qualified ModuleSystem.ImportEnvironment as IE
import qualified Data.Map as DM
import qualified Data.Set as DS
import qualified Data.Maybe as DJ
}

{
-- DEBUGGING

{-
top1 = H.compileWithExtraEnv "f x = x\ng x =\n    let\n        (z,zs) =\n            (f x,f [x]) in\n        zs" IE.emptyEnvironment
top1NoGEnv = maybe (generateImportEnv $ H.extractTypes top1) (\x -> removeFromTypeEnv x (generateImportEnv $ H.extractTypes top1)) (Just $ toHeliumWithRanges (IdentR "g" noRangeR))
combine1 = overwriteImportEnv top1NoGEnv IE.emptyEnvironment
top2 = H.compile''' False "g x =\n   let\n       (z,zs) =\n           (f x,f [x]) in\n       zs" combine1
combine2 = overwriteImportEnv (generateImportEnv $ H.extractTypes top2) combine1




topn = H.compileWithExtraEnv "f x = (\\ y -> z x y)\n  where z x y = x y\nz x y = x y" IE.emptyEnvironment
topnNoFEnv = maybe (generateImportEnv $ H.extractTypes topn) (\x -> removeFromTypeEnv x (generateImportEnv $ H.extractTypes topn)) (Just $ toHeliumWithRanges (IdentR "f" noRangeR))
combinen = overwriteImportEnv topnNoFEnv IE.emptyEnvironment
topn' = H.compile'' False "z x y = x y" combinen
combinen' = overwriteImportEnv (generateImportEnv $ H.extractTypes topn) combinen



-- FIXING EXAMPLE 1
example1top = H.compileWithExtraEnv "f x = g x\n  where g x = [x]\ng f x = f x" IE.emptyEnvironment
example1env = generateImportEnv $ H.extractTypes example1top
-}

}

attr ModuleR BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR NameR MaybeExprR MaybeNameR RangeR PositionR ListExprR TupleExprR ListPatsR TuplePatsR
   syn copy                                             :: self

  -- We get this from the Helium compiler.
  inh topLevelTypes                                     :: {IE.ImportEnvironment}

--{
--data NestedEnv a = WithLocalDefinitions (Map NameR a) (NestedEnv a) |
--                   NoLocalDefinitions
--}

-- Every node that has a (list of) declaration(s) has those declarations compiled
-- by the Helium compiler to get their types.

sem ExprR
   | LetR
    -- Generate types for this group of bindings.
      loc  .asModuleR           = makeModuleR @decls.copy
      loc  .heliumResults       = H.compileWithExtraEnv (render $ pprint @loc.asModuleR) @lhs.topLevelTypes
      loc  .types               = H.extractTypes @loc.heliumResults

      -- Generate an import environment with the top-level types from Helium.
      loc  .typesImportEnv      = generateImportEnv @loc.types
                                    
    -- Pass types down to decls and assign them to each definition, so everyone knows their type.
      decls.heliumTypes         = @loc.types

    -- Combine environment and pass it down to children.
      loc  .newEnv              = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes
      decls.topLevelTypes       = @loc.newEnv
      expr .topLevelTypes       = @loc.newEnv

sem RhsR
  | RhsR
    -- Generate types for this group of bindings.
      loc  .asModuleR           = makeModuleR @where.copy
      loc  .heliumResults       = H.compileWithExtraEnv (render $ pprint @loc.asModuleR) @lhs.topLevelTypes
      loc  .types               = H.extractTypes @loc.heliumResults

      -- Generate an import environment with the top-level types from Helium.
      loc  .typesImportEnv      = generateImportEnv @loc.types

    -- Pass types down to decls and assign them to each definition, so everyone knows their type.
      where.heliumTypes         = @loc.types

    -- Overwrite environment and pass it down to children.
      loc  .newEnv              = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes --IE.combineImportEnvironments @loc.importEnv @lhs.topLevelTypes
      where.topLevelTypes       = @loc.newEnv
      expr .topLevelTypes       = @loc.newEnv

  | GRhsR
    -- Generate types for this group of bindings.
      loc  .asModuleR           = makeModuleR @where.copy
      loc  .heliumResults       = H.compileWithExtraEnv (render $ pprint @loc.asModuleR) @lhs.topLevelTypes
      loc  .types               = H.extractTypes @loc.heliumResults

      -- Generate an import environment with the top-level types from Helium.
      loc  .typesImportEnv      = generateImportEnv @loc.types

    -- Pass types down to decls and assign them to each definition, so everyone knows their type.
      where.heliumTypes         = @loc.types

    -- Overwrite environment and pass it down to children.
      loc  .newEnv              = overwriteImportEnv @loc.typesImportEnv @lhs.topLevelTypes --IE.combineImportEnvironments @loc.importEnv @lhs.topLevelTypes
      where.topLevelTypes       = @loc.newEnv
      gexprs.topLevelTypes      = @loc.newEnv

-- We now have the types of the declarations, pass those down to each individual definition.

attr DeclsR DeclR FunBindsR FunBindR
  inh heliumTypes                                       :: {IE.TypeEnvironment}

sem BodyR
  | BodyR
      decls.heliumTypes         = (\(IE.ImportEnvironment _ _ typeEnv _ _ _) -> typeEnv) @lhs.topLevelTypes

sem FunBindR
  | FunBindR
      -- We'll use this local variable to generate contracts and contracted code.
      loc.heliumType            = DJ.fromJust $ DM.lookup (toHeliumWithRanges @name.copy) @lhs.heliumTypes

      -- We need to get the types of all variables, too. Pass the function type to the pattern list.
      pats.patType              = Just @loc.heliumType

      -- Synthesize the list of patterns with their types, we'll add those to the import environment.
      loc.patternTypes          = @pats.patternTypes

      -- Add synthesized list of patterns with types to import environment.
      rhs.topLevelTypes           = overwriteImportEnv (generateImportEnv @loc.patternTypes) @lhs.topLevelTypes
      

sem DeclR
  | DPatBindR
      -- Don't know if we'll need the contracts of stuff defined in tuples, but we might as well collect it, it's not too hard.
      loc.heliumType            = map (\name -> DJ.fromJust $ DM.lookup (toHeliumWithRanges name) @lhs.heliumTypes) @pat.localPatterns
      loc.heliumDebug           = @lhs.heliumTypes --map (toHeliumWithRanges :: CastRange Helium.Name NameR => NameR -> Helium.Name) @pat.localPatterns
      loc.patternTypes          = zip @pat.localPatterns @loc.heliumType

attr PatsR PatR ListPatsR TuplePatsR
  inh patType                                           :: {Maybe S.TpScheme}
  inh tuplePatType                                      :: {Maybe [S.TpScheme]}
  inh patContract                                       :: {Contract}
  syn patternTypes                                      :: {IE.TypeEnvironment}

-- Semantics for splitting up a function type and assigning it to a pattern.
sem PatsR
  | Cons
     -- Split up the type-generated contract and pass it to a pattern.
     loc.splitContract          = splitFunctionContract @lhs.patContract
     hd .patContract            = fst @loc.splitContract
     tl .patContract            = snd @loc.splitContract
     
     -- Split up the type and pass it to a pattern.
     loc.splitType              = maybe Nothing (Just . splitTopTypeScheme) @lhs.patType
     hd .patType                = maybe Nothing (Just . fst) @loc.splitType
     tl .patType                = maybe Nothing snd @loc.splitType

sem PatsR
  | Cons
     lhs.patternTypes           = DM.union @hd.patternTypes @tl.patternTypes
  | Nil
     lhs.patternTypes           = DM.empty

sem PatR
  | PHoleR
     lhs.patternTypes           = DM.empty

  | PConR
     -- TODO: Expand this.
     lhs.patternTypes           = DM.empty 

  | PInfixConR
     -- TODO: Expand this.
     lhs.patternTypes           = DM.empty

  | PListR
     lhs.patternTypes           = @pats.patternTypes
  
  | PLitR
     lhs.patternTypes           = DM.empty

  | PParenR
     lhs.patternTypes           = DM.empty

  | PTupleR
     lhs.patternTypes           = @pats.patternTypes
     pats.tuplePatType          = if @loc.lengthCheck 
                                   then @loc.splitUpTuple
                                   else error $ "Size of tuple as a pattern differs from size of tuple as a type! " ++
                                                "Size of pattern tuple: " ++ (show @loc.lengthPats) ++ ", " ++ 
                                                "Size of type tuple: " ++ (show @loc.lengthPatType)
     loc.lengthCheck            = @loc.lengthPatType == @loc.lengthPats
     loc.splitUpTuple           = maybe Nothing (Just . splitUpTuple) @lhs.patType
     loc.lengthPatType          = maybe 0 length @loc.splitUpTuple
     loc.lengthPats             = length @pats.copy

  | PVarR
     lhs.patternTypes           = case @lhs.patType of
                                   (Just x) -> DM.singleton (toHeliumWithRanges @name.copy) x
                                   Nothing  -> DM.empty
  | PAsR
     lhs.patternTypes           = DM.union @loc.pAs @pat.patternTypes
     loc.pAs                    = case @lhs.patType of
                                   (Just x) -> DM.singleton (toHeliumWithRanges @name.copy) x
                                   Nothing  -> DM.empty
  | PWildcardR
     lhs.patternTypes           = DM.empty

sem TuplePatsR
  | Cons
     lhs.patternTypes           = DM.union @hd.patternTypes @tl.patternTypes
     hd .patType                = maybe Nothing (Just . head) @lhs.tuplePatType
     tl .tuplePatType           = maybe Nothing (Just . tail) @lhs.tuplePatType
  | Nil
     lhs.patternTypes           = DM.empty

sem ListPatsR
  | Cons
     lhs.patternTypes           = DM.union @hd.patternTypes @tl.patternTypes
     hd .patType                = maybe Nothing (Just . getInnerListElem) @lhs.patType
     tl .patType                = @lhs.patType
  | Nil
     lhs.patternTypes           = DM.empty
