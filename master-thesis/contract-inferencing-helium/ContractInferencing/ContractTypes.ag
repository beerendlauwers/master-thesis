type MaybeConst  = maybe ExprR

data Contract
  |  CArr        c1     :: Contract  c2  :: Contract
  |  CProp       p      :: {String}
  |  CFunctor    o      :: Contract  i   :: Contract
  |  CBifunctor  o      :: Contract  il  :: Contract    ir :: Contract
  |  CVar        v      :: String    mc  :: MaybeConst
  |  CQuant      cv     :: Contract  cs  :: Contract
  |  CTuple      li     :: {[Contract]} -- Helium AST portrays tuples as lists, this seems like the best way


data Subst
  |  SId
  |  SComp   l  :: Subst     r  :: Subst
  |  SSubst  v  :: Contract  c  :: Contract

deriving Contract: Eq, Ord
deriving Subst: Eq


-- instance Eq Contract where
--   (==) (CProp a) (CProp b) = a == b
--   (==) a         b 

{
-- data PropertyContract = forall aT. PropertyContract (CTRT.Contract aT)

-- Because we've hidden the type, we have to be happy with a function that works for everything.
-- These particular instances don't really get used, though.
--instance Eq PropertyContract where
-- (==) (PropertyContract a) (PropertyContract b) = True

--instance Ord PropertyContract where
-- compare (PropertyContract a) (PropertyContract b) = EQ
}

{
infixr 4 +->
(+->) :: Contract -> Contract -> Subst
(+->) = SSubst

infixr 4 >->
(>->) :: Contract -> Contract -> Contract
(>->) = CArr

infixr 4 <@>
(<@>) :: Contract -> Contract -> Contract
(<@>) = CFunctor

infixr 4 <@@>
(<@@>) :: Contract -> (Contract, Contract) -> Contract
o <@@> (il,ir) = CBifunctor o il ir

-- Foralls the contracts
infixr 4 >!>
(>!>) :: Contract -> Contract -> Contract
c1 >!> c2 = 
 let allForalls = DL.nub $ concatMap getGeneralizedContracts [c1,c2]
 in addQuantifiers (CArr (stripQuantifiers c1) (stripQuantifiers c2)) allForalls

infixr 6 `o`
o :: Subst -> Subst -> Subst
o = SComp

--proptrue :: Contract
--proptrue = CProp (PropertyContract CTRT.true) "true"
}
