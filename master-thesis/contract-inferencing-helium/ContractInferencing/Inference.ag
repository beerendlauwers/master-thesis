MODULE {Domain.FP.ContractInferencing.Inference}{}


{
type CEnv = Map Name Contract
}

--
attr ExprR MaybeExprR ListExprR
  syn  infer                                    :: Contract
  syn  resEnv    use {`urenv`}     {DM.empty}   :: {Map Name [Contract]}
  syn  subst                                    :: Subst

attr ExprR MaybeExprR ListExpR
  inh  env                                      :: CEnv
  inh  cann                                     :: {Maybe Contract}

attr PatR
  syn  infer                                    :: Contract
  syn  subst                                    :: Subst

  syn envFromPats use {`urenv`}    {DM.empty}   :: CEnv

attr ListPatsR
  syn orderedPats :: [Contract] -- We can use this for creating a function contract
  syn envFromPats use {`urenv`}    {DM.empty}   :: CEnv

{-

Checklist:
                         EXPR
-- | A Haskell source module
DATA ModuleR
   | ModuleR

DATA BodyR
   | BHoleR
   | BodyR

-- | Declarations
DATA DeclR              
   | DHoleR
   | DEmptyR
   | DFunBindsR
   | DPatBindR

-- | Expressions         
DATA ExprR             
   | HoleR               DONE
   | FeedbackR
   | MustUseR
   | CaseR
   | ConR
   | IfR
   | InfixAppR
   | LambdaR             DONE
   | LetR                
   | LitR                
   | AppR                DONE
   | ParenR              
   | TupleR
   | VarR                DONE
   | EnumR               
   | ListR               
   | NegR

DATA MaybeExprR
   | NoExprR             
   | JustExprR           

-- | Alternatives
DATA AltR
   | AHoleR              DONE
   | AltR
   | AltEmptyR           DONE

-- | Function bindings
DATA FunBindR
   | FBHoleR             DONE
   | FunBindR            DONE

-- | Guarded expressions 
DATA GuardedExprR
   | GExprR

-- | Literal values
DATA LiteralR
   | LCharR
   | LFloatR
   | LIntR
   | LStringR

-- | Names
DATA NameR
   | IdentR
   | OperatorR
   | SpecialR

DATA MaybeNameR
   | NoNameR
   | JustNameR

-- | Patterns
DATA PatR
   | PHoleR              DONE
   | PConR               DONE
   | PInfixConR          DONE
   | PListR              DONE
   | PLitR               DONE
   | PParenR             DONE
   | PTupleR
   | PVarR               DONE
   | PAsR                DONE
   | PWildcardR          DONE

-- | Right hand side
DATA RhsR
   | RhsR
   | GRhsR

DATA RangeR
    | RangeR

DATA PositionR
    | PositionR
    | UnknownR
      

-}

attr ModuleR
  syn  topLevelDecls use {`DM.union`}  {DM.empty}    :: CEnv

sem ModuleR
   | ModuleR
      lhs   .topLevelDecls = @body.topLevelDecls

attr BodyR -- Body of entire module
  syn  topLevelDecls use {`DM.union`}  {DM.empty}    :: CEnv

  syn  subst                                         :: Subst

sem BodyR
   | BHoleR
      lhs  .topLevelDecls = DM.empty
      lhs  .subst = SId

   | BodyR
      -- These are the top-level function identifiers.
      loc  .functionIdents = @decls.functionIdents

      -- We have to add these to the environment so all functions know about all other functions.
      decls.env     =    DM.union @loc.functionIdents @lhs.env

      -- These are the contracts of the top-level declarations.
      lhs  .topLevelDecls = @decls.contractedFuns

      -- These are all the substitutions.
      lhs  .subst = @decls.subst
      

attr FunBindsR -- List of FunBindR
  syn  subst                                         :: Subst

  -- The function identifiers with their final contract, relies on env
  syn  contractedFuns use {`DM.union`}  {DM.empty}   :: CEnv

  -- The function identifiers with a fresh contract, doesn't rely on anything
  syn  functionIdents use {`DM.union`}  {DM.empty}   :: CEnv

sem FunBindsR
   | Cons
      lhs  .subst   =  @loc.subst'
      lhs  .contractedFuns = DM.union @loc.finalContractedFuns @tl.contractedFuns
      lhs  .functionIdents = DM.union @hd.functionIdents @tl.functionIdents

      -- Update the environment by applying the substitutions we know about to them.
      loc  .updatedEnv = subst @hd.subst @hd.contractedFuns
  
      -- We have to pass the contract environment from the head function binding
      -- To the rest of the function bindings.
      -- NOTE: Here, the user-supplied contract environment takes precedence!
      tl   .env     =   DM.union @lhs.env @loc.updatedEnv

      -- Collect all substitutions, pass them upwards.
      loc   .subst' =   @tl.subst `o` @hd.subst

      -- These substitutions will help us refine the function contracts more.
      loc   .finalContractedFuns = subst @loc.subst' @loc.updatedEnv

   | Nil
      lhs  .subst   =  SId
      lhs  .contractedFuns = DM.empty
      lhs  .functionIdents = DM.empty

attr FunBindR
  syn  infer                                         :: Contract
  syn  subst                                         :: Subst

  -- The function identifiers with their final contract, relies on env
  syn  contractedFuns use {`DM.union`}  {DM.empty}   :: CEnv

  -- The function identifiers with a fresh contract, doesn't rely on anything
  syn  functionIdents use {`DM.union`}  {DM.empty}   :: CEnv

sem FunBindR
   | FBHoleR
      lhs  .infer   =   mkVar @loc.num
           .subst   =   SId

      loc  .num     ::  uniqueref varcnt

   -- AST example: (ident "f") [pats] = rhs
   | FunBindR
      -- This is passed upwards to the entire list of function definitions.
      -- There, it is added to the environment, so that every function knows
      -- about every other function.
      lhs  .functionIdents = DM.singleton @name.copy (mkVar @loc.num) -- give f a fresh contract

      lhs  .infer   =   @loc.fctrt -- Contract of function f
           .subst   =   @loc.finalsubsts -- Substitutions of RHS, LHS only generates SIds
           .contractedFuns = DM.singleton @name.copy @loc.fctrt
           -- NOTE: DM.union is left-biased, so it could be that "older" function contracts overwrite "newer" ones?

           -- Look up contract for function identifier
           .fident  =   envLU @name.copy @lhs.env

           -- Add (f :: TRUEi) to env, may overwrite a possible previous contract
           .newenv  =   DM.insert @name.copy @loc.fident @lhs.env

           -- collect contracts from patterns
           .patenvs =   @pats.envFromPats

           -- Combine contract environment, pass to RHS
           -- No unification or substitution? 
           -- Indeed, because the variables and function identifier in the LHS
           -- are all fresh anyway, and they're all unique identifiers.
      rhs  .env     =   DM.union @pats.envFromPats @lhs.newenv

           -- RHS may have generated substitutions on our pattern variables, need to update:
           .substp  =   subst @rhs.substs @pats.orderedPats

           -- With pattern contracts and RHS, construct new contract for f,
           -- for example C1 >-> C2 >-> @rhs.infer
           .fctrt   =   foldr (>->) @rhs.infer @loc.substp

           -- It's possible the function identifier already had its contract inferred previously:
           -- f (x:xs) = [x]
           -- f [] = []
           -- Unify the contracts of these definitions?
           .finalsubsts = case DM.lookup @name.copy @lhs.env of
                           (Just previousctrt) -> (unifyC previousctrt @loc.ctrt) `o` @rhs.subst
                           Nothing             -> @rhs.subst        

      loc  .num     ::  uniqueref varcnt

attr DeclR
  syn  subst                                         :: Subst

  -- The function identifiers with their final contract, relies on env
  syn  contractedFuns use {`DM.union`}  {DM.empty}   :: CEnv

  -- The function identifiers with a fresh contract, doesn't rely on anything
  syn  functionIdents use {`DM.union`}  {DM.empty}   :: CEnv

sem DeclR
   | DHoleR
      lhs  .subst = SId
      lhs  .contractedFuns = DM.empty

   | DEmptyR
      lhs  .subst = SId
      lhs  .contractedFuns = DM.empty

   | DFunBindsR
      lhs  .subst = @funbinds.subst
      lhs  .contractedFuns = @funbinds.contractedFuns
      lhs  .functionIdents = @funbinds.functionIdents

   | DPatBindR  -- Used in lets, such as let (x:xs) = [1,2] in ...
      -- What we need to do here, is get a contract from the LHS and RHS,
      -- and then unify. This way, bound pattern variables will get their
      -- correct contracts. Then, we pass this information upwards.
      lhs  .subst = @loc.unifysubsts `o` @rhs.subst `o` @pat.subst

      lhs  .contractedFuns = DM.empty -- Can pattern-bound identifiers be top-level?
                                      -- If so, this is incorrect, and we'll have to
                                      -- pass @loc.finalEnv.

      -- We need to collect all the identifiers so these can be put
      -- in the environment of all (local) expressions, e.g.
      -- let (x:xs) = [1,2]
      --     f = xs ++ [x]
      -- in f
      lhs  .functionIdents = @pat.patternIdents

      -- Get environment from LHS, pass it to RHS

      -- TODO: Is envFromPats necessary here? lhs.functionIdents will
      -- pass all pattern-bound identifiers  to the environment anyway...
      --loc  .rhsEnv = DM.union @pat.envFromPats @lhs.env
      rhs  .env = @loc.rhsEnv

      -- Infer LHS and RHS, unify.
      loc  .unifysubsts    = unifyC @pat.infer @rhs.infer
      
      -- Now, we have to apply the substitutions to the envFromPats environment
      -- to get the final contracted patterns variables.
      -- TODO: Just pass this to the top?
      -- loc  .finalEnv       = subst (@loc.unifysubsts `o` @rhs.subst `o` @pat.subst) @loc.rhsEnv

-- Semantics for inferring a contract from an expression
sem ExprR
   | HoleR
      lhs  .infer   =   mkVar @loc.num
           .subst   =   SId

      loc  .num     ::  uniqueref varcnt

  | VarR
      lhs  .infer   =   @loc.infer'
           .subst   =   SId
           .resEnv  =   DM.singleton @name [@loc.infer']

      loc  .infer'  =   case @lhs.cann of
                         (Just ann)  -> ann
                         Nothing     -> envLU @name @lhs.env
      loc  .freshctrt = mkVar @loc.num
 
      -- Had to change this from Jurriën's implementation to reflect the fact that 
      -- identifiers can be referenced before they're defined, for example:
      -- f (x:xs) = g x ++ f xs
      -- g x = x
      -- We begin to infer for f, but encounter an unknown identifier, g.
      -- We rely on the compiler's correctness that g isn't just an unknown identifier,
      -- and give it a fresh contract variable.
      loc  .newIdent = case DM.lookup @nm @lhs.env of
                        (Just c) -> DM.empty
                        Nothing  -> DM.singleton @name @loc.freshctrt

      loc  .num     ::  uniqueref varcnt

  | LambdaR
      lhs  .infer   =   @loc.infer'
           .subst   =   @loc.th

      loc  .infer'  =   subst @loc.th $ @loc.x >-> @loc.c2
           .c2      =   @expr.infer
           .th      =   @expr.subst
           .x       =   case @lhs.cann of
                          (Just (CArr c1 _))  -> c1
                          _                   -> @loc.alpha
           .alpha   =   mkVar @loc.num
           .newenv  =   if (length @pats.copy) == 1
                         then case @pats.copy of
                               [(PVarR ev _)] -> DM.insert ev @loc.x @lhs.env
                               _              -> error "Only variables can be bound in a lambda!"
                         else error "Contract inferencing expects lambdas with a single variable!"
      loc  .num     ::  uniqueref varcnt

      pats .env     =   @loc.newenv
      pats .cann    =   case @lhs.cann of
                          (Just (CArr c1 _))  -> Just c1
                          _                   -> Nothing
      expr .env     =   @loc.newenv
      expr .cann    =   case @lhs.cann of
                          (Just (CArr _ c2))  -> Just c2
                          _                   -> Nothing


  | AppR
      lhs  .infer   =   @loc.infer'
           .subst   =   @loc.ths

      loc  .infer'  =   subst @loc.th3 @loc.alpha
           .ths     =   let  ths = @loc.th3 `o` @loc.th2 `o` @loc.th1
                        in   case @lhs.cann of
                               (Just ann)  -> unifyC ann @loc.infer' `o` ths
                               _           -> ths
           .c1      =   @fun.infer
           .th1     =   @fun.subst
           .e2env   =   subst @loc.th1 (DM.union @lhs.env @fun.
           .c2      =   @args.infer
           .th2     =   @args.subst
           .c1st    =   subst @loc.th2 @loc.c1
           .carr    =   @loc.c2 >-> @loc.alpha
           .th3     =   unifyC @loc.c1st @loc.carr
           .alpha   =   mkVar @loc.num
      loc  .num     ::  uniqueref varcnt

      args .env     =   subst @loc.th1 @loc.e2env

      fun  .cann    =   Nothing
      args .cann    =   Nothing

  | LetR
      lhs  .infer   =   @loc.c2
           .subst   =   @loc.ths

      -- TODO: This doesn't take into account patterns such as (x:xs) AT ALL!
      loc  .v       =   case (head @decls.copy) of
                          [DPatBindR (PVarR (IdentR x r) _) _ _] -> IdentR x r
                          x                                      -> error $ "Let definition has something else besides pattern binding! : " ++ show x

      -- v isn't in the AST, we only seem to need it for the string though
      -- v    .env     =   @loc.ve1env
      -- v    .cann    =   Nothing

      decls.env     =   @loc.ve1env
      decls.cann    =   DM.lookup @loc.lbvar @lhs.env

      expr .env     =   let  env' = subst @loc.th2d1 @lhs.env
                        in   case DM.lookup @loc.lbvar @lhs.env of
                               Just{}  -> @lhs.env
                               _       -> DM.insert @loc.lbvar @loc.varC env'

      loc  .lbvar   =   @loc.v
           .th1     =   @decls.subst
           .c1      =   @decls.infer
           .th2     =   unifyC (subst @loc.th1 @loc.var) @loc.c1
           .th2d1   =   @loc.th2 `o` @loc.th1
           .varC    =   gen  (subst @loc.th2d1 @lhs.env)
                             (subst @loc.th2 @loc.c1)
           .c2      =   @expr.infer
           .th3     =   @expr.subst
           .ths     =   @loc.th3 `o` @loc.th2d1
           .var     =   mkVar @loc.num
           .ve1env  =   case DM.lookup @loc.lbvar @lhs.env of
                          Just{}  -> @lhs.env
                          _       -> DM.insert @loc.lbvar @loc.var @lhs.env
      loc  .num     ::  uniqueref varcnt

  | LitR
      lhs  .infer   =   mkVarConst @loc.num @lit.copy
           .subst   =   SId

      loc  .num     ::  uniqueref varcnt

  | ParenR
      lhs  .infer   =   @expr.infer
           .subst   =   @expr.subst

  | ListR
      lhs  .infer   =   @exprs.infer
           .subst   =   @exprs.subst

 -- TODO: Think about making these more specific in case of a [x..] enum, perhaps [x..] unification is too general (or may even fail?)
  | EnumR
      lhs  .infer   =   @loc.inf
           .subst   =   @loc.ths

      loc  .inf     =   subst @loc.ths @loc.cfunc
           .cfunc   =   CFunctor @loc.var1 @loc.hdc
           .th1     =   @from.subst
           .th2     =   @to.subst
           .th3     =   unifyC @to.infer (subst @loc.th2 @loc.cfunc)
           .ths     =   @loc.th3 `o` @loc.th2 `o` @loc.th1
           .const   =   @from.isConst && @then.isConst && @to.isConst
           .var1    =   if @loc.const
                          then  mkVarConst @loc.num @loc.copy
                          else  mkVar @loc.num
           .hdc     =   if @loc.const
                          then  mkPlainC @from.infer
                          else  @from.infer
      loc  .num     ::  uniqueref varcnt

  | TupleR
      lhs  .infer   =   @exprs.infer
           .subst   =   @exprs.subst

  | CaseR
      lhs  .infer   =   @loc.inf
           .subst   =   @loc.altSubst

      loc  .inf       = subst @loc.altSubst @alts.infRhs
           .infLhs    = @alts.infLhs
           .subLhs    = @alts.subLhs
           .altSubst  = @loc.csubsts `o` @alts.subRhs `o` @alts.subLhs
           .matchC    = @expr.infer
           .csubsts   = unifyC @loc.matchC @loc.infLhs

      alts.inhSubsts = @loc.csubsts

attr TupleExprR -- List of ExprR for tuples, different semantics than a normal list of ExprR
  syn  infer                                         :: Contract
  syn  subst                                         :: Subst

sem TupleExprR
   | Cons
      lhs  .infer   =   CTuple ( @hd.infer : @tl.inferTl )
           .subst   =   @tl.subst `o` @hd.subst 
      loc  .inferTl =   case @tl.infer of
                         (CTuple xs) -> xs
                         x           -> x
   | Nil
      lhs  .infer   =   CTuple []
      lhs  .subst   =   SId



sem AltR
  | AHoleR
      lhs  .infer   =   mkVar @loc.num
           .subst   =   SId

      loc  .num     ::  uniqueref varcnt

  | AltR
      feedback : {Maybe String}
      pat      : PatR
      rhs      : RhsR
      range    : RangeR

  | AltEmptyR
      lhs  .infer   =   mkVar @loc.num
           .subst   =   SId

      loc  .num     ::  uniqueref varcnt


sem MaybeExprR
  | NoExprR
      lhs  .infer   =   mkVar @loc.num
           .subst   =   SId
      loc  .num     ::  uniqueref varcnt

  | JustExprR
      lhs  .infer   =   @expr.infer
           .subst   =   @expr.subst

sem ListExprR
  | Cons
      lhs  .infer   =   @loc.inf
           .subst   =   @loc.ths

      loc  .inf     =   subst @loc.ths @loc.cfunc
           .cfunc   =   CFunctor @loc.var1 @loc.hdc
           .th1     =   @hd.subst
           .th2     =   @tl.subst
           .th3     =   unifyC @tl.infer (subst @loc.th2 @loc.cfunc)
           .ths     =   @loc.th3 `o` @loc.th2 `o` @loc.th1
           .const   =   @hd.isConst && @tl.isConst
           .var1    =   if @loc.const
                          then  mkVarConst @loc.num @loc.copy
                          else  mkVar @loc.num
           .hdc     =   if @loc.const
                          then  mkPlainC @hd.infer
                          else  @hd.infer
      loc  .num     ::  uniqueref varcnt

  | Nil
      lhs  .infer   =   @loc.inf
           .subst   =   @loc.sub

      loc  .inf     =   CFunctor  (mkVarConst @loc.num1 @loc.copy)
                                  (mkVar @loc.num2)
           .sub     =   SId

      loc  .num1    ::  uniqueref varcnt
      loc  .num2    ::  uniqueref varcnt

sem PatR 
  | PHoleR -- Just a hole
      lhs  .infer   =   mkVar @loc.num
           .subst   =   SId
           .envFromPats = DM.empty

      loc  .num     ::  uniqueref varcnt

  | PConR -- a data constructor. Perhaps we can infer list and other contracts here?
      lhs  .infer   =   case @loc.specificInferCase of
                         (Just x) -> fst $ lookup x @loc.allInferrables
                         Nothing  -> @pats.infer
           .subst   =   case @loc.specificInferCase of
                         (Just x) -> fst $ lookup x @loc.allInferrables
                         Nothing  -> @pats.subst 
           .envFrompats = @pats.envFromPats

           -- All the specific contract inferring cases.
      loc  .allInferrables = [(@loc.nilResults,@loc.isNil)]

           -- A Maybe Int that identifies which inferring case is valid 
      loc  .specificInferCase = elemIndex True (snd @loc.allInferrables)

      -- SPECIFIC CASE 1: NIL OPERATOR --

      loc  .isNil   =  opIsNil @name.copy
           -- If it's Nil, we can infer a simple list contract!
           .inferNil =  CFunctor (mkVarConst @loc.numNil1 @loc.copy) (mkVar @loc.numNil2)
           .substNil =  SId

      loc  .nilResults = (@loc.inferNil,@loc.substNil)

      loc  .numNil1 :: uniqueref varcnt  
      loc  .numNil2 :: uniqueref varcnt  

    {-
      loc  .con     =   getVar @name.copy
           .isList  =   opIsList @name.copy
     
           -- If it's a list, we can infer a list contract!

           -- If it's a named variable, we can look it up in the environment.
           -- Otherwise, it's a literal or a wildcard or a hole or something,
           -- and we can make a fresh contract (HACK: we don't actually fetch
           -- the fresh contract made by the literal, wildcard or hole!!!)

           -- Fetch contract of head
           .headC   =   case (head @pats.copy) of 
                         (PVarR x) -> envLU x @pats.envFromPats
                         _         -> mkVar @loc.num1

           -- Fetch contract of tail
           .tailC   =   case (head.tail $ @pats.copy) of
                         (PVarR x) -> envLU x @pats.envFromPats
                         _         -> mkVar @loc.num2

           -- Make list contract
           .listC   =   CFunctor @loc.tailC @loc.headC
         
               
      loc  .num1    ::  uniqueref varcnt     
      loc  .num2    ::  uniqueref varcnt        
     -}

  | PInfixConR -- An infix PConR. Same thoughts as above, but here we can directly access our children!
      lhs  .infer   =   @loc.ctrt
           .subst   =   @loc.substs
           .envFrompats = DM.union @left.envFromPats @right.envFromPats

      loc  .ctrt    =   if @loc.isList
                         then @loc.infL
                         else mkVar @loc.numL
      loc  .substs  =   if @loc.isList
                         then @loc.thsL
                         else SId

           -- If it's a list, we can infer a list contract!
      loc  .isList  =   opIsList @name.copy

      loc  .infL    =   subst @loc.thsL @loc.cfuncL
           .cfuncL  =   CFunctor @loc.var1L @loc.hdcL
           .th1L    =   @left.subst
           .th2L    =   @right.subst
           .th3L    =   unifyC @right.infer (subst @loc.th2L @loc.cfuncL)
           .thsL    =   @loc.th3L `o` @loc.th2L `o` @loc.th1L
           .constL  =   @left.isConst && @right.isConst
           .var1L   =   if @loc.constL
                          then  mkVarConst @loc.numL @loc.copy
                          else  mkVar @loc.numL
           .hdcL    =   if @loc.constL
                          then  mkPlainC @left.infer
                          else  @left.infer
      loc  .numL    ::  uniqueref varcnt

  | PVarR -- A pattern variable defines a variable, so we need to put it in scope.
           -- Make a fresh contract for this fresh variable
      lhs  .infer   =   @loc.infer'
           -- No substitutions
           .subst   =   SId
           -- Add the contract to our environment.
           .envFromPats  =   DM.singleton @name [@loc.infer']

      loc  .infer'  = mkVar @loc.num

      loc  .num     ::  uniqueref varcnt

  | PLitR -- Copied from LitR, a literal pattern variable just gets assigned the True contract at the moment
      lhs  .infer   =   mkVarConst @loc.num @lit.copy
           .subst   =   SId
           .envFromPats  = DM.empty

      loc  .num     ::  uniqueref varcnt

  | PTupleR
      lhs  .infer   =   @pats.infer
           .subst   =   @pats.subst
           .envFromPats  = @pats.envFromPats


  | PParenR -- Copied from ParenR, just pass it along
      lhs  .infer   =   @pat.infer
           .subst   =   @pat.subst
           .envFromPats = DM.empty

  | PAsR -- example: p@(x:xs) in pattern match
           -- Pass along the pattern list contract
      lhs  .infer   =   @pat.infer
           -- These are pattern variables, so they should all have fresh contracts?
           -- Perhaps we should check this.
           .subst   =   SId
           -- p has the contract of the expression it's bound to.
           .envFromPats  =   DM.singleton @name [@pat.infer]

  | PWildcardR -- underscore in pattern match.
      lhs  .infer   =   mkVar @loc.num
           .subst   =   SId
           .envFromPats = DM.empty

      loc  .num     ::  uniqueref varcnt

  | PListR -- [x,y] pattern, just pass it along
      lhs  .infer   =   @pats.infer
           .subst   =   @pats.subst
           .envFromPats = @pats.envFromPats

sem ListPatsR -- Copied from ListExprR
  | Cons
      {-
      lhs  .infer   =   @loc.inf
           .subst   =   @loc.ths
      -}
      lhs  .envFromPats = DM.union @hd.envFromPats @tl.envFromPats
      lhs  .orderedPats = @hd.infer : @tl.infer

      -- TODO: Um, I don't think patterns are going to have the same contracts...
      -- Probably wasn't thinking right here and we can get rid of this code.
      {-
      loc  .inf     =   subst @loc.ths @loc.cfunc
           .cfunc   =   CFunctor @loc.var1 @loc.hdc
           .th1     =   @hd.subst
           .th2     =   @tl.subst
           .th3     =   unifyC @tl.infer (subst @loc.th2 @loc.cfunc)
           .ths     =   @loc.th3 `o` @loc.th2 `o` @loc.th1
           .const   =   @hd.isConst && @tl.isConst
           .var1    =   if @loc.const
                          then  mkVarConst @loc.num @loc.copy
                          else  mkVar @loc.num
           .hdc     =   if @loc.const
                          then  mkPlainC @hd.infer
                          else  @hd.infer
      loc  .num     ::  uniqueref varcnt
      -}

  | Nil
      {-
      lhs  .infer   =   @loc.inf
           .subst   =   @loc.sub
      -}
      lhs  .envFromPats = DM.empty
      lhs  .orderedPats = []

      {-
      loc  .inf     =   CFunctor  (mkVarConst @loc.num1 @loc.copy)
                                  (mkVar @loc.num2)
           .sub     =   SId

      loc  .num1    ::  uniqueref varcnt
      loc  .num2    ::  uniqueref varcnt
      -}

attr TuplePatsR
  syn  infer                                    :: Contract
  syn  subst                                    :: Subst

  syn envFromPats use {`urenv`}    {DM.empty}   :: CEnv

sem TuplePatsR
   | Cons
      lhs  .infer   =   CTuple ( @hd.infer : @tl.inferTl )
           .subst   =   @tl.subst `o` @hd.subst
      lhs  .envFromPats = DM.union @hd.envFromPats @tl.envFromPats
      loc  .inferTl =   case @tl.infer of
                         (CTuple xs) -> xs
                         x           -> x
   | Nil
      lhs  .infer   =   CTuple []
      lhs  .subst   =   SId
      lhs  .envFromPats = DM.empty


sem RhsR -- Type: RhsR :: ExprR -> DeclsR -> RangeR -> RhsR
         -- The DeclsR are the stuff in there where clause.
         -- We'll have to contract those things first, probably?
  | RhsR
      -- The substitions in the where clause have to be given to the RHS.
      lhs  .infer   =   @expr.infer
      lhs  .subst   =   @expr.subst

      -- We receive an environment filled with fresh patterns from the LHS.
      -- It gets passed to the where clause.

      -- Synthesize all the bound identifiers in the where-clause.
      -- functionIdents is a mapping from function identifiers to fresh contracts.
      loc  .whereIdents = @where.functionIdents

      -- Add these locally bound identifiers to the environment.
      -- These bindings overwrite any out-of-scope functions with the same name.
      loc .whereEnv     = DM.union @loc.whereIdents @lhs.env

      -- Pass this updated environment to the where clause, because these locally bound identifiers
      -- are probably used here as well.
      where.env     = @loc.whereEnv

      -- The where-clause itself generates an environment that is local to the expression,
      -- containing the final contracts for the local where-clause identifiers.
      -- Pass this env to the expression.

      -- UNCLEAR: Apply substitutions?
      expr .env     =   DM.union @where.envFromWhere @loc.whereEnv



      -- TODO: Substs were possibly generated for the out of scope functions,
      --       so we have to pass these substs upwards (both expr and where-clause).
      -- How to do this? 
