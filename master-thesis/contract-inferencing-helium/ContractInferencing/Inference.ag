MODULE {Domain.FP.ContractInferencing.Inference}{}


{
type CEnv = Map String Contract
}

--
attr ExprR MaybeExprR ListExprR
  syn  infer                                    :: Contract
  syn  resEnv    use {`urenv`}     {DM.empty}   :: {Map Name [Contract]}
  syn  subst                                    :: Subst
  syn  mkCtrd                                   :: ExprR

attr ExprR MaybeExprR ListExpR
  inh  env                                      :: CEnv
  inh  cann                                     :: {Maybe Contract}

attr PatR
  syn envFromPats use {`urenv`}    {DM.empty}   :: {Map Name [Contract]} 

attr ListPatsR
  syn envFromPats use {`urenv`}    {DM.empty}   :: {Map Name [Contract]} 

{-

Checklist:
                         EXPR
-- | A Haskell source module
DATA ModuleR
   | ModuleR

DATA BodyR
   | BHoleR
   | BodyR

-- | Declarations
DATA DeclR              
   | DHoleR
   | DEmptyR
   | DFunBindsR
   | DPatBindR

-- | Expressions         
DATA ExprR             
   | HoleR               DONE
   | FeedbackR
   | MustUseR
   | CaseR
   | ConR
   | IfR
   | InfixAppR
   | LambdaR             DONE
   | LetR                
   | LitR                
   | AppR                DONE
   | ParenR              
   | TupleR
   | VarR                DONE
   | EnumR               
   | ListR               
   | NegR

DATA MaybeExprR
   | NoExprR             
   | JustExprR           

-- | Alternatives
DATA AltR
   | AHoleR              DONE
   | AltR
   | AltEmptyR           DONE

-- | Function bindings
DATA FunBindR
   | FBHoleR             DONE
   | FunBindR            DONE

-- | Guarded expressions 
DATA GuardedExprR
   | GExprR

-- | Literal values
DATA LiteralR
   | LCharR
   | LFloatR
   | LIntR
   | LStringR

-- | Names
DATA NameR
   | IdentR
   | OperatorR
   | SpecialR

DATA MaybeNameR
   | NoNameR
   | JustNameR

-- | Patterns
DATA PatR
   | PHoleR              DONE
   | PConR               DONE
   | PInfixConR          DONE
   | PListR              DONE
   | PLitR               DONE
   | PParenR             DONE
   | PTupleR
   | PVarR               DONE
   | PAsR                DONE
   | PWildcardR          DONE

-- | Right hand side
DATA RhsR
   | RhsR
   | GRhsR

DATA RangeR
    | RangeR

DATA PositionR
    | PositionR
    | UnknownR
      

-}

attr FunBindsR -- List of FunBindR
  syn  contractedFuns use {`DM.union`}  {DM.empty}   :: {Map Name [Contract]}

attr FunBindR
  syn  infer                                         :: Contract
  syn  subst                                         :: Subst
  syn  contractedFuns use {`DM.union`}  {DM.empty}   :: {Map Name [Contract]}

sem FunBindR
   | FBHoleR
      lhs  .infer   =   mkVar @loc.num
           .subst   =   SId
           .contractedFuns = DM.empty

      loc  .num     ::  uniqueref varcnt

   -- (ident "f") [pats] = rhs
   | FunBindR
      lhs  .infer   =   @loc.fctrt -- Contract of function f
           .subst   =   @loc.finalsubsts -- Substitutions of RHS, LHS only generates SIds
           .contractedFuns = DM.singleton @name.copy @loc.fctrt
           -- NOTE: DM.union is left-biased, so it could be that "older" function contracts overwrite "newer" ones?

           -- Generate fresh contract for function identifier
           .fident  =   mkVar @loc.num -- give f a fresh contract

           -- Add (f :: TRUEi) to env, may overwrite a possible previous contract
           .newenv  =   DM.insert @name.copy @loc.fident @lhs.env

           -- collect contracts from patterns
           .patenvs =   @pats.envFromPats

           -- Combine contract environment, pass to RHS
           -- No unification or substitution? 
           -- Indeed, because the variables and function identifier in the LHS
           -- are all fresh anyway, and they're all unique identifiers.
      rhs  .env     =   DM.union @pats.envFromPats @lhs.newenv

           -- RHS may have generated substitutions on our pattern variables, need to update:
           .substp  =   subst @rhs.substs @pats.envFromPats

           -- With pattern contracts and RHS, construct new contract for f,
           -- for example C1 >-> C2 >-> @rhs.infer
           .fctrt   =   foldr (>->) @rhs.infer @loc.substp

           -- It's possible the function identifier already had its contract inferred previously:
           -- f (x:xs) = [x]
           -- f [] = []
           -- Unify the contracts of these definitions?
           .finalsubsts = case DM.lookup @name.copy @lhs.env of
                           (Just previousctrt) -> (unifyC previousctrt @loc.ctrt) `o` @rhs.subst
                           Nothing             -> @rhs.subst        

      loc  .num     ::  uniqueref varcnt

attr DeclR
  syn  contractedFuns use {`DM.union`}  {DM.empty}   :: {Map Name [Contract]}

sem DeclR
   | DHoleR
      lhs  .contractedFuns = DM.empty

   | DEmptyR
      lhs  .contractedFuns = DM.empty

   | DPatBindR  -- Used in lets, such as let (x:xs) = [1,2] in ...
      -- What we need to do here, is get a contract from the LHS and RHS,
      -- and then unify. This way, bound pattern variables will get their
      -- correct contracts. Then, we pass this information upwards.

      lhs  .contractedFuns =

      -- Get environment from LHS, pass it to RHS
      rhs  .env = DM.union @pat.envFromPats @lhs.env

      -- Infer LHS and RHS, unify.
      loc  .unifysubsts    = unifyC @pat.infer @rhs.infer
      
      -- Now, we have to apply the substitutions to the envFromPats environment
      -- to get the final contracted patterns variables.
      loc  .finalEnv       = subst (@loc.unifysubsts `o` @rhs.subst) 

      @pat.infer
      @rhs.infer
      

      pat      : PatR
      rhs      : RhsR
      range    : RangeR


-- Semantics for inferring a contract from an expression
sem ExprR
   | HoleR
      lhs  .infer   =   mkVar @loc.num
           .subst   =   SId

      loc  .num     ::  uniqueref varcnt

  | VarR
      lhs  .infer   =   @loc.infer'
           .subst   =   SId
           .resEnv  =   DM.singleton @name [@loc.infer']

     loc  .infer'  =   case @lhs.cann of
                         (Just ann)  -> ann
                         _           -> envLU @nm @lhs.env

  | LambdaR
      lhs  .infer   =   @loc.infer'
           .subst   =   @loc.th

      loc  .infer'  =   subst @loc.th $ @loc.x >-> @loc.c2
           .c2      =   @expr.infer
           .th      =   @expr.subst
           .x       =   case @lhs.cann of
                          (Just (CArr c1 _))  -> c1
                          _                   -> @loc.alpha
           .alpha   =   mkVar @loc.num
           .newenv  =   if (length @pats.copy) == 1
                         then case @pats.copy of
                               [(PVarR ev _)] -> DM.insert ev @loc.x @lhs.env
                               _              -> error "Only variables can be bound in a lambda!"
                         else error "Contract inferencing expects lambdas with a single variable!"
      loc  .num     ::  uniqueref varcnt

      pats .env     =   @loc.newenv
      pats .cann    =   case @lhs.cann of
                          (Just (CArr c1 _))  -> Just c1
                          _                   -> Nothing
      expr .env     =   @loc.newenv
      expr .cann    =   case @lhs.cann of
                          (Just (CArr _ c2))  -> Just c2
                          _                   -> Nothing


  | AppR
      lhs  .infer   =   @loc.infer'
           .subst   =   @loc.ths

      loc  .infer'  =   subst @loc.th3 @loc.alpha
           .ths     =   let  ths = @loc.th3 `o` @loc.th2 `o` @loc.th1
                        in   case @lhs.cann of
                               (Just ann)  -> unifyC ann @loc.infer' `o` ths
                               _           -> ths
           .c1      =   @fun.infer
           .th1     =   @fun.subst
           .e2env   =   subst @loc.th1 @lhs.env
           .c2      =   @args.infer
           .th2     =   @args.subst
           .c1st    =   subst @loc.th2 @loc.c1
           .carr    =   @loc.c2 >-> @loc.alpha
           .th3     =   unifyC @loc.c1st @loc.carr
           .alpha   =   mkVar @loc.num
      loc  .num     ::  uniqueref varcnt

      args .env     =   subst @loc.th1 @loc.e2env

      fun  .cann    =   Nothing
      args .cann    =   Nothing

  | LetR
      lhs  .infer   =   @loc.c2
           .subst   =   @loc.ths

      loc  .v       =   case (head @decls.copy) of
                          [DPatBindR (PVarR (IdentR x r) _) _ _] -> IdentR x r
                          x                                      -> error $ "Let definition has something else besides pattern binding! : " ++ show x

      -- v isn't in the AST, we only seem to need it for the string though
      -- v    .env     =   @loc.ve1env
      -- v    .cann    =   Nothing

      decls.env     =   @loc.ve1env
      decls.cann    =   DM.lookup @loc.lbvar @lhs.env

      expr .env     =   let  env' = subst @loc.th2d1 @lhs.env
                        in   case DM.lookup @loc.lbvar @lhs.env of
                               Just{}  -> @lhs.env
                               _       -> DM.insert @loc.lbvar @loc.varC env'

      loc  .lbvar   =   @loc.v
           .th1     =   @decls.subst
           .c1      =   @decls.infer
           .th2     =   unifyC (subst @loc.th1 @loc.var) @loc.c1
           .th2d1   =   @loc.th2 `o` @loc.th1
           .varC    =   gen  (subst @loc.th2d1 @lhs.env)
                             (subst @loc.th2 @loc.c1)
           .c2      =   @expr.infer
           .th3     =   @expr.subst
           .ths     =   @loc.th3 `o` @loc.th2d1
           .var     =   mkVar @loc.num
           .ve1env  =   case DM.lookup @loc.lbvar @lhs.env of
                          Just{}  -> @lhs.env
                          _       -> DM.insert @loc.lbvar @loc.var @lhs.env
      loc  .num     ::  uniqueref varcnt

  | LitR
      lhs  .infer   =   mkVarConst @loc.num @lit.copy
           .subst   =   SId

      loc  .num     ::  uniqueref varcnt

  | ParenR
      lhs  .infer   =   @expr.infer
           .subst   =   @expr.subst

  | ListR
      lhs  .infer   =   @exprs.infer
           .subst   =   @exprs.subst

 -- TODO: Think about making these more specific in case of a [x..] enum, perhaps [x..] unification is too general (or may even fail?)
  | EnumR
      lhs  .infer   =   @loc.inf
           .subst   =   @loc.ths

      loc  .inf     =   subst @loc.ths @loc.cfunc
           .cfunc   =   CFunctor @loc.var1 @loc.hdc
           .th1     =   @from.subst
           .th2     =   @to.subst
           .th3     =   unifyC @to.infer (subst @loc.th2 @loc.cfunc)
           .ths     =   @loc.th3 `o` @loc.th2 `o` @loc.th1
           .const   =   @from.isConst && @then.isConst && @to.isConst
           .var1    =   if @loc.const
                          then  mkVarConst @loc.num @loc.copy
                          else  mkVar @loc.num
           .hdc     =   if @loc.const
                          then  mkPlainC @from.infer
                          else  @from.infer
      loc  .num     ::  uniqueref varcnt

  | CaseR
      lhs  .infer   =   @loc.inf
           .subst   =   @loc.altSubst

      loc  .inf       = subst @loc.altSubst @alts.infRhs
           .infLhs    = @alts.infLhs
           .subLhs    = @alts.subLhs
           .altSubst  = @loc.csubsts `o` @alts.subRhs `o` @alts.subLhs
           .matchC    = @expr.infer
           .csubsts   = unifyC @loc.matchC @loc.infLhs

      alts.inhSubsts = @loc.csubsts

sem AltR
  | AHoleR
      lhs  .infer   =   mkVar @loc.num
           .subst   =   SId

      loc  .num     ::  uniqueref varcnt

  | AltR
      feedback : {Maybe String}
      pat      : PatR
      rhs      : RhsR
      range    : RangeR

  | AltEmptyR
      lhs  .infer   =   mkVar @loc.num
           .subst   =   SId

      loc  .num     ::  uniqueref varcnt


sem MaybeExprR
  | NoExprR
      lhs  .infer   =   mkVar @loc.num
           .subst   =   SId
      loc  .num     ::  uniqueref varcnt

  | JustExprR
      lhs  .infer   =   @expr.infer
           .subst   =   @expr.subst

sem ListExprR
  | Cons
      lhs  .infer   =   @loc.inf
           .subst   =   @loc.ths

      loc  .inf     =   subst @loc.ths @loc.cfunc
           .cfunc   =   CFunctor @loc.var1 @loc.hdc
           .th1     =   @hd.subst
           .th2     =   @tl.subst
           .th3     =   unifyC @tl.infer (subst @loc.th2 @loc.cfunc)
           .ths     =   @loc.th3 `o` @loc.th2 `o` @loc.th1
           .const   =   @hd.isConst && @tl.isConst
           .var1    =   if @loc.const
                          then  mkVarConst @loc.num @loc.copy
                          else  mkVar @loc.num
           .hdc     =   if @loc.const
                          then  mkPlainC @hd.infer
                          else  @hd.infer
      loc  .num     ::  uniqueref varcnt

  | Nil
      lhs  .infer   =   @loc.inf
           .subst   =   @loc.sub

      loc  .inf     =   CFunctor  (mkVarConst @loc.num1 @loc.copy)
                                  (mkVar @loc.num2)
           .sub     =   SId

      loc  .num1    ::  uniqueref varcnt
      loc  .num2    ::  uniqueref varcnt

sem PatR 
  | PHoleR -- Just a hole
      lhs  .infer   =   mkVar @loc.num
           .subst   =   SId
           .envFromPats = DM.empty

      loc  .num     ::  uniqueref varcnt

  | PConR -- a data constructor. Perhaps we can infer list and other contracts here?
      lhs  .infer   =   case @loc.specificInferCase of
                         (Just x) -> fst $ lookup x @loc.allInferrables
                         Nothing  -> @pats.infer
           .subst   =   case @loc.specificInferCase of
                         (Just x) -> fst $ lookup x @loc.allInferrables
                         Nothing  -> @pats.subst 
           .envFrompats = @pats.envFromPats

           -- All the specific contract inferring cases.
      loc  .allInferrables = [(@loc.nilResults,@loc.isNil)]

           -- A Maybe Int that identifies which inferring case is valid 
      loc  .specificInferCase = elemIndex True (snd @loc.allInferrables)

      -- SPECIFIC CASE 1: NIL OPERATOR --

      loc  .isNil   =  opIsNil @name.copy
           -- If it's Nil, we can infer a simple list contract!
           .inferNil =  CFunctor (mkVarConst @loc.numNil1 @loc.copy) (mkVar @loc.numNil2)
           .substNil =  SId

      loc  .nilResults = (@loc.inferNil,@loc.substNil)

      loc  .numNil1 :: uniqueref varcnt  
      loc  .numNil2 :: uniqueref varcnt  

    {-
      loc  .con     =   getVar @name.copy
           .isList  =   opIsList @name.copy
     
           -- If it's a list, we can infer a list contract!

           -- If it's a named variable, we can look it up in the environment.
           -- Otherwise, it's a literal or a wildcard or a hole or something,
           -- and we can make a fresh contract (HACK: we don't actually fetch
           -- the fresh contract made by the literal, wildcard or hole!!!)

           -- Fetch contract of head
           .headC   =   case (head @pats.copy) of 
                         (PVarR x) -> envLU x @pats.envFromPats
                         _         -> mkVar @loc.num1

           -- Fetch contract of tail
           .tailC   =   case (head.tail $ @pats.copy) of
                         (PVarR x) -> envLU x @pats.envFromPats
                         _         -> mkVar @loc.num2

           -- Make list contract
           .listC   =   CFunctor @loc.tailC @loc.headC
         
               
      loc  .num1    ::  uniqueref varcnt     
      loc  .num2    ::  uniqueref varcnt        
     -}

  | PInfixConR -- An infix PConR. Same thoughts as above, but here we can directly access our children!
      lhs  .infer   =   @loc.ctrt
           .subst   =   @loc.substs
           .envFrompats = DM.union @left.envFromPats @right.envFromPats

      loc  .ctrt    =   if @loc.isList
                         then @loc.infL
                         else mkVar @loc.numL
      loc  .substs  =   if @loc.isList
                         then @loc.thsL
                         else SId

           -- If it's a list, we can infer a list contract!
      loc  .isList  =   opIsList @name.copy

      loc  .infL    =   subst @loc.thsL @loc.cfuncL
           .cfuncL  =   CFunctor @loc.var1L @loc.hdcL
           .th1L    =   @left.subst
           .th2L    =   @right.subst
           .th3L    =   unifyC @right.infer (subst @loc.th2L @loc.cfuncL)
           .thsL    =   @loc.th3L `o` @loc.th2L `o` @loc.th1L
           .constL  =   @left.isConst && @right.isConst
           .var1L   =   if @loc.constL
                          then  mkVarConst @loc.numL @loc.copy
                          else  mkVar @loc.numL
           .hdcL    =   if @loc.constL
                          then  mkPlainC @left.infer
                          else  @left.infer
      loc  .numL    ::  uniqueref varcnt

  | PVarR -- A pattern variable defines a variable, so we need to put it in scope.
           -- Make a fresh contract for this fresh variable
      lhs  .infer   =   @loc.infer'
           -- No substitutions
           .subst   =   SId
           -- Add the contract to our environment.
           .envFromPats  =   DM.singleton @name [@loc.infer']

      loc  .infer'  = mkVar @loc.num

      loc  .num     ::  uniqueref varcnt

  | PLitR -- Copied from LitR, a literal pattern variable just gets assigned the True contract at the moment
      lhs  .infer   =   mkVarConst @loc.num @lit.copy
           .subst   =   SId
           .envFromPats  = DM.empty

      loc  .num     ::  uniqueref varcnt

  | PParenR -- Copied from ParenR, just pass it along
      lhs  .infer   =   @pat.infer
           .subst   =   @pat.subst
           .envFromPats = DM.empty

  | PAsR -- example: p@(x:xs) in pattern match
           -- Pass along the pattern list contract
      lhs  .infer   =   @pat.infer
           -- These are pattern variables, so they should all have fresh contracts?
           -- Perhaps we should check this.
           .subst   =   SId
           -- p has the contract of the expression it's bound to.
           .envFromPats  =   DM.singleton @name [@pat.infer]

  | PWildcardR -- underscore in pattern match.
      lhs  .infer   =   mkVar @loc.num
           .subst   =   SId
           .envFromPats = DM.empty

      loc  .num     ::  uniqueref varcnt

  | PListR -- [x,y] pattern, just pass it along
      lhs  .infer   =   @pats.infer
           .subst   =   @pats.subst
           .envFromPats = @pats.envFromPats

sem ListPatsR -- Copied from ListExprR
  | Cons
      lhs  .infer   =   @loc.inf
           .subst   =   @loc.ths
      lhs  .envFromPats = DM.union @hd.envFromPats @tl.envFromPats

      loc  .inf     =   subst @loc.ths @loc.cfunc
           .cfunc   =   CFunctor @loc.var1 @loc.hdc
           .th1     =   @hd.subst
           .th2     =   @tl.subst
           .th3     =   unifyC @tl.infer (subst @loc.th2 @loc.cfunc)
           .ths     =   @loc.th3 `o` @loc.th2 `o` @loc.th1
           .const   =   @hd.isConst && @tl.isConst
           .var1    =   if @loc.const
                          then  mkVarConst @loc.num @loc.copy
                          else  mkVar @loc.num
           .hdc     =   if @loc.const
                          then  mkPlainC @hd.infer
                          else  @hd.infer
      loc  .num     ::  uniqueref varcnt

  | Nil
      lhs  .infer   =   @loc.inf
           .subst   =   @loc.sub
      lhs  .envFromPats = DM.empty

      loc  .inf     =   CFunctor  (mkVarConst @loc.num1 @loc.copy)
                                  (mkVar @loc.num2)
           .sub     =   SId

      loc  .num1    ::  uniqueref varcnt
      loc  .num2    ::  uniqueref varcnt

sem RhsR -- Type: RhsR :: ExprR -> DeclsR -> RangeR -> RhsR
         -- The DeclsR are the stuff in there where clause.
         -- We'll have to contract those things first, probably?
  | RhsR
      -- The substitions in the where clause and the in
      lhs  .infer   =   @expr.infer
      lhs  .subst   =   @expr.subst

      expr .env     =   @lhs.env --DM.union @lhs.env @where.envFromWhere
