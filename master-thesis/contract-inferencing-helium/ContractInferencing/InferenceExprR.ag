-- ~/thesis/FPTutor/trunk/src$ ~/.cabal/bin/uuagc -dcfswH --module="Domain.FP.ContractInferencing.InferenceExprR" Domain/FP/ContractInferencing/InferenceExprR.ag

-- Include simplified syntax used by Ask-Elle
--include "Domain/FP/SyntaxWithRanges.ag"

-- Include contract types
--include "Domain/FP/ContractInferencing/ContractTypes.ag"

-- Include utility functions
--include "Domain/FP/CodeGeneration/Utils.ag"

attr BodyR DeclR DeclsR ExprR ExprsR PatR PatsR AltR AltsR FunBindR FunBindsR GuardedExprR GuardedExprsR LiteralR RhsR MaybeExprR ListExprR TupleExprR ListPatsR TuplePatsR MaybeConst
   inh availableContractVars                                    :: {ContractOffset}

sem ModuleR
  | ModuleR
      body .availableContractVars = @body.contractVariableOffset

-- We want two kinds of substitutions:
-- LOCAL substitutions are substitutions that substitute a polymorphic contract
-- variable for a monomorphic one. Such substitutions are sent downwards in the AST.
-- GLOBAL substitutions substitute one polymorphic contract variable for another. 
-- These are synthesized to the top of the AST, where they are collected.
-- These are to be applied first to a contract, and presumably to the list of of LOCAL
-- substitutions as well. Afterwards, the local substitutions are applied to the contract
-- to get the final contract.

-- Data we have from code generation:
-- Contracts have been generated for each VarR, which are based upon
-- types from the type tree. These types are already the most specific for a
-- certain function application.


attr ExprR
  syn  infer                                         :: Contract
  syn  subst                                         :: Subst
--  inh  locsubst                                      :: Subst

sem ExprR
  | HoleR
      lhs  .infer   =   mkCtrt (@loc.num + @lhs.availableContractVars)
           .subst   =   SId
      loc  .num     ::  uniqueref varcnt

  | FeedbackR MustUseR NegR ParenR
      lhs  .infer   =   @expr.infer
           .subst   =   @expr.subst

  | ListR TupleR
      lhs  .infer   =   @exprs.infer
           .subst   =   @exprs.subst

  | IfR
      lhs  .infer   =   subst @loc.subst @then.infer
           .subst   =   @loc.subst
      loc  .subst   =   fst @loc.unify `o` @cond.subst `o` @then.subst `o` @else.subst
      loc  .unify   =   splitSubsts $ unifyC @then.infer @else.infer
           .localsubsts = snd @loc.unify

  | VarR
      lhs  .infer   = stripQuantifiers $ @loc.varContract -- Contract derived from type tree type, all fresh polymorphic contract vars
           .subst   =   SId

  | ConR -- TODO: This will give odd results when using constructors many times, I think.
      lhs  .infer   =   stripQuantifiers $ @loc.varContract
           .subst   =   SId

  | LitR -- TODO: check if this is returning correct (= monomorphic) contracts
      lhs  .infer   =   stripQuantifiers $ snd @loc.results
           .subst   =   SId
      lit  .freshContractVariable = fst @loc.results
      loc  .results =   convertTopTypeToContract @lhs.freshContractVariable @loc.astType 

  | AppR
      lhs  .infer   =   @loc.infer'
           .subst   =   @loc.ths

--      fun  .locsubst   =   @loc.localsubsts -- TODO: Local substs will probably refer to old variables, may need to update those.
--      args .locsubst   =   @loc.localsubsts

      loc  .localsubsts = snd @loc.th3'
      

      loc  .infer'  =   subst @loc.th3 @loc.alpha
           .ths     =   let  ths = fst @loc.th3' `o` @loc.th2 `o` @loc.th1
                        in   ths --case @lhs.cann of
                             --  (Just ann)  -> unifyC ann @loc.infer' `o` ths
                             --  _           -> ths
           .th3'    =   splitSubsts @loc.th3
           .c1      =   @fun.infer
           .th1     =   @fun.subst
           -- .e2env   =   subst @loc.th1 @lhs.env
           .c2      =   @args.infer
           .th2     =   @args.subst
           .c1st    =   subst @loc.th2 @loc.c1
           .carr    =   @loc.c2 >-> @loc.alpha
           .th3     =   unifyC @loc.c1st @loc.carr
--           .th3     =   unifyC @loc.carr @loc.c1st -- TODO: I swapped the arguments around. What are the implications?
                                                   -- Seems to just change the way global substitutions flow. Should check locals
           .alpha   =   mkCtrt (@loc.num + @lhs.availableContractVars)
      loc  .num     ::  uniqueref varcnt

      -- args .env     =   subst @loc.th1 @loc.e2env

      --fun  .cann    =   Nothing
      --args .cann    =   Nothing

  | LetR
      lhs  .infer   =   @expr.infer
           .subst   =   @expr.subst `o` @decls.subst

attr ExprsR ListExprR
  syn  infer                                         :: Contract
  syn  subst                                         :: Subst
  inh  subst                                         :: Subst

--ExprsR is only used in AppR.
sem ExprsR
  | Cons 
      lhs  .infer   =   @hd.infer -- We've transformed the AST so each AppR only has a single argument.
           .subst   =   @hd.subst
   | Nil
      lhs  .infer   =   mkCtrt @loc.num
           .subst   =   SId

      loc  .num     ::  uniqueref varcnt

-- ListExprR is only used in ListR
sem ListExprR
  | Cons
      lhs  .infer   =   @loc.inf
           .subst   =   @loc.ths

      loc  .inf     =   subst @loc.ths @loc.cfunc
           .cfunc   =   CFunctor @loc.var1 @loc.hdc
           .th1     =   @hd.subst
           .th2     =   @tl.subst
           .th3     =   unifyC @tl.infer (subst @loc.th2 @loc.cfunc)
           .ths     =   @loc.th3 `o` @loc.th2 `o` @loc.th1
--           .const   =   @hd.isConst && @tl.isConst
--           .var1    =   if @loc.const
--                          then  mkVarConst @loc.num @loc.copy
--                          else  mkVar @loc.num
           .var1    =   mkCtrt (@loc.num + @lhs.availableContractVars)
           .hdc     =   @hd.infer
--           .hdc     =   if @loc.const
--                          then  mkPlainC @hd.infer
--                          else  @hd.infer
      loc  .num     ::  uniqueref varcnt

  | Nil
      lhs  .infer   =   @loc.inf
           .subst   =   @loc.sub

      loc  .inf     =   CFunctor  (mkCtrt (@loc.num1 + @lhs.availableContractVars))
                                  (mkCtrt (@loc.num2 + @lhs.availableContractVars))
           .sub     =   SId

      loc  .num1    ::  uniqueref varcnt
      loc  .num2    ::  uniqueref varcnt

attr TupleExprR
  syn  infer                                         :: Contract
  syn  minfer                                        :: {Maybe Contract}
  syn  subst                                         :: Subst

-- TupleExprR is only used in TupleR
sem TupleExprR
  | Cons
      loc  .infer   =   case @tl.minfer of
                         (Just tl) -> CBifunctor (mkCtrt (@loc.num + @lhs.availableContractVars)) @hd.infer tl
                         Nothing -> @hd.infer
      lhs  .infer   =	@loc.infer
      lhs  .minfer  =   Just @hd.infer
           .subst   =   @tl.subst `o` @hd.subst 
      loc  .num     ::  uniqueref varcnt

  | Nil
      lhs  .infer   =   mkCtrt (@loc.num + @lhs.availableContractVars)
           .minfer  =   Nothing
           .subst   =   SId
      loc  .num     ::  uniqueref varcnt
