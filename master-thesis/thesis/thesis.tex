\documentclass[10pt]{report}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[numbers]{natbib}
\usepackage{bussproofs}
\usepackage{color}
\usepackage{listings}
\usepackage{ amssymb }
\usepackage{courier}
\usepackage[pdftex]{graphicx}
\lstset{language=Haskell}
\lstset{breaklines=true}
\lstset{basicstyle=\scriptsize\sffamily}
\lstset{frame=single}
\lstset{showstringspaces=false}
\lstset{captionpos=b}
\usepackage{url}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{pdfpages}

\usepackage{attrib}
\usepackage{framed}

\newcommand{\functor}{<\!\!\!@\!\!\!>}
\newcommand{\bifunctor}{<\!\!\!@\!\!@\!\!\!>}

\newcommand{\W}{$\mathcal{W}$}
\newcommand{\CW}{$\mathcal{CW}$}
\newcommand{\CHW}{$\mathcal{CHW}$}

\newcommand{\ctrttemplate}{\underline{\hspace{1.5em}}contracted\_\code{X}}
\newcommand{\finaltemplate}{\underline{\hspace{1.5em}}final\_\code{X}}
\newcommand{\apptemplate}{\underline{\hspace{1.5em}}app\_\code{X}}

\newcommand{\sref}[1]{Section~\ref{#1}}
\newcommand{\annotate}[3]{
	\begin{scriptsize}
	\textcolor{#1}{\textbf{#2}~\textit{#3}}
	\end{scriptsize}\newline}
\newcommand{\todo}[1]{\annotate{red} {TODO:} {#1}}
\newcommand{\review}{\annotate{blue} {REVIEW:} {Please review the following text. \newline}}

\newcommand{\explain}[1]{\quad\{\;\text{#1}\;\}}
\newcommand{\justify}[1]{\quad\{\;\text{#1}\;\}}
\newcommand{\johan}[1]{[\textit{Johan says:}~#1]}
\newcommand{\augusto}[1]{[\textit{Augusto says:}~#1]}


\definecolor{light-gray}{gray}{0.95}
\newcommand{\code}[1]{%
  {% open a group for a local setting
   \setlength{\fboxsep}{-2\fboxrule}% the rule will be inside the box boundary
   \fcolorbox{black}{light-gray}{\hspace{1.5pt}\strut\texttt{#1}\hspace{1.5pt}}% print the box, with some padding at the left and right
  }% close the group
}

\author{
	Beerend Lauwers\\
	Utrecht University, The Netherlands}
\date{\today}
\title{Contract Inference for the Helium Functional Programming Language}
\begin{document}

\maketitle


\begin{abstract}
Ask-Elle is a programming tutor created by Alex Gerdes \cite{Gerdes:2012:phd} which utilizes (transformations of) model solutions to provide feedback to students on their exercise progress.
However, if a student's program cannot be reduced to such a model solution, providing helpful feedback becomes hard to do. 
The Master Thesis of Jurri\"en Stutterheim \cite{Stutterheim:2013:thesis} focuses on the development of a contract inference system for functional programs, with the goal to embed this functionality in the Ask-Elle programming tutor to provide a new source of meaningful feedback to students using the tutor.
This thesis builds upon his work, extending the contract inference algorithm to work with the language used by the Ask-Elle programming tutor: Helium.
This language is a subset of the Haskell functional programming language.
Additionally, a code generation system  for the \textit{typed-contracts} Haskell library is developed that annotates an arbitrary section of Helium code with contracts inferred by the extended contract inference algorithm.
\end{abstract}

\tableofcontents

\chapter{Introduction}

The Ask-Elle programming tutor is a web-based programming tutor created by Alex Gerdes \cite{Gerdes:2012:phd} that provides feedback on a student's progress in programming exercises in a language similar to Haskell, named Helium.
To facilitate this, the tutor is given several solutions to an exercise when defining an exercise.
It then uses strategies to reduce a student's input to one of these solutions, even idenitifying how many steps they are removed from the solution.
The tutor can then provide hints and other forms of feedback to help along the student.
Because it is possible that a student may come up with a solution that is not known by Ask-Elle, QuickCheck \cite{Claessen:2000p592} properties can be defined for an exercise that define the correctness of the solution.
For instance, one of the properties of a sorting function is that the sorted list must be a permutation of the original list: no elements may be removed or added during sorting.

These properties are then used to test the student's solution by randomly generating inputs to the proposed solution until an input causes a violation of the properties (called a \textit{counter-example}) or until a set testing limit is reached.
In the case of a failed test, Ask-Elle provides the student with the counter-example as feedback.
Compared to the rich feedback when a solution strategy can be identified, this information is rather poor, barely more useful than the message \textit{"There is an error present in your code."}

The motivation behind the Master Thesis of Jurri\"en Stutterheim \cite{Stutterheim:2013:thesis} is to fill up this feedback void.
To do so, he develops a contract inference system for functional programs, producing a contract inference algorithm for a simply-typed lambda calculus and proving the algorithm is sound.

Stutterheim aimed to combine the QuickCheck properties with the contract inference algorithm to generate contracted code that, in the event of a contract violation due to a counter-example generated by QuickCheck, would pinpoint exactly where the issue lies in a student's code.
This functionality was to be integrated into the Ask-Elle programming tutor, but remained future work.

This thesis builds upon Stutterheim's work, extending the contract inference algorithm to work with the syntax Ask-Elle uses to analyze a student's solution attempts.
This syntax is a slightly leaner version of the full Helium syntax, itself a subset of the Haskell programming language.
More precisely, Helium is a subset of the Haskell 98 language specification.

Additionally, a code generation system is developed for the \textit{typed-contracts} library by Hinze et al. \cite{Hinze06typedcontracts}, a Haskell library to define and assert contracts on functions.
This code generation system is largely library-agnostic and can be extended to generate code for different libraries.

In the following chapter, we provide the reader with a good background on contracts in functional programming languages, using examples from the \textit{typed-contracts} library to explain the concept.
Furthermore, we quickly go through the results of Stutterheim's thesis to understand the foundations upon which this thesis is built.
Related work in contracts and contract inference is discussed, as well.
Chapter \ref{chapter-overview} provides an overview of our improvements upon Stutterheim's work.
Chapter \ref{chapter-system-design} follows the flow of a piece of code as it goes through the entire system, the main parts consisting of the contract inference and code generation subsystems.
As we encounter each subsystem, we explain key concepts, definitions and how the system differs from Stutterheim's original work (if applicable).
Afterwards, in Chapter \ref{futurework}, we discuss improvements that can be made to our contract inference algorithm and other future work.
Finally, we conclude in Chapter \ref{chapter-conclusion}.

\chapter{Background}

In this chapter, we familiarize the reader with some concepts that are used in the rest of this thesis, the most important ones being \textit{contracts} and the notion of \textit{inferring} types and contracts.

This thesis concerns itself with \textit{contract inference}.
Let us break up this term and investigate each element thoroughly before moving on.

\section{Contracts}
In programming, a $contract$ is very much like its real-world counterpart: it stipulates prerequisites and guarantees between two parties.
In our case, the parties are the function being called (the $callee$) and the function receiving the result (the $caller$).

As a simple example, one could specify a contract that a function will only accept a natural number: a prerequisite.
Likewise, it is possible to state that a function must also always return a natural number: a guarantee.
By combining prerequisites and guarantees for arguments and results, respectively, it is possible to construct very specific contracts that are quite useful for tracking down bugs.
Just like in real life, these contracts can be violated, which will halt the program with an exception detailing which contract was violated at what position in the code.

When this happens, blame must be assigned.
A prerequisite violation is to be blamed on the $caller$: it was this function that should have provided a valid argument.
Likewise, a guarantee violation is to be blamed on the $callee$: there is a fault in the function being called that causes it to return an invalid result.

In other words, adding contracts to one's code adds an element of automated testing and aids in debugging any faults that may arise by being able to specify what exactly went wrong, and where.

This thesis builds upon the thesis of Stutterheim \cite{Stutterheim:2013:thesis}, who developed an algorithm for contract inference on a simple recursive let lambda language with support for holes.
While Stutterheim's contract grammar is library-agnostic, he chose to generate code for the \textit{typed-contracts} library by Hinze et al. \cite{Hinze06typedcontracts}. 
Also of interest is the library by Chitil \cite{Chitil:2012ua}, which is based on the work of Hinze et al.

\subsection{The \textit{typed-contracts} library}
Let us examine the library for which code will be generated.
Hinze et al. define the \code{Contract} type using a GADT:

\begin{lstlisting}[mathescape]
data Contract a where
   Prop      :: (a $\rightarrow$ Bool) $\rightarrow$ Contract a
   Function  :: Contract a $\rightarrow$ (a $\rightarrow$ Contract b) $\rightarrow$ Contract (a $\rightarrowtail$ b)
   Pair      :: Contract a $\rightarrow$ (a $\rightarrow$ Contract b) $\rightarrow$ Contract (a, b)
   List      :: Contract a $\rightarrow$ Contract [a]
   Functor   :: Functor f $\Rightarrow$ Contract a $\rightarrow$ Contract (f a)
   Bifunctor :: Bifunctor f $\Rightarrow$ Contract a $\rightarrow$ Contract b $\rightarrow$ Contract (f a b)
   And       :: Contract a $\rightarrow$ Contract a $\rightarrow$ Contract a
\end{lstlisting}

Let us go over each data constructor:
\begin{description}
	\item{\code{Prop} } is what one uses to actually define a constraint or property on a value. Given a function that expects a value of type \code{a} and which returns a Boolean, it produces a contract for something of type \code{a}. In other words, it lifts a function to a contract.
	\item{\code{Function} } is used to define a dependent function contract.
	\item{\code{Pair} } similarly defines a dependent pair contract.
	\item{\code{List} } is straightforward: it lifts contracts to the list level.
	\item{\code{Functor} } is a container that can house types of kind $* \rightarrow *$.
	\item{\code{Bifunctor} } is the same as \code{Functor}, but takes types of kind $* \rightarrow * \rightarrow *$ into account.
	\item{\code{And} } is used to chain several contracts together: all of them are asserted when a value is provided. 
\end{description}

Now that we know how a \code{Contract} can be constructed, let us look at a few examples. 
The very first example is the one we used when first introducing the concept of contracts, namely a contract that constrains a function such that it demands a natural number as its input, and the guarantee that it will return a natural number, too:

\begin{lstlisting}[mathescape]
natInNatOut :: Contract (Int $\rightarrowtail$ Int)
natInNatOut = nat $\rightarrowtail$ nat
\end{lstlisting}

We need a way to attach this contract to such a function, which is what the \code{assert} function is for:

\begin{lstlisting}[mathescape]
increase :: Int $\rightarrowtail$ Int
increase = assert "increase" natInNatOut (fun ($\lambda$n $\rightarrow$ 1 + n))
\end{lstlisting}

Note how the type of \code{increase} does not reflect the natural number constraints imposed by the contract, because the contract is asserted at runtime.

The \code{fun} function lifts a function to a contracted one, one argument at a time:

\begin{lstlisting}[mathescape]
fun :: (a $\rightarrow$ b) $\rightarrow$ (a $\rightarrowtail$ b)
\end{lstlisting}

Conversely, the \code{app} function lifts function application to contracts:

\begin{lstlisting}[mathescape]
app :: (a $\rightarrowtail$ b) $\rightarrow$ Int $\rightarrow$ a $\rightarrow$ b
\end{lstlisting}

By applying these functions accordingly, the contracted version of a function can replace its regular version without issue.
In this way, the contract mechanism acts as a partial identity function, because it either raises an exception during contract violation, or it returns the asserted value unmodified.
This behaviour is clearly reflected in the type of \code{assert}:

\begin{lstlisting}[mathescape]
assert :: String $\rightarrow$ Contract a $\rightarrow$ (a $\rightarrow$ a)
\end{lstlisting}

To clearly illustrate how \code{assert} works, we leave out the first \code{String} argument, which is used in feedback. We also omit some code pertaining to location information, also used for feedback purposes.

\begin{lstlisting}[mathescape]
assert (Prop p)         a   = if p a then a else error "contract failed"

assert (Function c$_1$ c$_2$) f	    = ($\lambda$x $\rightarrow$ (assert (c$_2$ x) . f) x) . assert c$_1$

assert (Pair c$_1$ c$_2$) (a$_1$,a$_2$)     = ($\lambda$a$'_1 \rightarrow$(a$'_1$,assert (c$_2$ a$'_1$) a$_2$)) (assert c$_1$ a$_1$)

assert (List c)         as  = map (assert c) as

assert (Functor f)      as  = fmap (assert f) as

assert (Bifunctor c$_1$ c$_2$) as   = bimap (assert c$_1$) (assert c$_2$s) as

assert (And c$_1$ c$_2$)        a   = (assert c$_2$ . assert c$_1$) a
\end{lstlisting}

Let's go over each pattern match to understand what happens:

\begin{description}
	\item{\code{Prop} :} When asserting a property, we apply the predicate to the supplied value. If the predicate holds, this function acts as the identity function. If it does not hold, however, an exception is raised. In the unabridged code, the exception message also includes the position of the violation in the source code.
	\item{\code{Function} :} For a \code{Function} contract, we first assert $c_1$ on the input of the function $f$. If this assertion holds, we pass the value $x$ to $f$, as can be seen in the lambda function. The result of $f x$ is then used to assert the codomain of the function using $c_2$.
	\item{\code{Pair} :} Similarly, the \code{Pair} contract first asserts the contract $c_1$ to the first element in the pair. Provided it succeeds, the first element is passed to $c_2$. The resulting contract $(c_2$ $a'_1)$ is then used to assert the second element of the pair.
	\item{\code{List}, \code{Functor}, \code{Bifunctor} :} These are all quite similar. The contract to be asserted is mapped over the elements of a container.
	\item{\code{And} :} This contract is used to combine two contracts, so asserting one implies that both contracts hold on the provided value.
\end{description}

Now that we know how contracts are constructed and asserted, let us look at some convenience functions that will be used throughout this thesis:

\begin{lstlisting}[mathescape]
c$_1$ $\rightarrowtail$ c$_2$		= Function c$_1$ (const c$_2$)
(&)		= And
c$_1$ $\functor$ c$_2$		= c$_1$ & Functor c$_2$
c$_1$ $\bifunctor$ (c$_2$,c$_2$)	= c$_1$ & Bifunctor c$_2$ c$_3$
\end{lstlisting}

The first definition allows us to define a non-dependent function contract, and the second is some simple syntactical sugar.
The last two definitions merit some more detail.
Along with (a) contract(s) for the elements of a container, a contract for the container in its entirety is provided as well in the form of $c_1$.
A simple example why this is useful, is the guarantee that a list is sorted when it is returned by a sorting function.
Such a property cannot be captured by any contract for a container's elements, as these elements only know about themselves and not about other elements in the container.
Therefore, we require container-wide contracts, which are also called "outer contracts".
Conversely, contracts for a container's elements are referred to as "inner contracts".

With these functions, we can easily describe complex contracts.
Let us look at an example.
First, we define two fundamental contracts, namely \code{true} and \code{false}, which always succeed and always fail, respectively, regardless of their input:

\begin{lstlisting}[mathescape]
true, false :: Contract a
true  = Prop ($\lambda$_ $\rightarrow$ True)
false = Prop ($\lambda$_ $\rightarrow$ False)
\end{lstlisting}

Let us construct a few contracts for the \code{head} function that will not raise an exception.
The very first contract is simply the \code{true} contract itself, which will take the entire \code{head} function as an argument.
But the contract could be made more specific:

\begin{lstlisting}[mathescape]
true $\rightarrowtail$ true :: Contract ([a] $\rightarrowtail$ a)
\end{lstlisting}

In this case, the \code{true} contract is asserted on both the input and output of the \code{head} function, but no longer on the function in its entirety.
We can make it even more specific:

\begin{lstlisting}[mathescape]
(true $\functor$ true) $\rightarrowtail$ true :: Contract ([a] $\rightarrowtail$ a)
\end{lstlisting}

Using the functor contract $\functor$, the \code{true} contract is asserted on the input list in its entirety, as well as each of its elements, along with the output of the function.

Up until now, we've only used the \code{true} contract.
But we can also use contract variables to express relations between the input and output of a function. 
A further refinement of the contract for \code{head} exemplifies this:

\begin{lstlisting}[mathescape]
(c$_{outer}$ $\functor$ c$_{inner}$) $\rightarrowtail$ c$_{inner}$ :: Contract ([a] $\rightarrowtail$ a)
\end{lstlisting}

It makes sense that the element that is extracted from the list still obeys the contract $c_{inner}$.
With this knowledge, let us look at a higher-order example: \code{fmap}.
By using the functor contract again, we can define a contract for \code{fmap}:

\begin{lstlisting}[mathescape]
(c$_1$ $\rightarrowtail$ c$_2$) $\rightarrowtail$ (c$_3$ $\functor$ c$_1$) $\rightarrowtail$ (c$_4$ $\functor$ c$_2$)
\end{lstlisting}

Note how the contract variables of the contract are very similar to the type variables of the type of \code{fmap}:

\begin{lstlisting}[mathescape]
fmap :: (a $\rightarrow$ b) $\rightarrow$ f a $\rightarrow$ f b
\end{lstlisting}

The contract variables $c_1$ and $c_2$ correspond to type variables $a$ and $b$, respectively.
Generally, we cannot perform such a mapping over containers, so they are assigned different contract variables: $c_3$ and $c_4$.
During a process called inference, it may turn out that these variables are equal, but this information is usually not deducible from the function's type.

Section \ref{background-inference} explains the concept of inference and its use in refining contracts even further.

At the moment, we have learned how contracts are composed and how they can be attached to functions that are lifted using the \code{fun} function.
We have also briefly encountered the \code{app} function, which lifts function application to contracts.
Apart from applying something to a contracted function, this function provides crucial information for use in feedback:

\begin{lstlisting}[mathescape]
app :: (a $\rightarrowtail$ b) $\rightarrow$ Int $\rightarrow$ a $\rightarrow$ b
app f loc x = apply f (makeloc (App loc)) x
\end{lstlisting}

In order to be able to precisely blame the expression that caused a violation, \code{app} expects an integer to be used as a location label in the feedback.

Here is an example of a contract violation:

\begin{lstlisting}[mathescape]
> app increase 1 (-5)
> *** Exception: contract failed: the expression labelled `1' is to blame.
\end{lstlisting}

Because $(-5)$ is not a natural number, it is the reason for the contract violation, and is blamed accordingly using the location label.
In this thesis, we enrich this feedback by including position information and displaying the value responsible for the contract violation.

For brevity, we do not expand upon the inner workings of the blaming system.
Details can be found in Hinze et al's paper \cite{Hinze06typedcontracts}.

\section{Contract inference}
\label{background-inference}

In computer science, the notion of \textit{inference} most often refers to the method of \textit{type inference}, which automatically deduces types for expressions written in a programming language.

For functional programs, the Hindley-Milner type inference system described by Damas and Milner \cite{Damas:1982ve} is the most well-known.
The thesis of Stutterheim \cite{Stutterheim:2013:thesis} builds upon this system, producing an algorithm for deducing \textit{contracts} from expressions written in a simple let-polymorphic lambda calculus.

\subsection{Goals of contract inference}
Stutterheim set out three goals for his contract inference system, shown in figure \ref{fig:goals-stutterheim-contract-inference}.

\begin{figure}[htps]
\begin{framed}
\begin{center}
\begin{itemize}
	\item Infer a well-typed contract for every function in a program
	\item Inferred contracts must allow a (non-strict) subset of the values allowed
by the types
	\item The most general inferred contract must never fail an assertion
\end{itemize}
\end{center}
\end{framed}
\attrib{{\em{Contract inference for Functional Programs}}, page 12}
\caption{\label{fig:goals-stutterheim-contract-inference}Stutterheim's goals for contract inference.}
\end{figure}

The first goal describes the notion of a \textit{fully contracted} expression: every function application is provided with a contract that can be used to assert it.
The second goal is sensible: any values constrained by the contract of an expression should be a subset of the inhabitants of the type of that expression.
Lastly, the third goal implies that asserting any inferred contract is equal to the identity function.
In other words, inferred contracts should never cause a contract violation.

\subsection{Language used}

The contract inference algorithm works on $\lambda_c$, a let-polymorphic lambda calculus shown in figure \ref{stutterheim-lambda-language}.

\begin{figure}[htps]
\begin{lstlisting}[mathescape]
$expr$      ::=   x				-- Variable
        |   $\lambda$$expr$ $\rightarrow$ $expr$				-- Lambda abstraction
        |   $expr$ $expr$				-- Application
        |   let $expr$ = $expr$ in $expr$			-- Let binding
        |   case $expr$ of			-- Case block
              { $expr$ $\rightarrow$ $expr$ (; $expr$ $\rightarrow$ $expr$)* }
        |   $const$				-- Constants
        |   $expr$ : $expr$				-- List cons constructor
        |   []				-- List nil constructor
        |   Just $expr$			-- Maybe Just constructor
        |   Nothing			-- Maybe Nothing constructor
        |   ($expr$, $expr$)			-- Pair
        |   Left $expr$			-- Either left constructor
        |   Right $expr$			-- Either right constructor
        |   $expr$ $\oplus$ $expr$				-- Binary operation
        |   ?				-- Holes


$const$      ::=   n				-- Integers
        |   b				-- Booleans
        |   c				-- Characters
        |   s				-- Strings
\end{lstlisting}
\caption{\label{stutterheim-lambda-language}The $\lambda_c$ language.}
\end{figure}

\subsection{Contract grammar}

Contracts are generated in an intermediate language-agnostic grammar (figure \ref{fig:stutterheim-intermediate-contract-grammar}), which can be translated to library-specific contracts.

\begin{figure}[htps]
\begin{center}
\begin{lstlisting}[mathescape]
  -- Contracts
  c ::=  $\rho_{\alpha}$			-- User-defined concrete contract
      |  $true_{\alpha}$			-- true contract
      |  $false_{\alpha}$			-- false contract
      |  $c_{\alpha} \rightarrowtail c_{\beta}$			-- Function contracts
      |  $c_{\alpha} \functor c_{\beta}$			-- Functor contracts
      |  $c_{\alpha} \bifunctor (c_{\beta}, c_{\gamma})$			-- Bifunctor contracts
      |  $int_{\alpha}$			-- Succeeds for all integers
      |  $bool_{\alpha}$			-- Succeeds for all booleans
      |  $char_{\alpha}$			-- Succeeds for all characters
      |  $string_{\alpha}$			-- Succeeds for all strings
      |  $list_{\alpha}$			-- Succeeds for all lists
      |  $either_{\alpha}$			-- Succeeds for all $Either$s
      |  $maybe_{\alpha}$			-- Succeeds for all $Maybe$s
      |  $pair_{\alpha}$			-- Succeeds for all pairs
  -- Contract schemes
  $\sigma$ ::=  $c$			-- Contract
      |    $\forall{true_{\alpha}}.\sigma$			-- Universal quantification for contract 
				-- indices
\end{lstlisting}
\end{center}
\caption{\label{fig:stutterheim-intermediate-contract-grammar}Intermediate grammar for the contracts.}
\end{figure}

We have already seen some examples of user-defined contracts as well as the definitions of the \code{true} and \code{false} contracts in the \textit{typed-contracts} library.
But in this grammar, the contracts $true$, $false$ and $\rho$ also have an index $\alpha$ that is used to differentiate between different instances of the same type of contract.
This index serves the same purpose as fresh type variables in Algorithm \W.
\textit{"Generating a fresh contract"} is a commonly used phrase in this thesis that refers to a fresh indexed $true$ contract.

The syntax of the function arrow ($\rightarrowtail$), functor ($\functor$) and bifunctor ($\bifunctor$) is the same as that of its inspiration, the \textit{typed-contracts} library syntax.

Furthermore, terminals for literals and several container data types are available as default contracts for the corresponding types.

Contract schemes are used to universally quantify over $true$ contracts.

\subsection{Contract relations and refinement}

Before the algorithm itself is described, Stutterheim defines relations between contracts by "regarding contracts as sets of Haskell values" and using set-theoretic operations on these sets.
He uses these relations to formally define the notion of \textit{contract refinement}, where a contract that constrains a set of values is replaced by another contract that constrains a subset of those values.
This concept is what drives the contract inference algorithm.

\subsection{Algorithm \CW}
The algorithm itself is very much alike Algorithm \W:

\begin{itemize}
	\item A contract environment $\Gamma$ is defined that maps variables to contracts.
	\item Use of generalization and instantiation to introduce and remove universally quantified $true$ contracts, respectively.
	\item A modified version of Robinson's unification algorithm that checks for free \textit{contracts} during the occurs check. It also ensures that substitutions always refine the contract.
\end{itemize}

Stutterheim proves that the algorithm is sound with respect to the contracting rules in his thesis.
For brevity, we do not replicate the proofs, contracting rules, unification rules nor code for Algorithm \CW ~here.
These elements can be found in subsection 3.4 of Stutterheim's thesis \cite{Stutterheim:2013:thesis}.

%Can we refine the contract even more without risking raising an exception?
%It appears we cannot: we have reached a fixed point for a contract that will never raise an exception, regardless of the values it is provided.
%
%In section 3.3 of his thesis, Stutterheim defines relations between contracts by "regarding contracts as sets of Haskell values" and using set-theoretic operations on these sets.
%With these relations, he is able to define the notion of a \textit{most specific} contract:
%
%\begin{quotation}
%"..the inferred contract is also the most specific contract. I.e., the semantics of the inferred contract is a subset of any other contract that can be described in the contract system. (..) Intuitively, this seems true, because \textit{(contract inference algorithm)} \CW ~will infer contracts specific to certain types."
%\end{quotation}
%
%The contract in figure \ref{fig:head-contract-fixed-point} is close to being a \textit{most specific} contract.
%The only difference between our contract and the most specific contract, is that latter has been passed through Stutterheim's contract inference algorithm.
%
%Comparing this contract with the type of \code{head} shows that they are very similar:
%
%\begin{figure}[htbp]
%\begin{lstlisting}[mathescape]
%head_ctrt :: Contract ([aT] $\rightarrowtail$ aT)
%head_ctrt = (true $\functor$ true) $\rightarrowtail$ true
%
%head :: [a] $\rightarrow$ a
%\end{lstlisting}
%\caption{\label{fig:resemblance-contract-type}A strong resemblance between contracts and types.}
%\end{figure}
%
%This is not a random occurence: in Conjecture 1 of Stutterheim's thesis, he speculates that, 
%
%
%
%The example we have just viewed showed us how we can increase the specificity of a contract, starting from the \code{true} contract and working towards a very specific contract from there.
%This is how Stutterheim's contract inference system operates.
%In this thesis, we will exploit the resemblance shown in figure \ref{resemblance-contract-type} to simplify contract inference by providing the inference algorithm with the generalized version of the most specific contract for a given expression.
%A generalized contract is one that purely uses 
%
% relation the fact that we can generate a most specific contract from a type
%
%In fact, it is possible to generate a most specific generic contract from the type of the expression.

%\section{Ask-Elle programming tutor}
%We have seen how contracts can be used to pinpoint specific locations in a section of code in the event of a contract violation.
%We have also witnessed how contracts can be automatically inferred from a section of code using Stutterheim's Algorithm \CW.
%These inferred contracts can be used to generate a fully contracted version of the original section of code.
%
%Stutterheim aimed to combine the QuickCheck properties available in the Ask-Elle programming tutor with the contract inference algorithm to generate contracted code that, in the event of a contract violation due to a counter-example generated by QuickCheck, would pinpoint exactly where the issue lies in a student's code.
%This functionality was to be integrated into the Ask-Elle programming tutor, but remained future work.
%
%Because this thesis builds upon Stutterheim's work, the syntax used by Ask-Elle is the language that we construct a contract inference algorithm for.

\section{Related work concerning contracts}
\label{section:relatedworkcontracts}
The concept of contracts dates back to the Eiffel programming language \cite{Meyer:1988wp} in 1988, which included it as a language feature.
Many other languages support contracts, or have libraries available to achieve the same functionality.

In a functional setting, contracts are less popular, but there has been a lot of research in this field.
Initial steps were taken by Findler and Felleisen \cite{Findler:2002:CHF:583852.581484}, who defined a typed lambda calculus with support for contracts for higher-order functions in the Scheme language.
For Haskell, Hinze et al. \cite{Hinze06typedcontracts} developed a dynamic contract library that builds upon Findler and Felleisen's findings. 
A static approach was taken by Xu et al. \cite{Xu:2006ul, Xu:2009:SCC:1594834.1480889}, allowing contracts to be checked using symbolic computation at compile-time. This technique is similar to that of refinement types, which we will cover in a later paragraph.

Degen et al. \cite{DegenThiemannWehr2009} provide an overview of contract implementation in lazy languages and their pitfalls, demonstrating how each form of dynamic contract monitoring (eager, semi-eager and lazy) is inherently flawed, either changing program behavior or ignoring contract violations.
The article also touches upon Xu's work on static contract systems, which the authors argue is similar to the eager monitoring style they discuss in their article.
Eager contract monitoring is preferred by the authors as all contracts defined in it are faithful: they will always evaluate to their actual value, which implies that, if a program terminates, all of the contracts within it will have evaluated to true.

Other researchers have explored enriching the type system to replace the functionality offered by contracts, producing what is commonly called "refinement types".
Rondon et al. \cite{rondon2008liquid} have developed a set of data types called Logically Qualified Data Types, often shortened to Liquid Types.
Using liquid types, they are able to embed a decidable subset of dependent typing functionality in a Hindley-Milner typing system.
With only the HM types and a predefined set of logical qualifiers, their algorithm is able to infer liquid types, which are dependent types that consist of conjunctions of the aforementioned logical qualifiers.
After inferring these liquid types, they can be resolved using an SMT solver.
In the end, one ends up with the strongest constraint possible on the expression that can be generated with the provided set of logical qualifiers.
Implementations of liquid typing are available for OCaml \cite{rondon2008liquid} and Haskell (using GHC) \cite{rondon2013refinement}.
The Haskell implementation is able to provide feedback if type checking fails, indicating the position(s) in the source code where things have gone wrong.
Additionally, a HTML file is generated of the processed source code annotated with the inferred types.

A similar approach was taken by Vytiniotis et al. \cite{Vytiniotis:2013ww}, whose framework converts contracts written in Haskell into a simpler lambda calculus, which itself is translated into first-order logic formulae.
Finally, these formulae are solved using an off-the-shelf theorem solver.

Terauchi \cite{terauchi2010dependent} also builds upon the recent developments in refinement types to present a system that is able to infer dependent types for a subset of the OCaml language without external input.
Instead of taking a user-provided set of formulas, the algorithm uses counterexample guided abstraction refinement (CEGAR) to iteratively refine a lattice of candidate dependent types.
Counterexamples are parts of the program that are untypable with the current lattice of candidate types.
The algorithm then attempts to type the program with all available types instead of the lattice.
If typing succeeds, the new candidates are added to the lattice and a new counterexample is selected.
If it fails, then the program is untypable.
As the algorithm itself generates the set of candidates, users can be sure that if the program is untypable, it really is untypable.
On the other hand, because the types are inferred automatically, they are not necessarily the strongest types available.

Ranjit et al. \cite{jhala2010refinement} take another route to attain refinement types: they first attain refinement type constraints using the implementation of Rondon et al. \cite{rondon2008liquid}, and then translate these types to a first-order imperative program.
If and only if the assertions of this imperative program hold, the higher-order program typechecks.
This verification can be done using several abstract interpretation techniques (of which CEGAR is one), which have readily available implementations for imperative languages.
The proof of safety of the imperative program translates to the solutions of the refinement type constraints.
Thus, these can be used to annotate the original higher-order program, obtaining the refinement types.

Cousot et al. \cite{cousotabstract} have implemented automatic contract inference for method extraction, a common refactoring technique.
The inferred contract satisfies four requirements: (i) it is valid for the extracted method; (ii) the contract takes into account language and programmer assertions; (iii) the contract of the refactored code is as precise as the non-refactored code, and (iv) the contract is as general as possible.
The authors use an iterative approximation algorithm to attain contracts that fulfill these requirements, and prove that an exact solution is uncomputable.

The articles of Dimoulas \& Felleisen \cite{Dimoulas:2011:CSH:2039346.2039348} and Greenberg et al. \cite{Greenberg:2010:CMM:1707801.1706341} provide an excellent overview of recent developments pertaining to contracts, as well as as detailed comparisons between the different libraries and frameworks. \cite{Dimoulas:2011:CSH:2039346.2039348} also goes into greater detail of the semantics of contract satisfaction.

Another form of type enrichment that enforces constraints is dimensional typing.
In short, a (usually numerical) value is given a dimension (time, length, mass, etc.).
Either through static analysis and inference or through type-level programming, these constraints can be enforced, ensuring that nonsensical operations, such as adding a time value and a mass value, are caught at compile-time.
Kennedy's thesis \cite{langanddim} explores this domain extensively for the ML language. 
A number of dimensional typing libraries are available for Haskell, most of which are defined using type-level programming or using type families.
Some simply constrain the input and output of functions, while others perform automatic conversion between compatible types, for example between meters and inches.

\chapter{Overview}
\label{chapter-overview}

The contract inference system devised by Stutterheim is a solid base upon which we can build to support a language such as Helium:

\begin{itemize}
	\item The grammar to describe a contract is library-agnostic. It borrows several elements from the \textit{typed-contracts} library by Hinze et al. \cite{Hinze06typedcontracts}, which it uses as the example library to describe its code generation procedure.
	\item Using simple set-theoretic operations, Stutterheim defines relations between contracts, which he uses to prove how a contract can be more general than another.
	\item The language used, $\lambda_c$, is a simple let-polymorphic lambda calculus.
	\item His contract inference algorithm \CW ~is based upon Milner's Algorithm \W ~and uses Robinson's unification algorithm, two well-understood algorithms.
\end{itemize}

There are a few limitations in Stutterheim's system that we address:

\begin{itemize}
	\item A system for code generation is left implicit in Stutterheim's thesis. Feedback towards a user is also not discussed.
	\item Substitutions generated by algorithm \CW ~are in placed in a global set. Conflicting substitutions may result in generating an inferred contract that causes a violation during assertion.
\end{itemize}

The following limitations are \textit{not} addressed by us:

\begin{itemize}
	\item Inability of Algorithm \CW ~to handle dependent contracts.
	\item Lack of constant expression contracts.
	\item Integration with the Ask-Elle programming tutor.
\end{itemize}

We improve upon Stutterheim's system in the following ways:
\begin{itemize}
	\item The language we use is a slightly simplified version of the Helium language, a dialect of Haskell that is a subset of the Haskell 98 language specification.
	\item Using type information, we perform abstract syntax tree (AST) transformations to simplify the contract inference algorithm.
	\item With the same information, we generate \textit{initial contracts} that simplify contract inference even further, especially in the case of mutually recursive functions.
	\item Algorithm \CW ~is extended to support the aforementioned Helium dialect, producing Algorithm \CHW.
	\item Substitutions are divided into two lists: global and local. This avoids the problem of contract violations by inferred contracts inherent to the original system.
	\item We provide a system to generate code for the \textit{typed-contracts} library and identify several library-agnostic techniques to enrich feedback.
\end{itemize}

Furthermore, we modify the \textit{typed-contracts} library to allow for a richer form of feedback.

\chapter{System design}
\label{chapter-system-design}

In this chapter, we explain the improvements we have made to Stutterheim's system in detail.
The chapter follows a similar structure to the path code is put through as illustrated in section \ref{section:overview}.

Before providing an overview of the system, we introduce the syntax for our abstract syntax tree (AST), which is a slightly modified version of the syntax the Ask-Elle programming tutor uses.
After the overview, we follow the flow of the abstract syntax tree as it goes through the entire system, starting with several AST transformations, after which we enter the code generation system, which consists of contract generation and -inference, and code generation.
As we encounter each subsystem, we explain key concepts and definitions.

\section{Syntax}
The Ask-Elle programming tutor uses its own version of the Helium syntax, casting aside some things such as type signatures and other syntax constructs that are irrelevant to Ask-Elle.
Helium itself is a subset of the Haskell 98 language specification, its main missing component being user-definable type classes.

We have slightly modified the syntax used by the Ask-Elle system:
\begin{itemize}
	\item Fields to store range information were added to nearly all nodes. Range information consists of the line and column number of the node and its source (standard input, file, unknown) if this information is available.
	\item In Ask-Elle, constructors that use a list of patterns or expressions use the \code{Pats} and \code{Exprs} type synonyms, respectively. For example, expressions that describe a tuple or a list both use \code{Exprs}. However, from the viewpoint of contract inference, these expressions could not be more different! The solution is simple: tuples and lists in patterns and expressions use the type synonyms \code{ListPatsR}, \code{TuplePatsR}, \code{ListExprR} and \code{TupleExprR}. All other constructors remain unchanged.
\end{itemize}

This modified syntax can be downcast to the regular Ask-Elle syntax, and partially upcast to the Helium syntax.

\begin{lstlisting}[caption=Our modified Ask-Elle syntax.]
-- | A Haskell source module
data ModuleR
   | ModuleR
      name     :: MaybeNameR
      body     :: BodyR
      range    :: RangeR

data BodyR
   | BHoleR
      id       :: HoleIDR
      range    :: RangeR
   | BodyR
      decls    :: DeclsR
      range    :: RangeR

-- | Declarations
data DeclR
   | DHoleR
      id       :: HoleIDR
      range    :: RangeR
   | DEmptyR
      range    :: RangeR
   | DFunBindsR
      funbinds :: FunBindsR
      range    :: RangeR
   | DPatBindR
      pat      :: PatR
      rhs      :: RhsR
      range    :: RangeR

type DeclsR = [DeclR]

-- | Expressions
data ExprR
   | HoleR
      id       :: HoleIDR
      range    :: RangeR
   | FeedbackR
      feedback :: String
      expr     :: ExprR
      range    :: RangeR
   | MustUseR
      expr     :: ExprR
      range    :: RangeR
   | CaseR
      expr     :: ExprR
      alts     :: AltsR
      range    :: RangeR
   | ConR
      name     :: NameR
      range    :: RangeR
   | IfR
      cond     :: ExprR
      then     :: ExprR
      else     :: ExprR
      range    :: RangeR
   | InfixAppR
      left     :: MaybeExprR
      op       :: ExprR
      right    :: MaybeExprR
      range    :: RangeR
   | LambdaR
      pats     :: PatsR
      expr     :: ExprR
      range    :: RangeR
   | LetR
      decls    :: DeclsR
      expr     :: ExprR
      range    :: RangeR
   | LitR
      lit      :: LiteralR
      range    :: RangeR
   | AppR
      fun      :: ExprR
      args     :: ExprsR
      range    :: RangeR
   | ParenR
      expr     :: ExprR
      range    :: RangeR
   | TupleR
      exprs    :: TupleExprR
      range    :: RangeR
   | VarR
      name     :: NameR
      range    :: RangeR
   | EnumR
      from     :: ExprR
      then     :: MaybeExprR
      to       :: MaybeExprR
      range    :: RangeR
   | ListR
      exprs    :: ListExprR
      range    :: RangeR
   | NegR
      expr     :: ExprR
      range    :: RangeR

type ExprsR = [ExprR]
type ListExprR = [ExprR]
type TupleExprR = [ExprR]

data MaybeExprR
   | NoExprR
   | JustExprR
      expr     :: ExprR

-- | Alternatives
data AltR
   | AHoleR
      id       :: HoleIDR
      range    :: RangeR
   | AltR
      feedback :: {Maybe String}
      pat      :: PatR
      rhs      :: RhsR
      range    :: RangeR
   | AltEmptyR
      range    :: RangeR

type AltsR = [AltR]

-- | Function bindings
data FunBindR
   | FBHoleR
      id       :: HoleIDR
      range    :: RangeR
   | FunBindR
      feedback :: {Maybe String}
      name     :: NameR
      pats     :: PatsR
      rhs      :: RhsR
      range    :: RangeR

type FunBindsR = [FunBindR]

-- | Guarded expressions
data GuardedExprR
   | GExprR
      guard    :: ExprR
      expr     :: ExprR
      range    :: RangeR

type GuardedExprsR = [GuardedExprR]

-- | Literal values
data LiteralR
   | LCharR
      val      :: Char
      range    :: RangeR
   | LFloatR
      val      :: Float
      range    :: RangeR
   | LIntR
      val      :: Int
      range    :: RangeR
   | LStringR
      val      :: String
      range    :: RangeR

-- | Names
data NameR
   | IdentR
      name     :: String
      range    :: RangeR
   | OperatorR
      name     :: String
      range    :: RangeR
   | SpecialR
      name     :: String
      range    :: RangeR

data MaybeNameR
   | NoNameR
   | JustNameR
      name     :: NameR

-- | Patterns
data PatR
   | PHoleR
      id       :: HoleIDR
      range    :: RangeR
   | PConR
      name     :: NameR
      pats     :: PatsR
      range    :: RangeR
   | PInfixConR
      left     :: PatR
      name     :: NameR
      right    :: PatR
      range    :: RangeR
   | PListR  
      pats     :: ListPatsR
      range    :: RangeR
   | PLitR
      lit      :: LiteralR
      range    :: RangeR
   | PParenR
      pat      :: PatR
      range    :: RangeR
   | PTupleR
      pats     :: TuplePatsR
      range    :: RangeR
   | PVarR
      name     :: NameR
      range    :: RangeR
   | PAsR
      name     :: NameR
      pat      :: PatR
      range    :: RangeR
   | PWildcardR
      range    :: RangeR

type PatsR = [PatR]
type ListPatsR = [PatR]
type TuplePatsR = [PatR]

-- | Right hand side
data RhsR
   | RhsR
      expr     :: ExprR
      where    :: DeclsR
      range    :: RangeR
   | GRhsR
      gexprs   :: GuardedExprsR
      where    :: DeclsR
      range    :: RangeR

data RangeR
    | RangeR
        rangestart                    :: PositionR
        rangestop                     :: PositionR

data PositionR
    | PositionR
        filename                 :: String
        line                     :: Int
        column                   :: Int
    | UnknownR
\end{lstlisting}

\section{Overview}
\label{section:overview}

\includepdf[pages={1}]{systemoverview.pdf}
\includepdf[pages={2}]{systemoverview.pdf}

\section{AST transformations}
Before passing the AST to the rest of the system, we apply several transformations to it to facilitate contract inference and code generation.

\subsection{Capture lambdas}
Anonymous functions cannot be contracted, as a name is required to properly  perform generation of contracted code.
Our solution is simple: bind all lambda functions to a unique identifier and place them in the where-clause of the original definition.
A simple example:

\begin{lstlisting}[mathescape]
f = $\lambda$x $\rightarrow$ x
\end{lstlisting}

is transformed into

\begin{lstlisting}[mathescape,caption=Result of lambda capture transformation.]
f = __lam0                   
 where                    
  __lam0 = $\lambda$x $\rightarrow$ x
\end{lstlisting}

Because of referential transparency, the behaviour of the program is not altered.

\subsection{Rewrite point-free functions}
The library of our choice, \textit{typed-contracts}, does not support asserting partially applied functions.
Because of this, all function arguments are made available on the left-hand side and applied to the right-hand side of a definition.
To continue with our previous example,

\begin{lstlisting}[mathescape]
f = __lam0                   
 where                    
  __lam0 = $\lambda$x $\rightarrow$ x
\end{lstlisting}

is now transformed into

\begin{lstlisting}[mathescape, caption=Result of $\eta$-abstraction transformation.]
f __a0 = (__lam0) __a0                
 where                    
  __lam0 __a0 = ($\lambda$x $\rightarrow$ x) __a0
\end{lstlisting}

This is essentially $\eta$-abstraction.
The information required for this transformation is provided by the type source,  which is described in section \ref{sourceoftypes}.

\subsection{Rewrite infix function applications}
To cut down on duplicate code for both contract inference and code generation, we convert infix function applications to regular function applications.
In other words, we remove a layer of syntactic sugar.

\subsection{Expand function applications}
To keep contract inference simple, we split up function applications that are applied to multiple arguments into several nested function applications.
For example:

\begin{lstlisting}
f g x y z = g x y z
\end{lstlisting}

is transformed into

\begin{lstlisting}[caption=Result of function application expansion transformation.]
f g x y z = ((g x) y) z
\end{lstlisting}

This allows us to use Stutterheim's original contract inference code for function applications.

\subsection{Expand lambda arguments}
The reasons for this transformation are similar as the previous one: keeping contract inference simple and being able to reuse Stutterheim's contract inference code.
A lambda function with multiple arguments is split up into nested lambda functions:

\begin{lstlisting}[mathescape]
f = $\lambda$g x y z $\rightarrow$ g x y z
\end{lstlisting}

is transformed into

\begin{lstlisting}[caption=Result of lambda argument expansion transformation.,mathescape]
f = $\lambda$g $\rightarrow$ ($\lambda$x $\rightarrow$ ($\lambda$y $\rightarrow$ ($\lambda$z $\rightarrow$ g x y z)))
\end{lstlisting}

\section{Source of types and initial contracts}
\label{sourceoftypes}
After these transformations, the AST is passed to the type source and to the code generator.
in this section, we explain the concept and role of a type source in the contract inference algorithm and code generation system.

\subsection{Type source}

%Each node in the tree holds an attribute list of a 3-tuple of information: 
%\begin{itemize}
%\item A textual representation of the piece of code, for debugging purposes.
%\item A Helium AST of the piece of code.
%\item If applicable, the type of the piece of code.
%\end{itemize}

Abstractly, a type source is a data structure that may hold information about the type of a node in an AST.
A node can query the type source to obtain its type if it is available.

Our particular type source consists of a doubly linked tree that resembles the corresponding AST.
This "type tree" is generated by a modified version of the Helium type inference code and is deconstructed to provide the following AST nodes with type information:

%This "type tree" is generated in the \code{ModuleR} node of the AST, and is then passed down to the body of the module.
%
%For the most part, the type tree format is the same as the code AST, the biggest discrepancies being situated in the following nodes:
%
%\begin{description}
%	\item{GRhsR:} The attribute list is of the form:
%\begin{lstlisting}
%[guard,expr,guard,expr,...,wheredecls]
%\end{lstlisting}
%	\item{CaseR:} An alternative has two entries in the attribute list: one for the left-hand side, and one for the right-hand side.
%	\item{EnumR:} The type tree is ambiguous here: both \code{[1..2]} and \code{[1,2..]} return the same type tree. The code AST is inspected to determine what form is used, and the type tree is split up accordingly.
%	\item{FunBindR:} A type is not available for a function binding, so we must synthesize one. This is done by concatenating all the types of any patterns of the function binding and the type of the right-hand side. 
%\end{description}

%Types are available for the following AST nodes:
\begin{itemize}
	\item ExprR
	\item PatR
	\item AltR
	\item FunBindR
	\item RhsR
	\item GuardedExprR
\end{itemize}

\subsection{Initial contract generation}
\label{subsection:contractgeneration}

Using the type information present in the type source, we generate \textit{initial contracts} that prove useful in simplifying contract inference and final contract generation.

\subsubsection{Definition of initial contracts}

By deriving an initial contract from an identifier's type, we obtain a contract with the following properties:

\begin{itemize}
	\item Asserting the contract is equal to the identity function.
	\item It is a \textit{generalized} version of the \textit{most specific} contract for that identifier.
\end{itemize}

Let us discuss the latter property in further detail:
Stutterheim posits a conjecture that any inferred contract in algorithm \CW ~is also the \textit{most specific}, which means that the contract inferred for an expression $e$ is a subset of any other contract that is valid for $e$.

A \textit{generalized} version of such a contract is one where every contract variable present in the contract maps to a $true$ contract and where the relations in an identifier or expression's type are also present in its contract.

For example, here are the generalized most specific contracts for the functions \code{id} and \code{map}:

\begin{lstlisting}[mathescape]
ctrt_id = c$_0$ $\rightarrowtail$ c$_0$
ctrt_map = (c$_1$ $\rightarrowtail$ c$_2$) $\rightarrowtail$ (c$_3$ $\functor$ c$_1$) $\rightarrowtail$ (c$_4$ $\functor$ c$_2$)
\end{lstlisting}

Conversely, these are \textbf{not} the generalized most specific contracts for those functions, as they do not capture the relations present in the types of the functions:

\begin{lstlisting}[mathescape]
ctrt_id = c$_0$ $\rightarrowtail$ c$_1$
ctrt_map = (c$_1$ $\rightarrowtail$ c$_2$) $\rightarrowtail$ (c$_3$ $\functor$ c$_4$) $\rightarrowtail$ (c$_5$ $\functor$ c$_6$)
\end{lstlisting}

\subsubsection{Uses for initial contracts}

There are a few uses for generalized most specific contracts, which we call \textit{initial} contracts:

\begin{itemize}
	\item They simplify contract inference by already incorporating some of the relations that would otherwise be discovered during inference. Particularly, relations between mutually recursive functions are captured as well.
	\item They allow for polymorphic versions of the $\finaltemplate$, $\apptemplate$ and $\ctrttemplate$ templates. 
\end{itemize}

Again, the latter property merits more detail, but to understand it, knowledge about the contract inference and code generation systems is necessary, so we defer the explanation to section \ref{generation-of-final-contracts}.

\subsubsection{Transferring relations between mutually recursive functions}

Mutually recursive functions are troublesome to define in Stutterheim's $\lambda_c$, requiring the contract environment $\Gamma$ to be pre-populated with the contract for the last-defined mutually recursive function to ensure Algorithm \CW ~does not terminate with an error.
In the case that Algorithm \CW ~terminates without error, the relation(s) between the mutually recursive functions is recorded in their contracts.

Because initial contracts are derived from types that record any relation(s) functions may have, the equivalent of pre-populating $\Gamma$, binding group analysis, is no longer necessary.
Binding group analysis is done during type inference to increase polymorphism in those types, an attribute we wish to mirror in our contracts.
By piggybacking upon already-inferred types, we gain both this increased polymorphism and any relations between functions present in the types.

%These initial contracts are of great use for mutually recursive functions.
%Let's look at the initial contracts that are generated for the following example:
%
%\begin{lstlisting}[caption=Simple mutually recursive function example.]
%f x = g x
%g x = f x
%\end{lstlisting}
%
%which generate the following types:
%\begin{description}
%	\item{\code{f} :} \code{v1 >-> v2}
%	\item{\code{g} :} \code{v1 >-> v2}
%\end{description}
%
%From the types, it is obvious that the two functions are very closely intertwined, as they both take the same form of contracted input and the same form of contracted output.

\subsubsection{Initial contract generation algorithm}

%After providing types, a contract environment is constructed that holds the contracts for all identifiers (which consists of function identifiers and pattern identifiers) currently in scope at a certain node of the AST.

An initial contract is generated by passing the type representation (a datatype from the \textit{top} library) to the \code{convertTopTypeToContract} function, which strips down the type to its primitive type and converts it.

The following list shows which pattern match relates to which action:
\begin{description}
	\item{\code{(TVar i)} :} A \code{TVar} contains an integer \code{i} that corresponds to a specific type. That integer is prefixed with the character 'c' to create a fresh contract variable. For example, if \code{a} maps to the integer \code{1}, the type \code{a} is converted to the contract \code{c1}.
	\item{\code{(TApp (TApp (TCon "$\rightarrow$") t1) t2)} :} A function application. \code{t1} and \code{t2} are also converted and put in a non-dependent function contract. For example, given the mapping \code{a $\mapsto$ 1, b $\mapsto$ 2} the type \code{a $\rightarrow$ b} is converted to the contract \code{c1 $\rightarrowtail$ c2}.
	\item{\code{(TApp (TCon x) t1) | x `elem` ["Maybe","[]"]} :} Both the \code{Maybe} type and the list type are converted to a functor contract.
	\item{\code{(TApp (TApp (TCon x) t1) t2) | x `elem` ["Either","(,)"]} :} Both the \code{Either} type and the 2-tuple type are converted to a bifunctor contract.
	\item{\code{(TCon x) | x `elem` ["Int","Char","Float","Bool","String"]} :} Literals of these types are converted to a fresh contract variable that does not collide with those used for the \code{TVar} constructors.
\end{description}

3-tuples and 4-tuples are also supported, but have been left out for brevity.

At the moment, user-defined data types are unsupported.
Implementing support is discussed in section \ref{datatype-support-initial-contracts-algorithm} of the future work chapter.

\section{Contract inference}
Our contract inference system is based upon Stutterheim's work, and it is advised you read his chapters on contract inference if you are interested in the details, which we may omit if they are the same.

Our algorithm is also based on the Damas and Milner type inference system, with a few modifications and simplifications thanks to our use of a type source.

Our goals for contract inference remain the same as Stutterheim's:
\begin{enumerate}
	\item Infer a well-typed contract for each function in a program;
	\item Inferred contracts must allow a (possibly non-strict) subset of the values that the type allows, and
	\item The most general contract inferred by the inference system must never fail during assertion.
\end{enumerate}

Because we use Algorithm \CW ~as a starting point, our algorithm, too, is based on Milner's Algorithm \W, and we make use of Robinson's unification algorithm as well.
The resulting algorithm is called Algorithm \CHW.

\subsection{Formal description of the contract language}
Figure \ref{fig:contract-grammar} describes our contract language, which is a subset of that of Stutterheim's contract language.

While Stutterheim preferred to have specific terminals for data types and literals, we feel this over-encumbers the contract language.
Instead, we replace this multitude of terminals with a single $literal_i$ terminal.

\begin{figure}[htbp]
\begin{center}
\begin{lstlisting}[mathescape]
  -- Contracts
  c ::=  $\rho_{\alpha}$			-- User-defined concrete contract
      |  $c_{\alpha} \rightarrowtail c_{\beta}$			-- Function contracts
      |  $c_{\alpha} \functor c_{\beta}$			-- Functor contracts
      |  $c_{\alpha} \bifunctor (c_{\beta}, c_{\gamma})$			-- Bifunctor contracts
      |  $true_{\alpha}$			-- true contract
      |  $false_{\alpha}$			-- false contract
      |  $literal_{\alpha}$			-- literal contract
\end{lstlisting}
\end{center}
\caption{\label{fig:contract-grammar}Simplified grammar for the contract language.}
\end{figure}

Stutterheim describes several definitions, properties and relations between contracts in his thesis.
These remain valid in our system.

\todo{Most of this was done by Jurrien, although we can leave out some parts.}



\subsection{The contract inference system}
In this section, we introduce a system that allows us to infer a contract from an expression.
This system is based upon Stutterheim's work, and this section will roughly follow the same structure as the corresponding section in his thesis.

In our system, we use a contract environment $\Gamma$ which maps contract variables to contracts.
\todo{Should we just say that we use the same env system as Jurrien?}
A contract environment is defined as such:

\begin{figure}[htbp]
$\Gamma ::= [\!~]\!~||\!~\Gamma_1[x \mapsto c]$
\end{figure}

So, $\Gamma$ can either be completely empty, or consist of an environment $\Gamma_1$ that is extended by a mapping from a contract variable $x$ to a contract $c$.

We use the same notation as Stutterheim for contract environments:
\begin{itemize}
	\item $\Gamma(x)=c$ means that the right-most binding for $x$ in $\Gamma$ maps $x$ to $c$.
	\item $\Gamma \vdash e : c$ denotes that, in environment $\Gamma$, the expression $e$ has the contract $c$.
	\item $fc(\sigma)$ indicates the set of $true$ contracts that are free in contract schema $\sigma$.
	\item $fc(\Gamma)$ indicates the set of $true$ contracts that are free in the codomain of $\Gamma$.
\end{itemize}

The \code{gen} and \code{inst} support functions used by Stutterheim are deprecated by our use of a type source, so we will omit them in our description.
In place of these functions, we define the support function \code{ts}, which takes an identifier $i$ and as many fresh $true$ contracts as necessary to perform a conversion from the type of $i$ to an initial contract $c$ as described in subsection \ref{subsection:contractgeneration}.

\subsubsection{Contracting rules}

We will begin the contracting rules with those for patterns, as many of the rules are similar to those for declarations, right-hand sides, (guarded) expressions and alternatives.

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-PHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PWildcard}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $* :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PCon}}
  \AxiomC{$\Gamma \vdash$ $e_1 :: c_2 \rightarrowtail c$}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c_2$}
  \BinaryInfC{$\Gamma \vdash$ $e_1$ $e_2 :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PVar}\quad}
  \AxiomC{$\forall{i}\in[0\ldots{n}]$ $fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $p :: ts(p,[true_0\ldots{true_n}])$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PAs}\quad}
  \AxiomC{$\forall{i}\in[0\ldots{n}]$ $fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $p@(ps) :: ts(p,[true_0\ldots{true_n}])$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PCons}\quad}
  \AxiomC{$\Gamma \vdash$ $x :: c$}
  \AxiomC{$\Gamma \vdash$ $xs :: list \functor c$}
  \BinaryInfC{$\Gamma \vdash$ $(x : xs) :: list \functor c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PNil}\quad}
  \AxiomC{$fresh(i, j)$}
  \UnaryInfC{$\Gamma \vdash$ $[] :: true_i \functor true_j$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PTuple}\quad}
  \AxiomC{$\forall{i}\in{[0\ldots{n}]} \Gamma \vdash$ $e_i :: c_i$}
  \AxiomC{$fresh(j)$}
  \BinaryInfC{$\Gamma \vdash$ $(e_0, .., e_i) :: true_j \bifunctor (c_1, .., c_i)$}
  \DisplayProof
  \vskip 0.5em
%  \RightLabel{\textsc{C-PTupleNil}\quad}
%  \AxiomC{$\forall{i}\in[0\ldots{n}]$ $\Gamma \vdash$ $t_i :: c_i$}
%  \AxiomC{$\forall{j}\in[0\ldots{n-1}]$ $fresh(j)$}
%  \BinaryInfC{$\Gamma \vdash$ $(t_0, ..., t_i) :: true_0 <@@> (c_0, true_1 <@@> (..., true_j <@@> (c_i-1, c_i) ) )$}
%  \DisplayProof
%  \vskip 0.5em
  \RightLabel{\textsc{C-PLit}}
  \AxiomC{l is a literal}
  \AxiomC{$fresh(i)$}
  \BinaryInfC{$\Gamma \vdash$ $l :: literal_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PParen}\quad}
  \AxiomC{$\Gamma \vdash$ $p :: c$}
  \UnaryInfC{$\Gamma \vdash$ $(p) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PInfixCon}}
  \AxiomC{$\Gamma \vdash$ $e_1 :: c_1$}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c_2$}
  \AxiomC{$\Gamma \vdash \oplus$ $:: c_1 \rightarrowtail c_2 \rightarrowtail c_3$}
  \TrinaryInfC{$\Gamma \vdash e_1 \oplus e_2 :: c_3$}
  \DisplayProof
\end{center}
\caption{\label{fig:pattern-inference-rules}Contracting rules for patterns.}
\end{figure}

Contracts for patterns are collected purely from the type source using the \code{ts} support function, which is used in the \code{C-PVar} and \code{C-PAs} contracting rules.
Let us go over the rules in figure \ref{fig:pattern-inference-rules}, except for \code{PCon}, which is the same as in Damas and Milner's work.

Please note that while our syntax contains a \code{PListR} data constructor, we use the two contracting rules \code{C-PCons} and \code{C-PNil} to describe its contracting behaviour. 
This is how the \code{PListR} constructor works behind the scenes.
We will follow this convention for all constructors that describe lists.

\begin{description}
	\item{\code{C-PHole} and \code{C-PWildcard} :} In both cases, a fresh contract is generated because a more specific contract cannot be provided.
	\item{\code{C-PVar} and \code{C-PAs} :} Because the type source may require a number of fresh contracts between $0$ and $n$, we ensure that we create sufficient fresh contracts. The pattern identifier $p$ is then passed to \code{ts} along with the fresh contracts, which generates the final contract for $p$.
	\item{\code{C-PNil} :} Because we know nothing about the inner or outer contract, we generate fresh $true$ contracts for both.
	\item{\code{C-PCons} :} In this case, we know about the contracts of the tail and head of the list. The inner contract of the list tail must be the same as the contract of the head of the list. The resulting contract is the same as the list tail.
	\item{\code{C-PTuple} :} For a tuple; we know about each contract of the tuple's members. We generate a nested bifunctor contract for tuples larger than 2, nesting in $c_2$ until we have accomodated every member of the tuple. For each bifunctor contract, we require a fresh contract for the outer contract, which means we require $n-1$ fresh contracts, $n$ being the size of the tuple.
	\item{\code{C-PLit} :} A pattern literal is given a fresh $literal$ contract.
	\item{\code{C-PParen} :} Parentheses simply copy the contract of the enclosed pattern.
	\item{\code{C-PInfixCon} :} An infix operator in Helium only supports two arguments, so the contracting rule is a slight variation of regular function application.
\end{description}

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-DHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-DEmpty}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $ :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-DFunBinds}}
  \AxiomC{$\Gamma \vdash$ $d :: c$}
  \UnaryInfC{$\Gamma \vdash$ $(d:ds) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-DPatBind}\quad}
  \AxiomC{$\forall{i}\in[0\ldots{n}]$ $fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $p = rhs :: ts(p,[true_0\ldots{true_n}])$}
  \DisplayProof
\end{center}
\caption{\label{fig:declaration-inference-rules}Contracting rules for declarations.}
\end{figure}

Figure \ref{fig:declaration-inference-rules} shows the contracting rules for declarations. The rules \code{C-DHole} and \code{C-DEmpty} are trivial, but the remaining two warrant a little more explanation:

\begin{description}
	\item{\code{C-DFunBinds} :} In this rule, we select the contract of the very first element of the list of function bindings and use that as the contract of the entire list. This makes sense because function bindings must have the same number of arguments and the same result, meaning that the contract is also the same.
	\item{\code{C-DPatBind} :} A pattern binding will look up its contract in the type source, in the same manner as \code{C-PVar}.
\end{description}

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-FBHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-FunBind}}
  \AxiomC{$\Gamma \vdash$ $ident :: c$}
  \UnaryInfC{$\Gamma \vdash$ $ident$ $ps = rhs :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:funbinds-inference-rules}Contracting rules for function bindings.}
\end{figure}

The contracting rules for function bindings in figure \ref{fig:funbinds-inference-rules} are straightforward: \code{C-FBHole} works as all other holes, and \code{C-FunBind} looks up the identifier in the contract environment and assigns that contract to the entire function binding.

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-Rhs}}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $e$ \textbf{where} $d :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-GRhs}}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $|$ $g = e$ \textbf{where} $d :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:rhs-inference-rules}Contracting rules for right-hand sides.}
\end{figure}

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-GExpr}}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $g$ $|$ $e :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:guardedexpr-inference-rules}Contracting rules for guarded expressions.}
\end{figure}

Right-hand side contracting rules (see figure \ref{fig:rhs-inference-rules}) are equally simple: the contract of $e$ is looked up in the contract environment and is used for the entire right-hand side.
The same is done for guarded expressions (figure \ref{fig:guardedexpr-inference-rules}).

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-Hole}\quad}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Feedback}\quad}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $e :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-MustUse}\quad}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $e :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Case}}
  \AxiomC{$\Gamma \vdash$ $m :: c_1$}
  \AxiomC{$\forall{i}\in[0\ldots{n}] \Gamma \vdash$ $p_i :: c_1$}
  \AxiomC{$\forall{i}\in{[0\ldots{n}]} \Gamma \vdash$ $e_i :: c_2$}
  \TrinaryInfC{$\Gamma \vdash$ \textbf{case} $m$ \textbf{of} \{${p_0 -> e_0; ...; p_n -> e_n}$\} $:: c_2$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Con}\quad}
  \AxiomC{$\Gamma(x) = c$}
  \UnaryInfC{$\Gamma \vdash$ $x :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-If}\quad}
  \AxiomC{$\Gamma \vdash$ $t :: c$}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \BinaryInfC{$\Gamma \vdash$ \textbf{if} $cond$ \textbf{then} $t$ \textbf{else} $e :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Lambda}\quad}
  \AxiomC{$\Gamma[x \mapsto c_1] \vdash$ $e :: c_2$}
  \UnaryInfC{$\Gamma \vdash$ $\ x -> e :: c_1 \rightarrowtail c_2$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Let}\quad}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c$}
  \UnaryInfC{$\Gamma \vdash$ \textbf{let x =} $e_1$ \textbf{in} $e_2 :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Lit}}
  \AxiomC{$l$ is a literal}
  \AxiomC{$fresh(i)$}
  \BinaryInfC{$\Gamma \vdash$ $l :: literal_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-App}\quad}
  \AxiomC{$\Gamma \vdash$ $e_1 :: c_2 \rightarrowtail c$}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c_2$}
  \BinaryInfC{$\Gamma \vdash$ $e_1$ $e_2 :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Paren}\quad}
  \AxiomC{$\Gamma \vdash$ $p :: c$}
  \UnaryInfC{$\Gamma \vdash$ $(p) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Tuple}\quad}
  \AxiomC{$\forall{i}\in{[0\ldots{n}]} \Gamma \vdash$ $e_i :: c_i$}
  \AxiomC{$fresh(j)$}
  \BinaryInfC{$\Gamma \vdash$ $(e_0, .., e_i) :: true_j \bifunctor (c_1, .., c_i)$}  
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Var}\quad}
  \AxiomC{$\Gamma(x) = c$}
  \UnaryInfC{$\Gamma \vdash$ $x :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Enum}\quad}
  \AxiomC{$fresh(i)$ $\Gamma \vdash$ $x :: c$}
  \AxiomC{$\Gamma \vdash$ $y :: c$}
  \AxiomC{$\Gamma \vdash$ $z :: c$}
  \TrinaryInfC{$\Gamma \vdash$ [$x$ .. ($y$) .. ($z$)] $ :: true_i \functor c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Cons}\quad}
  \AxiomC{$\Gamma \vdash$ $x :: c$}
  \AxiomC{$\Gamma \vdash$ $xs :: list \functor c$}
  \BinaryInfC{$\Gamma \vdash$ $(x : xs) :: list \functor c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Nil}\quad}
  \AxiomC{$fresh(i, j)$}
  \UnaryInfC{$\Gamma \vdash$ $[] :: true_i \functor true_j$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Neg}\quad}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $-e :: c$}
  \DisplayProof
  \vskip 0.5em
\end{center}
\caption{\label{fig:expr-inference-rules}Contracting rules for expressions.}
\end{figure}

Figure \ref{fig:expr-inference-rules} details the contracting rules for expressions, which have large overlaps with those for patterns.
Note how there is no rule \code{C-InfixApp}.
This is because infix function applications are converted to regular function applications before contract inference occurs.
As such, there is no need for such a rule.

Rules that are either trivial or similar to those of patterns are: \code{C-Hole}, \code{C-Feedback}, \code{C-MustUse}, \code{C-Lit}, \code{C-App}, \code{C-Paren}, \code{C-Tuple}, \code{C-Cons}, \code{C-Nil} and \code{C-Neg}.
The rest of the contracting rules are discussed hereafter.

\begin{description}
	\item{\code{C-Case} :} This rule describes contracting of a case statement for an arbitrary number of cases. The contract of the expression being evaluated, $m$, must be the same as the contracts of the patterns $p_i$, namely $c_1$. The contract of the entire case statement is $c_2$, which is the contract that is given to each alternative.
	\item{\code{C-If} :} Syntactic sugar for a boolean case statement. Like its generalized version, the contract of the entire statement is the same of each alternative, in this case $c$. 
	\item{\code{C-Lam} :} This contracting rule is the same as in Damas \& Milner's work.
	\item{\code{C-Let} :} A non-generalized let. This is not necessary because every contract variable is polymorphic in the global contract environment. 
	\item{\code{C-Enum} :} A list generator. $y$ and $z$ are fully optional, but if they are present, they must have the same contract as that of $x$, namely $c$. A fresh outer contract is generated to complete the final contract.
\end{description}

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-AHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-AltEmpty}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $ :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Alt}}
  \AxiomC{$\Gamma \vdash$ $rhs :: c$}
  \UnaryInfC{$\Gamma \vdash$ $p$ $\rightarrow$ $rhs :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:alternatives-inference-rules}Contracting rules for alternatives.}
\end{figure}

The contracting rules for alternatives in figure \ref{fig:alternatives-inference-rules} are quite simple. \code{C-AHole} and \code{C-AltEmpty} are trivial, and \code{C-Alt} takes the contract of the right-hand side as the contract of the entire alternative.

\todo{May want to add contracting rules for interesting lists like those for alts.}

\todo{A few simple examples of applying the rules?}

\subsubsection{Substitutions and unification}

We use the same substitutions grammar as that of Stutterheim.
Our unification algorithm, too, is identical to that of Stutterheim, which itself is based upon Robinson's unification algorithm.
We refer you to subsection 3.4.2 of Stutterheim's thesis for a description of the unification algorithm and the substitutions it generates.
When you are done reading, we will note a caveat in his description of the algorithm.

It merits mentioning that although Stutterheim's unification algorithm supports concrete contract refinement in theory, in code this is unsupported.
In fact, the example posed by Stutterheim:

$\mathcal{U}$ $(int,nat)$

results in an error message, as evidenced by the relevant pattern matches of the \code{unifyC} function as shown in figure \ref{figure:unifyCWFails}.

\begin{figure}[htbp]
\begin{lstlisting}[mathescape]
unifyC :: Contract $\rightarrow$ Contract $\rightarrow$ Subst
unifyC c1              c2 | c1 == c2   = SId
unifyC v@CVar{}        c               = unifyCVars v c
unifyC c               v@CVar{}        = unifyCVars v c
...
unifyC c1 c2 = unifyErr "No such unification case when" c1 c2
\end{lstlisting}
\caption{\label{figure:unifyCWFails}A part of the \code{unifyC} function of Algorithm \CW.}
\end{figure}

This is because the $int$ and $nat$ contracts are in fact defined as user-defined concrete contracts in the system's code.
The default contracts that Stutterheim refers to in figure 3.2 of his thesis do not exist in the Haskell data type, which only supports the inhabitants of our simplified grammar as shown in figure \ref{fig:contract-grammar}.
Relations between contracts that allow for refinement are thus non-existent.
While these relations can be mapped out manually, a better idea would be to look towards true refinement types as described in section \ref{section:relatedworkcontracts}.

%\begin{figure}[htbp]
%\begin{center}
%\begin{lstlisting}[mathescape]
%$\theta$  ::=  Id		-- Identity substitution
%    |    $\theta_1 \circ \theta_2$		-- Substitution composition
%    |    [$c_1 \mapsto c_2$]		-- Substitution for $c_1$ with a contract $c_2$
%\end{lstlisting}
%\end{center}
%\caption{\label{fig:subst-grammar} The substitution grammar as defined by Stutterheim.}
%\end{figure}

\subsubsection{Algorithm \CHW}
Now that we have reviewed the contracting rules and the unification algorithm, let us define the contract inference algorithm \CHW.
This algorithm takes a \code{Module} and infers contracts for each declaration, pattern, right-hand side, (guarded) expression and alternative that resides in the module.

Our starting point was Stuterheim's algorithm $\mathcal{CW}$, which has been extensively modified.

To infer a contract, a number of elements are required:
\begin{enumerate}
	\item The contract environment $\Gamma$, which has been populated beforehand with initial contracts from the type source as described in subsection \ref{subsection:contractgeneration}.
	\item The type source $\Xi$, which contains the raw types of the contractable non-terminals. When needed, these raw types will be converted to a unique initial contract. An example of this would be the list constructor, which for obvious reasons must have a unique initial contract every time it is encountered.
\end{enumerate}

\todo{Work in progress.}

\section{Providing richer feedback}

\todo{intro needed?}

\subsection{Modifications to \textit{typed-contracts} library}
\label{modificationstotypedcontracts}
In order to provide adequate feedback to the user, we modify the \textit{typed-contracts} library by Hinze et al. \cite{Hinze06typedcontracts} to produce more specific feedback in a language that the user can understand.
The original library code provides error messages that refer to contract violations and (higher-order) blame of expressions, concepts that are foreign to the average user and thus do not provide any useful feedback.

Here is an example of the feedback provided by the original library:

\begin{lstlisting}[mathescape]
inc :: Int $\rightarrowtail$ Int
inc  = assert "inc" (nat $\rightarrowtail$ nat) (fun ($\lambda$n $\rightarrow$ n + 1))

> app inc 1 (-5)
> *** Exception: contract failed: the expression labelled `1' is to blame.
\end{lstlisting}

\subsubsection{Type position information}

To improve this rudimentary feedback, we require position information that records the position of an argument (or result) in a type.
We record this information in a tuple:

\begin{lstlisting}
type PosInfo = (Int,Int)
\end{lstlisting}

For example, the position $(0,1)$ indicates the first argument of a function that has one argument.
The position $(1,1)$ indicates the result of such a function.

Using this information, it is possible to produce highly specific feedback messages:

\begin{lstlisting}[caption=Code that generates text indicating the location of the problem.]
posInfoText (pos,arity) | pos < arity  = "The " ++ showPos (pos+1) ++ " supplied argument of this function "
                        | pos == arity = "The result of this function "
                        | (pos,arity) == (-1,-1) = "An unknown position "

showPos p | p == 1 = "first"
          | p == 2 = "second"
          | p == 3 = "third"
          | p == 4 = "fourth"
          | p == 5 = "fifth"
          | p == 6 = "sixth"
          | otherwise = show p
\end{lstlisting}

\subsubsection{Using the type position information}

The \code{Contract} GADT is modified to include the \code{PropInfo} constructor, which takes an additional argument: a function that, given type position information of which argument or result that the property is asserting, returns an appropriate error message:

\begin{lstlisting}[mathescape]
PropInfo   ::  (aT $\rightarrow$ Bool) $\rightarrow$ (PosInfo $\rightarrow$ String) $\rightarrow$ Contract aT
Prop       ::  (aT $\rightarrow$ Bool) $\rightarrow$ Contract aT
\end{lstlisting}

Here is a usage example of \code{PropInfo}:

\begin{lstlisting}[mathescape]
isBiggerThan_prop = PropInfo ($\lambda$x $\rightarrow$ fromEnum x > 5 ) ($\lambda$p $\rightarrow$ mkErrorMsg p "the number must be larger than five.")
\end{lstlisting}

If this property were to be asserted on the first argument of a function and was violated, it would generate the following error message:

\begin{quote}
\textit{"The first supplied argument of this function does not fulfill the following property: the number must be larger than five."}
\end{quote}

We add the functions \code{assertPos} and \code{assert''} to the \textit{typed-contracts} library to record this type position information.
For brevity, we omit the definitions of \code{makeLoc} and \code{Def}.
These can be found in the \textit{typed-contracts} library source code.

\begin{lstlisting}[mathescape]
assertPos :: String $\rightarrow$ String $\rightarrow$ Contract a $\rightarrow$ a $\rightarrow$ a
assertPos s ext c = assert$"$ c (0, ctrtarity c) (makeloc (Def (s ++ ext)))
 where
  ctrtarity :: Contract a $\rightarrow$ Int
  ctrtarity (Function c1 c2) = 1 + ctrtarity (c2 undefined)
  ctrtarity _                = 0
\end{lstlisting}

\subsubsection{External feedback}

\code{assertPos}'s purpose is twofold: to initialize the type position information, and to accept an additional feedback string \code{ext}.

Because the \code{app} function is responsible for providing a location label in the form of an integer, it makes sense to define a version of \code{app} that accepts an additional feedback string instead of an integer: \code{appParam}.

\begin{lstlisting}[mathescape]
app :: (a $\rightarrowtail$ b) $\rightarrow$ Int $\rightarrow$ a $\rightarrow$ b
app f loc x = apply f (makeloc (App loc)) x

appParam :: (a $\rightarrowtail$ b) $\rightarrow$ String $\rightarrow$ a $\rightarrow$ b
appParam f s x = apply f (makeloc (Def s)) x
\end{lstlisting}

The use for these extra feedback strings is discussed in the next subsection.

\subsection{External library-agnostic feedback}
\label{codegeneration}

Along with improvements to the \textit{typed-contracts} library, we have identified several techniques for generating library-agnostic feedback through abstract syntax tree analysis and -modification.

\subsubsection{Dynamic representation of values using \code{Show} class}
The most robust way of displaying a value is through use of the \code{Show} typeclass.
The natural caveat one thinks of is the lack of a \code{Show} instance for objects such as functions.
Circular or infinite data structures are also troublesome.

So, when generating code that relies on \code{Show} instances, one must ensure that there are no datatypes without a \code{Show} instance, and that circular or infinite data structures are not present.

In our particular situation, we assume that every argument has a \code{Show} instance. Because QuickCheck should not generate infinite structures (quite the contrary!), this appears to be a reasonable assumption.

\code{Show} instances for functions would still be required, but those can be provided:

\begin{lstlisting}[mathescape]
instance Show (a $\rightarrowtail$ b) where
	showsPrec a = showString "<function>"
\end{lstlisting}

\subsubsection{Static string representation of functions}
In the event of a contract violation inside a higher-order function, it is possible that the offending value is a function.
But providing a meaningful \code{Show} instance for the function type is impossible.
How can this limitation be amended?
One possibility is to generate a static string representation of each argument and use that in the feedback.
For instance, the following example:

\begin{lstlisting}[mathescape]
f g x = g x
z = f id 1
\end{lstlisting}

would become

\begin{lstlisting}[mathescape]
f g x = g (x,"x")
z = f (id,"id") (1,"1")
\end{lstlisting}

However, a string representation loses all notion of the original structure.
In the case of functions, this is not a problem, but structures such as lists suffer.
Let us assume we apply the \code{map} function to an appropriate function and the list \code{[1,2,3]}.
Code is generated that replaces the original argument with the tuple \code{([1,2,3],"[1,2,3]")}.
The \code{map} function then applies its function argument to the first item in the list.
This list item causes a contract violation, but the only visual information available is a string representation of the entire list.
Clearly, this catch-all approach does not work.

By defining a new typeclass \code{ShowFunc}, we can circumvent this issue while still making use of the statically generated string representations:

\begin{lstlisting}[mathescape]
class ShowFunc a where
 showFunc :: String $\rightarrow$ a $\rightarrow$ String
 
instance (Show a) $\Rightarrow$ ShowFunc a where
 showFunc _ a = show a
 
instance ShowFunc (a $\rightarrow$ b) where
 showFunc rep _ = rep
\end{lstlisting}

Unfortunately, user-defined typeclasses are currently unsupported by Helium, so this technique is not applicable to us.

\subsubsection{Identifying a function as higher-order}

By inspecting the type of a function, it is possible to inform the user if the contract violation was caused by a higher-order function or a first-order function.

\subsubsection{Dynamic generation of line and column numbers of an expression}

If the abstract syntax tree provides them, extracting line and column numbers and putting them in the modified AST as a string is trivial and a highly valuable way of improving feedback.

\subsection{Example of detailed feedback for \textit{typed-contracts} library}

While we are unable to say what function caused the contract violation in a higher-order function due to the lack of user-defined typeclasses, we can indicate which arguments of both the higher-order function and the function argument failed.
We use this information to generate highly detailed feedback, as can be seen with this snippet of generated code:

\begin{lstlisting}
g f x = f x
\end{lstlisting}

becomes

\begin{lstlisting}[mathescape]
(fun ($\lambda$f $\rightarrow$ (fun ($\lambda$x $\rightarrow$ g ($\lambda$a $\rightarrow$ (appParam f (concat "the application of the higher-order function 'g' ",(generatePositionData posinfo),". g has a function as its first argument."," The first argument of that function",", namely ",show a]) a)) x))))
\end{lstlisting}

Note how the argument \code{x} is applied to \code{f} with a very detailed feedback message that incorporates the following elements:

\begin{itemize}
	\item Whether the function is higher-order or not.
	\item Run-time generation of line and column number information.
	\item Identification of the position of \code{f} in the type of \code{g}. This is a duplication of the type position information functionality added to the \textit{typed-contracts} library.
	\item Identification of the position of \code{x} in the type of \code{f}.
	\item Run-time representation of the offending value using the \code{Show} typeclass.
\end{itemize}

In the case of a contract violation, the feedback could look like this:

\begin{quote}
\textit{
A part of your code, or a supplied argument to a function, does not fulfill a required property. This occurred at the application of the higher-order function 'g' at line number 1, column number 1. g has a function as its first argument. The first argument of that function, namely -5, does not fulfill the following property: the number must be a natural number.
}
\end{quote}

From this feedback, the user can deduce the following:
\begin{itemize}
\item Which application of a higher-order function caused the contract violation.
\item Which argument of the higher-order function is the function that caused the contract violation.
\item Which argument of that function caused the violation.
\item Possibly, the offending value.
\end{itemize}

\subsection{Reusing QuickCheck properties}

The Ask-Elle programming tutor supports QuickCheck properties that are executed to verify the correctness of code that cannot be reduced to a known strategy.
A very interesting idea is to derive contracts from such properties automatically and use them to construct contracts that can be used to contract the result of the function.
However, remember that we are limited to non-dependent contracts, so we only have access to a single argument or the result of the function in a contract.
Most QuickCheck properties, however, refer to one or more arguments of the function.

A simple QuickCheck property of the palindrome function illustrates the problem well:

\begin{lstlisting}[mathescape]
prop_Main = $\lambda$xs $\rightarrow$ whenFail (putStrLn "This function does not correctly check for palindromes.") ( (palindrome xs) == (reverse xs == xs) )  
\end{lstlisting}

The input \code{xs} must be captured with a dependent contract before it can be referred to.
This means that we are unable to derive a contract useful for contract inference.

The only QuickCheck properties that are of use to derive a contract from, are properties that only refer to the result of the function.
For these kinds of properties, we can construct a contract of the following form:

\begin{lstlisting}[mathescape]
PropInfo ($\lambda$result $\rightarrow$ ...)
\end{lstlisting}

As you can see, we are severely limited in the the range of properties that we can use.
For this reason, we do not develop a contract deriving mechanism for QuickCheck properties and leave it as future work.
\section{Code Generation}
\label{codegeneration}

After the process of contract inference, we possess enough information to fully contract the original code.
For each function definition \code{X}, we generate three new function definitions:

\begin{itemize}
	\item $\underline{\hspace{1.5em}}final\_\code{X}$
	\item $\underline{\hspace{1.5em}}app\_\code{X}$
	\item $\underline{\hspace{1.5em}}contracted\_\code{X}$
\end{itemize}

We will inspect each template in detail and explain its purpose.

\subsection{\finaltemplate}

The $\finaltemplate$ template is simple: it is a transformed copy of the original code.
Every function application found within the original code is replaced by its contracted equivalent, the $\apptemplate$ template.
This transformation makes this template the entry point for all other generated functions.



As an example, here is the filled-in $\finaltemplate$ template for the \code{foldr} function:

\begin{lstlisting}[mathescape]
__final_foldr f b (x:xs) = f x (__app_foldr $ctrt$ $pos$ ($p1$,f) ($p2$,b) ($p3$,xs))
__final_foldr f b [] = b
\end{lstlisting}

%\todo{Why could we not also give the position info of x to f? I think this has to do with the type-level representation then expecting functions that expect tuples. Perhaps modifying the 'final' template to take that into account is an idea, although it's possible the position info is useless there.}

The first thing to note is how the recursive call to \code{foldr} is contracted by replacing the original function application with a call to the $\apptemplate$ template of the \code{foldr} function definition.
From the original code, extra information is generated that is passed to the $\apptemplate$ template. 
The placeholders in the above example represent the following extra information:

\begin{itemize}
	\item $ctrt$: The contract that will be used to assert the original function application. Details of the generation of the contract are found in the next section (\ref{generation-of-final-contracts}).
	\item $pos$: A tuple of the line and column position of the function application. It is is used to generate specific feedback at runtime in case of a contract violation.
	\item $p1...n$: Line and column position information is generated for each argument applied to the original function application, again used for specific feedback.
\end{itemize}

It may puzzle you why the application of \code{f} is not transformed in the same manner.
This is because it is a $pattern$ available in the left-hand side of the function definition.
It is a call to a locally-available function that has already been contracted.

To clarify, let us look at the next example.
The following expression:

\begin{lstlisting}
foldr insert [] [5,4,7,0,10]
\end{lstlisting}

is transformed into the following one:

\begin{lstlisting}[mathescape]
__app_foldr ($p1$,__contracted_insert $ctrt$ $pos$) ($p2$,[]) ($p3$,[5,4,7,0,10])
\end{lstlisting}

Because \code{insert} is a function that does not yet have any arguments applied to it, it is replaced by its $\ctrttemplate$ counterpart.

%\todo{What about partially-applied functions? I think we have to wrap these with lambdas and put in "unknown" positions and then use the app versions, but that would probably not go well with the contract types.}

As you can see, the contracted version of \code{insert} is passed to the contracted version of \code{foldr}.
Hence, the $pattern$ \code{f} in \code{\underline{\hspace{1.5em}}final\_foldr} in our previous example does not have to be transformed.

\subsection{\apptemplate}

This template captures information for use in feedback, wraps it appropriately using \code{appParam}, and passes it to the $\ctrttemplate$ template of the function definition.

Let us examine the template:

\begin{lstlisting}[mathescape]
__app_X ctrt posinfo $argument$ $patterns$ = $applied$ $arguments$
\end{lstlisting}

%The patterns ctrt and posinfo appear here again: both are passed to the \_\_contracted version of the function. Note again that this generated function is polymorphic with respect to its contract.

The placeholders \textit{argument patterns} and \textit{applied arguments} are relatively simple:

\begin{itemize}
	\item \textit{argument patterns} generates a tuple for each argument, containing the position information of the argument and the argument itself.
	\item \textit{applied arguments} uses this extra information to provide richer feedback at runtime and applies the arguments to the $\ctrttemplate$ template of the function.
\end{itemize}

Let us take the following example:

\begin{lstlisting}
g f x = f x
\end{lstlisting}

which generates the following code:

\begin{lstlisting}
__app_g ctrt posinfo (posf,f) (posx,x) =
 appParam (appParam (__contracted_g ctrt posinfo) (show f ++ generatePositionData posf) f) (show x ++ generatePositionData posx) x
\end{lstlisting}

The $\ctrttemplate$ template of the function is fed arguments using \code{appParam}, and are accompanied by feedback strings containing the argument as a string and its position in the source code.


\subsection{\ctrttemplate}

The final template, $\ctrttemplate$, constructs an assertion with the contract provided for a function definition \code{X}.

Let us inspect the template:

\begin{lstlisting}[mathescape]
__contracted_X ctrt posinfo = assertPos $(function$ $info)$ 
 (generatePositionData posinfo) ctrt funs
  where funs = $(contracted$ $function$ $definition)$
\end{lstlisting}

The placeholders represent the following:

\begin{itemize}
	\item \textit{function info}: A string that informs the user which function violated its contract, and if that function is higher-order or not.
	\item \textit{contracted function definition}: Using the \code{fun} function, a function is lifted to a contracted version.
\end{itemize}

The latter placeholder benefits from a few examples.
Here is what the contract version of the identity function looks like:

\begin{lstlisting}[mathescape]
fun ($\lambda$x $\rightarrow$ __final_id x)
\end{lstlisting}

For each argument, an extra layer of the \code{fun} function is applied to capture them and make them available to the original function.

A function argument is slightly more involved, as it must be applied to its arguments using \code{appParam}.
For example,

\begin{lstlisting}
g f x = f x
\end{lstlisting}

generates the following for the \textit{contracted function definition} placeholder:

\begin{lstlisting}[mathescape]
(fun ($\lambda$f $\rightarrow$ (fun ($\lambda$x $\rightarrow$ __final_g ($\lambda$a $\rightarrow$ (appParam f $info$ a)) x))))
\end{lstlisting}

Note how \code{a} is captured and applied to \code{f} using \code{appParam}.
This is because \code{f} is a contracted function that was passed to the higher-order function.

\section{Generation of final contracts}
\label{generation-of-final-contracts}

In this section, we illustrate an important limitation in the substitutions generated by Algorithm \CW ~and propose a solution to this limitation.
This limitation manifests itself when generating code for a library.
We have seen how templates for the \textit{typed-contracts} library are filled out, but it is not yet clear how the intermediate contract language is translated to a \textit{typed-contracts} contract.
Hence, that is what we start with before moving on to the limitation.

\subsection{Translation of intermediate contract language to \textit{typed-contracts} library}

Because the intermediate contract language is inspired by the notation used by the \textit{typed-contracts} library, translation between the two is simple.

The $true_i$ and $false_i$ contracts are translated into the \code{true} and \code{false} functions, respectively.
The index $i$ is only relevant to contract inference, so it is discarded.

The contract arrow ($\rightarrowtail$), functor ($\functor$) and bifunctor ($\bifunctor$) translate directly to the \textit{typed-contracts} library. 

At the moment, $literal_i$ contracts are translated into \code{true} contracts. Stutterheim's thesis suggests constant expression contracts as a better candidate for translation, but notes that extra program analysis is required to safely replace a simple \code{true} contract with a constant expression one.

Finally, user-defined concrete contracts only exist as a string in the intermediate contract language.
Translation is done simply by printing that string when generating the code, as the string is the identifier of a contract defined outside of the generated code.

Now that it is clear how translation works, we explain the limitation in Algorithm \CW  ~and how doing this translation at runtime proves troublesome.


\subsection{The monomorphic Algorithm \CW}

Algorithm \CW ~contains a severe limitation: every generated substitution is placed in a global set.
This set is then used to generate the final contract of an expression $e$ during code generation by applying the substitutions to the inferred contract of $e$.
The limitation presents itself when we apply a function \code{f} to two different arguments with different contracts:

\begin{lstlisting}[caption=An example code snippet that may generate incorrect code when using substitutions from Algorithm \CW.,label=code:incorrectgeneratedcode]
f x = [x]
z = (f 'a', f 5)
\end{lstlisting}

If we leave the contract environment $\Gamma$ empty, both \code{'a'} and \code{5} receive a $true$ contract, say, $true_1$ and $true_2$.
During inference, these contracts are unified and generate a substitution indicating they refer to the same contract.
In the end, the contract of \code{z} is as follows:
\begin{lstlisting}[mathescape]
true$_0$ $\bifunctor$ (true$_3$ $\functor$ true$_1$, true$_4$ $\functor$ true$_2$)
\end{lstlisting}
Because $true$ contracts are translated into the \code{true} \textit{typed-contracts} contract, no runtime or compilation error occurs.

But if we seed $\Gamma$ with an initial contract, the story is entirely different!
The contract of \code{z} is now set to the following:

\begin{lstlisting}[mathescape,label=env:contractz,caption=Contract environment $\Gamma$ is now seeded with a contract for \code{z}.]
$\Gamma$(z) = true$_0$ $\bifunctor$ (true$_1$ $\functor$ isChar, true$_2$ $\functor$ isNum)
\end{lstlisting}

For the rest of the identifiers and literals, the following contracts are constructed by Algorithm \CW:

\begin{lstlisting}[mathescape]
$\Gamma$(x) 	= true$_4$
$\Gamma$(f) 	= (true$_4$ $\rightarrowtail$ (true$_3$ $\functor$ true$_4$)) 
$\Gamma$('a') 	= true$_5$
$\Gamma$(5) 	= true$_6$
\end{lstlisting}

The relevant unifications of \code{f 'a'}, \code{f 5} and \code{z} are as follows:

\begin{lstlisting}[mathescape]
-- Unification of first argument of f with 'a'
unify (true$_4$) (true$_5$)

-- Unification of first argument of f with 5
unify (true$_4$) (true$_6$)
\end{lstlisting}

We obtain the following substitutions:

\begin{itemize}
	\item \code{true$_4$ $\mapsto$ true$_5$}
	\item \code{true$_4$ $\mapsto$ true$_6$}
\end{itemize}

We can apply these substitutions in left-to-right or right-to-left order to the contract of the right-hand side of z, which is 

\code{(true$_7$ $\bifunctor$ true$_3$ $\functor$ true$_4$, true$_3$ $\functor$ true$_4$)}. 
$true_7$ is a fresh contract:

\begin{itemize}
	\item left-to-right: \code{(true$_7$ $\bifunctor$ (true$_3$ $\functor$ true$_5$, true$_3$ $\functor$ true$_5$))}
	\item right-to-left: \code{(true$_7$ $\bifunctor$ (true$_3$ $\functor$ true$_6$, true$_3$ $\functor$ true$_6$))}
\end{itemize}

What happens when we unify either of these with the contract for \code{z}?

\begin{lstlisting}[mathescape]
unify (true$_0$ $\bifunctor$ (true$_1$ $\functor$ isChar, true$_2$ $\functor$ isNum))
      (true$_7$ $\bifunctor$ (true$_3$ $\functor$ true$_5$, true$_3$ $\functor$ true$_6$))
\end{lstlisting}

Relevant substitutions:

\begin{itemize}
	\item \code{true$_5$ $\mapsto$ isChar}
	\item \code{true$_5$ $\mapsto$ isNum}
\end{itemize}
      
\begin{lstlisting}[mathescape]
unify (true$_0$ $\bifunctor$ (true$_1$ $\functor$ isChar, true$_2$ $\functor$ isNum))
      (true$_7$ $\bifunctor$ (true$_3$ $\functor$ true$_6$, true$_3$ $\functor$ true$_6$))
\end{lstlisting}

Relevant substitutions:

\begin{itemize}
	\item \code{true$_6$ $\mapsto$ isChar}
	\item \code{true$_6$ $\mapsto$ isNum}
\end{itemize}

Here, the limitation becomes apparent: regardless of how we apply these substitutions, one of the contracts of expressions \code{f 'a'} and \code{f 5} will always be incorrect!
If we apply the substitutions left-to-right, the expression \code{f 5} is given the contract \code{true$_1$ $\functor$ isChar}. Doing it right-to-left provides \code{f 'a'} with the contract \code{true$_1$ $\functor$ isNum}.

In both instances, either a compile-time or a run-time error occurs.
This breaks Stutterheim's proposition that \textit{"(an) inferred contract will never fail assertion for that expression"} (\cite{Stutterheim:2013:thesis}, proposition 6). 

In this manner, Algorithm CW ~is monomorphic: the inferred contract of a function may constrain the acceptable values of an argument to a static subset of what the argument should actually be able to accept.

\subsubsection{Proposed solution: global and local substitution lists}

Instead of a single, global set of substitutions that is applied to every contract during translation, we keep track of a single global list of substitutions and several local lists.
Contract variables are also given a flavour of global or local.

Whenever unification between two contracts takes place, the resulting substitutions are split up in a global and local group:
\begin{itemize}
\item The global group holds all substitutions that go from global contract variables to global other contract variables.
\item The local group holds all substitutions that go from global contract variables to local contract variables, as well as those that go from local contract variables to other local contract variables.
\end{itemize}

The global group is added to the global substitution list.
The local group is added to the local substitution list, which already contains the parent's local substitution list.
In other words, the global group travels up the AST towards the top, and the local group travels downwards into the child nodes of the node where unification took place.

\subsubsection{Applying global and local substitution lists}

The algorithm for calculating the final contract from these lists is comprised of four steps.
First, look up the initial contract $c_{initial}$ in the contract environment $\Gamma$.

Second, apply the global substitution list $s_{global}$ to $c_{initial}$ until a fixed point is reached or until $n+1$ applications have taken place, where $n$ is the number of substitutions in the global list. 
This yields $c_{global}$.
For those interested, a more detailed description of this application can be found in section \ref{futurework:efficientsubstalgo}.
The reason why the substitutions must be applied up to $n+1$ times is because, in our language, the ordering of function declarations is random, but the order in which the generated substitutions must be applied is not.
Stutterheim's language uses nested let-expressions to introduce multiple function declarations, which means the order of the generated substitutions is always correct, so it did not have to perform this search.

As the third step, the local substitution list $s_{local}$ is updated to reflect the changes in $c_{initial}$ that have been introduced by $s_{global}$.
This is done by applying $s_{global}$ to $s_{local}$ up to $n+1$ times until a fixed point is reached, producing $s_{updated}$.

Finally, $s_{updated}$ is applied to $c_{global}$ in the same manner until a fixed point is reached, resulting in $c_{final}$.


%It is this contract that is translated into a \textit{typed-contracts} contract and placed in the generated code.

%A more abstract solution is this: generate a deterministic finite state machine from $s$ and $v_{orig}$:
%\begin{description}
%	\item{$\sum$} = The unique set of contract variables in $s$.
%	\item{$S$} = The unique set of contract variables in $s$.
%	\item{$s_0$} = $v_{orig}$.
%	\item{$\delta$} = The substitution set $s$.
%	\item{$F$} = All contract variables in $s$ that occur on the right-hand side of a substitution.
%\end{description}
%
%Now, step through the list of substitutions $s$, interpreting $v_a$ $\mapsto$ $v_b$ as follows: if $v_a$ equals the current state we are in, accept $v_b$ as a symbol and transition to state $v_b$.
%When the list is empty, 

At first, it appears logical to apply these substitutions during code generation, and not during runtime, but this is not optimal.
To see why, let us look at the code generated by this example:

\begin{lstlisting}[caption=Expanded version of listing \ref{code:incorrectgeneratedcode}.]
f x = g x
g x = f [x]
z = (f 'a', f 5)
\end{lstlisting}

The example has been expanded to include function \code{g}, which is called by \code{f}.
Our code generation system for the \textit{typed-contracts} library produces the following \finaltemplate ~code for \code{z}, \code{g} and \code{f} (we omit the line and column position information):

\begin{lstlisting}[caption=Output of code generation for the \textit{typed-contracts} library.,mathescape]
__final_f x = __app_g (v1 $\rightarrowtail$ (v2 $\functor$ v1)) x
__final_g x = [x]
__final_z = (__app_f (isChar $\rightarrowtail$ (true $\functor$ isChar)) 'a', __app_f (isNum $\rightarrowtail$ (true $\functor$ isNum)) 5)
\end{lstlisting}

Calling the contracted version of \code{f} will call the contracted version of \code{g}, but with an initial contract!
In other words, the local substitutions that made the contract passed to \code{\_\_app\_f} more specific, are not utilized by \code{\_\_app\_g}.
The solution appears trivial: pass the local substitutions as another argument to the \apptemplate ~and \ctrttemplate ~templates and apply them to the initial contract at runtime.

\subsubsection{Applying substitutions at runtime}

Unfortunately, it is not so simple.
Doing substitutions at runtime instead of statically means a runtime translation is necessary between the intermediate contract language and the \textit{typed-contracts} contract datatype, because the substitutions only work on the intermediate contract language.
The targeted library expects a contract in its own datatype, of course.
The intermediate contract language is modeled as a simple UUAGC-generated datatype without a phantom type, and \textit{typed-contracts}'s datatype is a GADT with a phantom type used for a type-level representation of the contract.
Conversion between the two means we need to be able to tell what this phantom type should be. This is especially a problem when we need to convert between user-defined concrete contracts (\code{Prop} and \code{PropInfo}), because each of these contracts may have a different phantom type and assorted type class constraints, and the only information available in the AST datatype equivalent is a \code{String}.

Several attempts were made to provide a runtime translation function, but none were initially successful.
Due to time constraints, we defer this translation method as future work.
Section \ref{futurework:runtimetranslation} provides an overview of the attempts and promising methods.

The current code generation system generates monomorphic code that may fail when a contracted function is applied to different contracts.

\chapter{Discussion and future work}
\label{futurework}

\section{Adding support for user-defined datatypes to the initial contract generation algorithm}
\label{datatype-support-initial-contracts-algorithm}

\todo{Expand upon what the data type env is, where it comes from, etc.}

However, a data type environment is available and could be queried for the data type's general form and its name, allowing us to construct a pattern match.
Alternatively, one could generate a typeclass instance for each defined data type using Template Haskell or some other form of preprocessing.
Manually adding new data types to the conversion function is another option.

\section{Integration with the Ask-Elle programming tutor}

\todo{Talk about how contract inference is not of use when there is no recursion or function application.}

\todo{Talk about how the QuickCheck properties should be enriched to allow for more useful feedback.}

\todo{Talk about how you'll need to run the code generation system on the Prelude and any other modules you'll use.}

\section{Run-time translation of intermediate contract language}
\label{futurework:runtimetranslation}
\todo{Talk about a few interested avenues for getting this to work.}


Several ideas were tested to complete the conversion, the first of which was to use a typeclass:

\begin{lstlisting}[caption=Attempt at using a typeclass to recover the extra type information.]
class ConvertContract aT where
 convert :: Contract -> (Contract aT)

instance ConvertContract aT where
 convert (CVar s _) = true
 convert (CProp s) = searchEnvTuple s envTuple

instance ConvertContract (aT :-> bT) where
 convert (CArr c1 c2) = (>->) (convert c1) (convert c2)

instance Bifunctor f => ConvertContract (f aT bT) where
 convert (CBifunctor o il ir) = (convert o) <@@> (convert il,convert ir)

instance Functor f => ConvertContract (f aT) where
 convert (CFunctor o i) = (convert o) <@> (convert i)
 
testEnvTuple
  :: (Functor f, Ord dT, Ord bT, RealFrac eT) =>
     ((String, Contract (f cT :-> [dT])),
      ((String, Contract aT),
       ((String, Contract [bT]),
        ((String, Contract Char),
         ((String, Contract eT), ([a], Contract fT))))))
testEnvTuple = ( ("isort",sortCtrt), ( ("ctrue",true), ( ("ord",ord), ( ("isChar_prop",isChar_prop), ( ("isInt_prop", isInt_prop), ([], true) ) ) ) ) )
\end{lstlisting}

Because of the different phantom types, a nested tuple was needed to house the property environment. \todo{Why didn't this work, again? I think the typechecker didn't want to play nice and kept trying to unify these types or something.}

A type annotation would be required for this solution, so the compiler knows which instance to select.
Statically generating such an annotation would have been perfectly feasible, although it would have suffered from the same issue as the one we were trying to solve: 
the annotation for the contracted version of 'g' would have been a generic one.

Another idea would be to add the phantom type to the AST datatype, making conversion trivial.
Unfortunately, an option for adding phantom types in a UUAGC-defined datatype could not be found.
Even if phantom types were supported, the generation code would have had to have been rewritten to use a nested tuple for the environment contract instead of a regular list.

What about using type synonyms and the aforementioned typeclass?

\begin{lstlisting}[caption=Attempt at using type synonyms to choose the correct instances.]
instance ConvertContract aT where
  convert (CVar s _) = true
type IsIntProp aT = aT
instance RealFrac (IsIntProp aT) => ConvertContract (IsIntProp aT) where
  convert (CProp p) | p == "isInt_prop" = isInt_prop
\end{lstlisting}

Unfortunately, when deciding an instance, any constraints are ignored, and because type synonyms are transparent to the compiler, these instances fully overlap.
Simon Peyton-Jones and Oleg Kiselyov (http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap) do describe a way to use overlapping instances and functional dependencies to achieve this, but it requires a lot of extra work for every property.

After type synonyms, newtypes were tried:

\begin{lstlisting}[caption=Attempt at using newtypes to choose the correct instances.]
newtype IsIntProp aT = IsIntProp aT
instance RealFrac (IsIntProp aT) => ConvertContract (IsIntProp aT) where
  convert (CProp p) | p == "isInt_prop" = isInt_prop
\end{lstlisting}

This seemed to work, but it required wrapping and unwrapping of values, which was incompatible with the generated code.
Recall the contracted version of \code{f}:

\begin{lstlisting}
__app_f ctrt x = appParam (__contracted_f ctrt) x
__contracted_f ctrt = assertPos "f" ctrt funs
    where
        funs = (fun (\x -> __final_f x))
__final_f x = __app_g (v1 >-> (v2 <@> v1)) x
\end{lstlisting}

The value \code{x} would have to be unwrapped before it could be passed to \code{\_\_final\_f}, and these unwrapping functions would all have a different name.
A typeclass could be used to provide a singular function to wrap and unwrap newtypes, but user-defined typeclasses are currently unsupported by the Helium compiler.
Apart from that, this seemed to be a promising solution.

A final "solution" that would not require the use of typeclasses, would have been to generate a monomorphic set of contracted functions for every single function application.
Naturally, this set would need to contain every single function that is called when evaluating that particular function application; a possibly daunting amount.
Importing other modules makes this solution even less feasible, as functions from those modules would also need to be included in the set.
Because of the multitude of issues, this solution was disregarded early in the process.

Rolling back to the polymorphic version is, of course, still possible, and is left as future work (see section ~\ref{futurework}).

\section{More efficient algorithm for finding final contracts}
\label{futurework:efficientsubstalgo}



Algorithm:

Given a contract variable $v_{orig}$ and a list of substitutions $s$, set $v_i$ to $v_{orig}$.
While you have not reached the end of $s$, search for a substitution that goes from $v_i$ to $v_j$.
If you encounter such a substitution, set $v_i$ to $v_j$.
When the end of $s$ has been reached, check if $v_{orig} = v_i$.
If yes, return $v_{orig}$ as the result.
Otherwise, recurse with $v_j$ and $s$.


\section{Using paramorphisms to tackle dependent contracts}

\review

Johan Jeuring provided a wonderful idea to be able to run contract inference on some catamorphisms with dependent contracts by converting them to a paramorphism, which is a catamorphism that provides its function argument with the original input as well:

\begin{figure}[htps]
\begin{lstlisting}
para  :: (a -> [a] -> b -> b) -> b -> [a] -> b
foldr :: (a ->        b -> b) -> b -> [a] -> b

para  c n (x : xs) = c x xs (para c n xs)
foldr c n (x : xs) = c x    (foldr c n xs)
para  c n []       = n
foldr c n []       = n
\end{lstlisting}
\texttt{\scriptsize{Source: http://stackoverflow.com/questions/13317242/what-are-paramorphisms}}
\end{figure}

This functionality is of great use for dependent contracts that need access to the original argument, as can be seen in the following example code (courtesy of Johan Jeuring):

\begin{lstlisting}
-- GList      ::  Contract aT -> ([aT] -> Bool) -> Contract [aT]
sortc =  GList int (const True) >-> \xs -> GList int (\r -> nonDesc r && isPerm xs r)
isPerm xs ys = null (xs \\ ys)

sort_perm'         :: Ord a => [a] -> [a]
sort_perm'         =  foldr insert_notPerm []
insert_notPerm ::  Ord a => a -> [a] -> [a]
insert_notPerm x []                    =  [x]
insert_notPerm x (y:ys)  |  x <= y     =  x:y:ys
                         |  otherwise  =  insert_notPerm x ys
                         
sort_permWrong        =  foldr insert_notPerm [] 
sort_permNotViolated  =  assert sortc sort_permWrong [3,2,4]
\end{lstlisting}

In the above example the input, \code{xs}, is needed in the \code{sortc} contract to be able to express the permutation property, but this introduces a dependent contract, which means the contract cannot be used for contract inference.

This is where the paramorphism comes in, as it provides that \code{xs} value.
The contract for the \code{para} function is, then:

\begin{lstlisting}
parac
  :: Contract aT
     -> ([aT] -> Bool)
     -> ([aT] -> Contract bT)
     -> Contract ((aT -> [aT] -> bT -> bT) -> bT -> [aT] -> bT)
parac aT p bT =   (aT >-> \x -> GList aT p >-> \xs -> bT xs >- bT (x:xs))
              >-  bT []
              >-  GList aT p
              >-> \xs -> bT xs
              
psort  =  para (\x xs ys -> insert_correct x ys) []
\end{lstlisting}

Unifying \code{sortc} and \code{parac} gives us:

\begin{lstlisting}
GList aT  p             >->  \xs -> bT xs
GList int (const True)  >->  \xs -> GList int (\r -> nonDesc r && isPerm xs r)

aT  :=  int
p   :=  const True
bT  :=  \xs -> GList int (\r -> nonDesc r && isPerm xs r)
\end{lstlisting}

Applying these substitutions, we see that \code{bT []} will get the contract:  

\begin{lstlisting}
GList int (\r -> nonDesc r && isPerm [] r)
\end{lstlisting}

And the contract for \code{insert} becomes:

\begin{lstlisting}
insertc'  =    int 
          >->  \x  -> GList int (const True) 
          >->  \xs -> GList int (\r -> nonDesc r && isPerm xs r)
          >-   GList int (\r -> nonDesc r && isPerm (x:xs) r)
cinsert_notPerm_violated = assert insertc' (\x xs ys -> insert_notPerm x ys) 3 [2,4] [2,4]
\end{lstlisting}

Note that by using a paramorphism instead of a catamorphism, \code{insert} is supplied with an argument it does not require, so it is wrapped in a lambda function and the superfluous argument is ignored.

How do we relate this contracted paramorphism to the original user's \code{foldr} call?
By defining \code{foldr} as a paramorphism, which is quite simple:

\begin{lstlisting}
pfoldr f e = para (\x xs r -> f x r) e
sort_perm''        =  pfoldr insert_notPerm []
sort_permViolated' =  assert sortc' sort_perm'' [3,2,4]
\end{lstlisting}

In short, this implies it is possible to convert some functions that use catamorphisms with dependent contracts, into paramorphisms with non-dependent contracts.

Some feedback problems do pop up: how do we meaningfully inform the user of a violated contract in  \code{(\textbackslash x xs r -> f x r)} ? 
And what if the \code{para} contract is violated, how do we report that?
It is possible to modify the feedback messages in contract generation to "cloak" the use of a paramorphism, but this has not yet been investigated further.

\chapter{Conclusion}
\label{chapter-conclusion}

\todo{I should expand this a bit.}

The end.

\bibliographystyle{plain}
\bibliography{bibliography}
\end{document}
