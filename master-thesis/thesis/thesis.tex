\documentclass[10pt,a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[numbers]{natbib}
\usepackage{bussproofs}
\usepackage{color}
\usepackage{listings}
\usepackage{ amssymb }
\usepackage{courier}
\usepackage[pdftex]{graphicx}
\lstset{language=Haskell}
\lstset{breaklines=true}
\lstset{basicstyle=\scriptsize\sffamily}
\lstset{frame=single}
\lstset{showstringspaces=false}
\lstset{captionpos=b}
\usepackage{url}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{pdfpages}

\newcommand{\functor}{<\!\!\!@\!\!\!>}
\newcommand{\bifunctor}{<\!\!\!@\!\!@\!\!\!>}

\newcommand{\W}{$\mathcal{W}$}
\newcommand{\CW}{$\mathcal{CW}$}
\newcommand{\CHW}{$\mathcal{CHW}$}

\newcommand{\sref}[1]{Section~\ref{#1}}
\newcommand{\annotate}[3]{
	\begin{scriptsize}
	\textcolor{#1}{\textbf{#2}~\textit{#3}}
	\end{scriptsize}\newline}
\newcommand{\todo}[1]{\annotate{red} {TODO:} {#1}}
\newcommand{\review}{\annotate{blue} {REVIEW:} {Please read the following, and make improvements. \newline}}

\definecolor{light-gray}{gray}{0.95}
\newcommand{\code}[1]{%
  {% open a group for a local setting
   \setlength{\fboxsep}{-2\fboxrule}% the rule will be inside the box boundary
   \fcolorbox{black}{light-gray}{\hspace{1.5pt}\strut\texttt{#1}\hspace{1.5pt}}% print the box, with some padding at the left and right
  }% close the group
}

\author{
	Beerend Lauwers\\
	Utrecht University, The Netherlands}
\date{\today}
\title{Embedding Contract Inferencing for Functional Programs In Ask-Elle}
\begin{document}

\maketitle


\chapter{Abstract}
\todo{Finish up abstract}
Ask-Elle is a programming tutor created by Alex \citet{Gerdes:2012:phd} for his PhD Thesis. It utilizes (transformations of) model solutions to provide feedback to students on their progress.
However, if a student's program cannot be reduced to such a model solution, providing helpful feedback becomes hard to do. 
The Master Thesis of Jurri\"en \citet{Stutterheim:2013:thesis} focuses on the development of a contract inferencing system for functional programs, with the goal to embed this functionality in the Ask-Elle programming tutor, so as to provide a new source of meaningful feedback to students using the tutor.
In the "Future Work" section of the thesis, Stutterheim notes that the actual integration of the contract inferencing system in Ask-Elle still remains to be done.
This research proposal explores what needs to be done in order to attain that goal, as well as the effects it would have upon the tutor's capability to provide meaningful feedback.


%5:58:09 PM] : ][CW][ : Brutos: whats your thesis about?
%[5:58:14 PM] : ][CW][ : Brutos: well i guess about that :D
%[5:58:18 PM] : ][CW][ : Brutos: but more in detail
%[5:58:25 PM] =[BSID]= 1LT Beerdude26: Embedding contract inferencing in the Ask-Elle functional programming tutor
%[5:58:39 PM] =[BSID]= 1LT Beerdude26: You know that everything has a type in Haskell
%[5:58:50 PM] : ][CW][ : Brutos: yes
%[5:59:26 PM] =[BSID]= 1LT Beerdude26: Contracts are a refinement of those (in fact, many researchers go the way of refinement types, but those need solvers and a whole lot of other crap)
%[5:59:38 PM] =[BSID]= 1LT Beerdude26: So like, you have a function that goes from Int -> Int
%[5:59:57 PM] =[BSID]= 1LT Beerdude26: You could define a contract for it that says "Input must be below 0, output must be below 2"
%[6:00:10 PM] =[BSID]= 1LT Beerdude26: Or something like that, stupid example
%[6:00:21 PM] =[BSID]= 1LT Beerdude26: You can use arbitrary functions when defining contracts
%[6:00:30 PM] =[BSID]= 1LT Beerdude26: So it can also be that the input must be prime or something
%[6:00:46 PM] =[BSID]= 1LT Beerdude26: Do you know about type inference?
%[6:01:00 PM] : ][CW][ : Brutos: yes i did even learn one algorithm to do it
%[6:01:04 PM] =[BSID]= 1LT Beerdude26: Algorithm W
%[6:01:06 PM] =[BSID]= 1LT Beerdude26: Probably
%[6:01:07 PM] : ][CW][ : Brutos: but i forgot everything about it again ._.
%[6:01:07 PM] : ][CW][ : Brutos: :D
%[6:01:49 PM] =[BSID]= 1LT Beerdude26: Well, the guy whose work I'm building on found out that for a subset of the Contract datatype he was using, it is possible to infer contracts for expressions, just like you can for types
%[6:01:54 PM] : ][CW][ : Brutos: might be the notation in wiki looks somewhat familiar
%[6:02:17 PM] : ][CW][ : Brutos: so i have some code and i can infer that id > 0
%[6:02:18 PM] =[BSID]= 1LT Beerdude26: This is pretty nice; it allows you to define a "top-level" contract, and the rest of your code gets contracted appropriately
%[6:02:36 PM] : ][CW][ : Brutos: oh i say my id > 0 and the compiler checks it everywhere?
%[6:02:52 PM] =[BSID]= 1LT Beerdude26: Well
%[6:03:41 PM] =[BSID]= 1LT Beerdude26: It's more like, "I know that this output comes from this function, and this output has the constraint that it must be at least 10 items long"
%[6:04:01 PM] =[BSID]= 1LT Beerdude26: "So, I can infer that the constraint for the output of the function it came from must also be 10 items long"
%[6:04:05 PM] =[BSID]= 1LT Beerdude26: Etc etc
%[6:04:08 PM] =[BSID]= 1LT Beerdude26: Other tricks
%[6:04:27 PM] =[BSID]= 1LT Beerdude26: In the end, you have very specific contracts for deeply nested code
%[6:04:42 PM] : ][CW][ : Brutos: in 30 years it will make it into some kind of c++ standard :(
%[6:04:50 PM] =[BSID]= 1LT Beerdude26: Which is nice, because that means you can find out more easily where your code is going wrong
%[6:05:17 PM] =[BSID]= 1LT Beerdude26: The guy gave a nice example of insertion sort defined as a fold with insert: isort xs = foldr insert [] xs
%[6:05:41 PM] =[BSID]= 1LT Beerdude26: Then he defined a contract: the input of xs doesn't matter as long as it's a list, the output of xs must be ordered.
%[6:06:13 PM] =[BSID]= 1LT Beerdude26: Unfortunately, the inference does not support relations between input and output, so we can't say that the output must also be a permutation of the input
%[6:06:33 PM] : ][CW][ : Brutos: is that a limitation of the theory or of the tools?
%[6:06:38 PM] =[BSID]= 1LT Beerdude26: (Unless we transform our fold into paramorfism)
%[6:06:58 PM] =[BSID]= 1LT Beerdude26: Of the theory, the inferencing algorithm is very simple
%[6:07:15 PM] =[BSID]= 1LT Beerdude26: And cannot handle dependent functions
%[6:07:24 PM] =[BSID]= 1LT Beerdude26: That's why people look to refinement types, because they do support all this
%[6:07:37 PM] =[BSID]= 1LT Beerdude26: However, you need a constraint solver, some other fancy stuff
%[6:07:44 PM] =[BSID]= 1LT Beerdude26: Proving it all is fucking hard
%[6:07:52 PM] =[BSID]= 1LT Beerdude26: While proving this is pretty easy
%[6:08:00 PM] =[BSID]= 1LT Beerdude26: At the moment, I'm doing code generation
%[6:08:06 PM] : ][CW][ : Brutos: sounds like aweful big oh
%[6:08:23 PM] =[BSID]= 1LT Beerdude26: Yeah it's probably pretty slow, too
%[6:09:05 PM] =[BSID]= 1LT Beerdude26: The code generation I'm doing just takes Helium code (subset of Haskell 98 spec) and transforms it so it is fully contracted
%[6:09:47 PM] =[BSID]= 1LT Beerdude26: At the moment, it's just generic contracts that always resolve to "true", so in other words the contracts don't impose any restraints whatsoever
%[6:10:21 PM] =[BSID]= 1LT Beerdude26: However, I can then inject substitutions into the code generation bit
%[6:10:37 PM] =[BSID]= 1LT Beerdude26: So then suddenly you have specific contracts that are being passed around
%[6:11:34 PM] =[BSID]= 1LT Beerdude26: I think I'll copy this convo in my thesis text, it's a nice overview of what I have and have not done lol

\tableofcontents

\chapter{Introduction}
\todo{Talk about Ask-Elle and Jurriens work}
In this thesis, we extend the contract inferencing system developed by Jurri\"en Stutterheim and integrate it with the Ask-Elle programming tutor.

There are three main parts to this thesis:
firstly, the modifications to the original contract inferencing system are discussed and implemented. Secondly, code generation of contracted code is explained; Thirdly, the integration with the Ask-Elle programming tutor is laid out and developed.

\chapter{Problem description}
\section{Research question}
Having embedded contract inferencing in Ask-Elle, does this new functionality provide students with more detailed feedback than without?
Three main research goals are set up to achieve this.

\begin{description}
	\item{\textbf{Goal one}} Embed the contract inferencing system as described in Stutterheim's thesis.
	\item{\textbf{Goal two}} Perform tests with students to check if the newly-implemented functionality adds value to the provided feedback.
	\item{\textbf{Goal three}} Analyze the testing results and report our findings.
\end{description}

\subsection{Goal One: Embedding the contract inferencing system}


Figure depicts an overview of the steps involved in using the contract inferencing system.
The blue dashed-dotted arrows and boxes represent functionality that is not yet present in Ask-Elle, but is required for the contract inferencing system to be of use.
Let us step through the system and inspect the goals and requirements of each element in more detail.

Currently, if conventional 'diagnosis' of the student program fails, a QuickCheck example is generated, after which it is displayed to the user (this arrow is not shown).
Alongside the counterexample, the AST of the student program must be generated such that it can be used by the contract inferencing system.
The ASTs used by the Ask-Elle programming tutor and the contract inferencing system differ; Ask-Elle uses Helium as its back-end for Haskell, and Algorithm CW is based upon a small lambda language. So the first step towards embedding the system will be:

\begin{description}
	\item{\textbf{Step 1}} Modify and extend Algorithm CW to accept the AST generated by Ask-Elle, and embed it in Ask-Elle.
\end{description}

Initial work of this step has already been undertaken by research assistants (\todo{Who?}).
After completing Step 1, it should be possible to infer a contract for any arbitrary AST generated by Ask-Elle.

The next step is to use the contract-typed AST to generate an error message.
There are two ways of doing this:

\begin{enumerate}
	\item Use the QuickCheck-provided counterexample to transform the contract-typed AST directly, and then convert it back to an executable program and run it. We suspect that this functionality will be required for dependent function contracts.
	\item Convert the contract-typed AST back to an executable program immediately, and apply the counterexample to it.
\end{enumerate}

Replacing parts of the contract-typed AST with a counterexample was touched upon in Stutterheim's thesis, but an automated way of determining what should be replaced and where does not seem to be available.
Hence, this  is the next step:
\begin{description}
	\item{\textbf{Step 2}} Investigate an automated way of modifying the contract-typed AST with a counterexample, and implement this functionality.
\end{description}

After (not) modifying the contract-typed AST, it must be converted back into an executable program.
We assume the Helium-compiler has a way of feeding it an AST and returning an executable program.
However, keeping the well-known saying about assumptions in mind, we will have to investigate further:

\begin{description}
	\item{\textbf{Step 3}} Investigate if it is possible to feed a contract-typed AST to the Helium compiler. If not, investigate if this functionality can be implemented.
\end{description}

If all has gone well, we should end up with an error message generated by the Helium compiler, caused by a contract violation.
However, returning this error message to the student will not result in useful feedback.
Therefore, we must transform the error message by replacing the details of the contract violation with those of the function wrapped by the violated contract.
This transformed error message will be returned to the student. The final step of this subsection, then, is as follows:

\begin{description}
	\item{\textbf{Step 4}} Implement an error message transformer that "cleans up" the generated error message so it is understandable by the student, and feed it to the Ask-Elle feedback mechanism.
\end{description}

\subsection{Goal Two: Perform testing with students}

In August, Utrecht University hosts an Applied Functional Programming summer school.
This summer school course specifically targets students and participants who are not yet very knowledgeable about functional programming in general, and Haskell in particular.
This is an excellent opportunity to test the functionality described in Goal One.
Let us again go through each step that must be taken to complete this goal.

The first step is relatively simple, but nonetheless crucial:

\begin{description}
	\item{\textbf{Step 1}} Organize the practical aspects of the testing on time. Contact the coordinators of the summer school and request a time slot during which testing can take place.
\end{description}

After that, we must provide two versions of the Ask-Elle tutor: one with the new contract inferencing system embedded, and the original, unmodified one.
We require two versions to perform a simple A/B test: for each exercise, a version of Ask-Elle is randomly selected and presented to the student.
Thus, we require a way to randomly serve one of the versions to a student:

\begin{description}
	\item{\textbf{Step 2}} Prepare two versions of the Ask-Elle tutor, and set up access in such a way that, for each exercise, one of the versions is randomly served to the student.
\end{description}

After completing an exercise in Ask-Elle (there are around fifteen exercises in total), the student will fill out a very small survey if he or she encountered feedback containing a counterexample.
The feedback will be shown above the survey.
The following questions will then be visible below the feedback:

\fbox {
    \parbox{\linewidth}{
For each question, please mark the circle that corresponds with your opinion.
\begin{enumerate}
	\item The feedback above provided me with sufficient information to help me find the mistake in my code. \newline
[Strongly disagree] 0 - 0 - 0 - 0 - 0 [Strongly agree]
	\item The feedback above should indicate a more specific part of the code.\newline
[Strongly disagree] 0 - 0 - 0 - 0 - 0 [Strongly agree]
\end{enumerate}
    }
}

As this survey is quite small, it could be made multi-lingual if this makes students more inclined to take part in the survey.

With the results of these surveys, we are able to discern which version of Ask-Elle students prefer when they encounter feedback containing a counterexample.

So, our final steps for this goal are:

\begin{description}
	\item{\textbf{Step 3}} Build a small survey system that acquires any feedback containing a counterexample from the Ask-Elle tutor and presents the survey mentioned above, then writes the answers back to a database.
	\item{\textbf{Step 4}} Test the entire system beforehand, and ensure it is operational for use by the students.
	\item{\textbf{Step 5}} Collect survey results.
\end{description}

\subsection{Goal Three: Analyze the testing results and report findings}

Having collected the survey results, all that remains to be done is to analyze them and determine if the embedding of the contract inferencing system in Ask-Elle has increased the usefulness of feedback containing a counterexample provided to students, or not:

\begin{description}
	\item{\textbf{Step 1}} Analyze the survey results to answer the research question.
\end{description}

After processing the results, we will present our findings in a presentation, as is customary:

\begin{description}
	\item{\textbf{Step 2}} Report findings and problems encountered / lessons learned during this thesis in a presentation.
\end{description}

\chapter{Background}
In this chapter, we will familiarize the reader with some concepts that will be used onwards in this thesis, the most important ones being contracts and the notion of inferring types and contracts.


\section{Contracts}
\section{Inferencing}
\section{Attribute grammars}

\chapter{Approach}
Our first order of affairs was to read and test the source code provided by Stutterheim, which contained the contract inferencing system and the code generation system.
The latter system had some issues, and working those out provided the first step to our final code generation system.
On the way, we encountered several more problems, which we will discuss in the remainder of this section.
Each subsection focuses on initial research and attempts at solving the problem, and concludes with a reference to a section describing the workings of the final solution.

\section{Overview}

\begin{itemize}
\item Stutterheim's code generation system did not work correctly out of the box, and required some tinkering to get to work, a short description of which can be found at subsection ~\ref{figuringoutcodegeneration}. A more detailed overview of the final code generation system can be found at section ~\ref{codegeneration}.
\item The existing 'typed-contracts' library provided poor feedback messages and required expansion. Section ~\ref{modificationstotypedcontracts} explains the modifications to the library in depth.
\item Code generation and some AST transformations required a reliable and robust source of types. The attempts can be found subsection ~\ref{attemptssourceoftypes}, and a description of the workings of the final system is at section ~\ref{sourceoftypes}.
\item The last problem encountered was an underestimated one: moving from monomorphic to polymorphic contracts. Further exploration of this problem is located in subsection ~\ref{monotopolyproblem}.
\end{itemize} 

\section{Figuring out code generation}
\label{figuringoutcodegeneration}

\subsection{Short description}
Stutterheim's code generation system takes the AST of the code to be contracted along with information about identifiers' types and contracts, and uses those to transform the original code into a fully-contracted version.

A very simple example:

\begin{lstlisting}[caption=A simple expression in Stutterheim's $\lambda_c$ language.]
let g x = x
in let f x = g x
   in (\x -> f x)
\end{lstlisting}

This would be converted into something like:

\begin{lstlisting}[caption=The same expression after going through code generation.]
let g x = x
in let __ctrt_g ctrt x = apply (assert "g" ctrt) (app (fun (g x)))
   in let f x = __ctrt_g {CONTRACT} x
      in let __ctrt_f ctrt x = apply (assert "f" ctrt) (app (fun (f x)))
         in (\x -> __ctrt_f {CONTRACT} x)
\end{lstlisting}

In short, the AST is traversed and every function definition receives a contracted version which calls the original code.
On top of that, every function application is replaced with this contracted version and a contract is added as another parameter.

\subsection{Issues in original code}
The code generation proof-of-concept in Stutterheim's thesis did not generate code that compiled in GHC, as it contained several errors:

\begin{itemize}
\item Capture and application of arguments using the \code{fun} and \code{app} functions, respectively, was done incorrectly, resulting in an incorrectly typed contract (if valid at all). 
\item Higher-order functions were not taken into account.
\end{itemize}

Function arguments of a higher-order function  should be not replaced by a fully-applied contracted version of the function, but by something else.
We began by splitting up the application of arguments to a contracted function and the definition and assertion of a contracted function itself.
As an example, the function definition

\begin{lstlisting}
f x = x
\end{lstlisting}

would now generate two more definitions:

\begin{lstlisting}
__contracted_f ctrt = assert "f" ctrt funs
 where funs = fun (\x -> f x)
__app_f ctrt x = app (__contracted_f ctrt) 0 x
\end{lstlisting}

This allowed us to use the \_\_contracted version for a function argument,
and the \_\_app version for fully-applied function applications of \code{f}.

Expanding the code generation system was necessary to accommodate for this feature.
But to be able to do so, we needed some information about the type of a function, namely its arity and the arity of its arguments.
Using this information, it would be possible to differentiate between partially-applied and fully applied function applications.
This source of type information was recovered from the contracts themselves, which closely mimick the type of a function.

Differentiating between these two versions uncovered another issue, however:
function arguments in a higher-order function must be expanded to be able to apply any other arguments to it.
Another example:

\begin{lstlisting}
f g x = g x
\end{lstlisting}

generates the following \code{\_\_contracted} definition:

\begin{lstlisting}[caption=Output of the \_\_contracted function definition of the above example.]
__contracted_f ctrt = assert "f" ctrt funs
 where funs = fun (\g -> (fun (\x -> f (\y -> app g y) x)))
\end{lstlisting}

This is because the argument \code{g} passed to \code{f} is already a contracted version of \code{g}.
Hence, we need to use \code{app} to apply \code{y} to \code{g}.

After these modifications, code was correctly generated for Stutterheim's simple language.

Of course, we still lacked many features that were required for the successful (and useful!) contracting of Helium code:

\begin{itemize}
\item The use of nested lets made use of mutually recursive functions hard to do.
\item Because of a global list of substitutions, applying a function twice to different arguments resulted in one of the functions being contracted incorrectly. In this sense, generated code was monomorphic with regard to contracts.
\item There was no way to point to a certain location in the code, and feedback was minimal.
\item Anonymous functions were not contracted.
\item It wasn't obvious where we could get the types from for the Helium AST.
\end{itemize}

Supporting mutually recursive functions proved to be relatively easy if we modeled the non-inferenced contracts after the types from the Helium compiler \todo{make section?}.

Making generated code polymorphic with regard to contracts needed far more attention, the details of which can be found in subsection ~\ref{monotopolyproblem}.

Providing rich feedback was also a goal. Details can be found in section ~\ref{providingricherfeedback}.

\todo{Section for transformations done?}

Finding a reliable source of types proved daunting, which is what the next subsection will cover.

\section{Attempts at finding a source of types}
\label{attemptssourceoftypes}
While developing the code generation code, it quickly became clear that the types of an identifier would be required.

There were two main uses for these types:
\begin{enumerate}
\item Calculating the arity of a type and the arity of each of the arguments of a function. This information proved necessary for code generation of higher-order functions and several AST transformations.
\item Basing an identifier's contract upon its type made contract inferencing easier and simpler. It also prevented the need for an analysis of mutually recursive structures during contract inferencing, as that analysis had already been done by the type system. \todo{Is this true? Verify!}
\end{enumerate}

\subsection{Initial attempt}

A first attempt at producing such a source of types was very ad-hoc: 
an initial type environment was produced by taking the string representation of the code and passing it to the Helium compiler, which returned the types of all top-level identifiers.
Identifiers defined in patterns were given a type by breaking it up piece by piece and passing it through the AST.
This meant that we needed to be able to identify each constructor, fetch its type, and break up the type into appropriate parts.
Every time a where-clause or let-binding was encountered, the environment would be passed to the Helium compiler along with the string version of the code block.
Then, the existing environment would be updated accordingly and passed downwards in the AST.
Lambda functions and case statements were even worse, needing to be first converted into a declaration AST before being able to be passed to the Helium compiler.
Because of this iterated process, some information was lost, such as type class prerequisites.
In turn, this caused compilation errors when the Helium compiler expected an identifier to have a type class prerequisite it did not have.
The system was cumbersome, buggy and most certainly not very efficient time- and spacewise.
It sorely needed replacement.

\subsection{Finding an alternative}
Looking through the Helium compiler options did not show any way of solely extracting the types from a piece of code and returning it in a structured manner.

However, in the Helium codebase, we discovered a function named 'proximaTypeInferencing' that returned a list of tuples that contained a range and a type scheme.

Intrigued, we dug deeper and discovered that it first collected the types of the entire AST in a doubly-linked tree data structure that closely resembled the original Helium AST.

Through some trial and error, it was possible to deconstruct this "type tree" as it was passed downwards through an AST.
The information this tree held was very rich indeed: not only did it have types for every identifier in patterns and expressions, but those types were also the final ones.
Most importantly, the integers that represented a unique type variable could be used to seed an initial contract for each identifier.
Because type inferencing had already taken place, contract inferencing could piggyback on the relations between the types of different identifiers.

With this new source in place, it was trivial to keep a type environment updated without too much changes required to the rest of the codebase.
As an added bonus, this type collection needed to be ran only once: a vast improvement compared to the first type source.

Further details on the final source of types can be found in section ~\ref{sourceoftypes}.

\section{Exploring the conversion from monomorphic to polymorphic contracts}
\label{monotopolyproblem}

Stutterheim's contract inferencing algorithm is monomorphic with relation to contracts.
What this means is that if a contracted function is applied more than once, to different arguments, only one of the function applications will yield a valid contract.
Naturally, we would like to be able to apply a function to different arguments without issue.

Let's look at a short example to clarify the problem.

\subsection{Problem example}
We want to run contract inferencing on the following piece of code:

\begin{lstlisting}[caption=An example code snippet that may generate incorrect code under Stutterheim's contract inferencing algorithm.]
f x = [x]
z = (f 'a', f 5)
\end{lstlisting}

We can either leave the contract environment empty, or seed it with some initial values, as you can see in listing \ref{lst.contractz}.

\begin{lstlisting}[caption=Contract of \code{z}.,label=lst.contractz]
true <@@> (true <@> isChar, true <@> isNum)}
\end{lstlisting}

The used contract are as follows: \code{true} is the most general contract you can have and never fails. \code{isChar} and \code{isNum} check if the argument that is provided to them is a character or a number, respectively.
\todo{We should write this all a bit more formally, of course.}

With this environment, contract inferencing generates the following substitutions:

\begin{lstlisting}[caption=List of substitutions generated by running Stutterheim's contract inferencing algorithm.]
(m8 +-> (true <@> isNum)) `o` (m7 +-> (true <@> isChar)) `o` (v1 +-> m8) `o` (v1 +-> m7)
\end{lstlisting}

Contract variables prefixed with a 'v' are universally quantified variables, or 'global' variables, and those prefixed with an 'm' are 'local' variables.
Local variables are only relevant to the function application from which they were generated.
Both types of variables are converted to the \code{true} contract during code generation if they have not been replaced by property contracts.

Armed with this knowledge, let's look at the universally quantified contract for \code{f}:

\todo{This contract is incorrect, update.}
\begin{lstlisting}[caption=The inferred contract for \code{f}.]
(v1 >-> v1)
\end{lstlisting}

The problem with placing local substitutions among global ones becomes apparent: whichever way we choose to apply the list of substitutions (left-to-right or right-to-left), one of the function applications will always have an incorrect contract!

In our example, the contracted version of \code{z} could be as follows:

\todo{This contract is incorrect, update.}
\begin{lstlisting}[caption=Contracted version of \code{z} that will fail typechecking.]
z = (__app_f (true <@> isNum) 'a', __app_f (true <@> isNum) 5)
\end{lstlisting}

Obviously, \code{'a'} is not a number.
This particular generated code will fail to compile because the compiler recognizes that the \code{Char} type does not have a class instance for the \code{Num} typeclass, but contracts that do not rely on such prerequisites will typecheck without issue.
For instance, it is possible to have a contract that checks if a number is a natural number.
If such a contract were to be erroneously applied to a number that is not a natural number, the generated code would typecheck, but fail during runtime.
This breaks Stutterheim's proposition that "(an) inferred contract will never fail assertion for that expression". \todo{Source diiis}

\subsection{Proposed solution}
Global and local substitutions must be kept apart from each other.
Whenever unification between two contracts takes place, the resulting substitutions are to be split up in a global and local group:
\begin{itemize}
\item The global group holds all substitutions that go from polymorphic contracts to other polymorphic contracts.
\item The local group holds all substitutions that go from polymorphic contracts to monomorphic contracts, as well as those that go from monomorphic contracts to other monomorphic contracts.
\end{itemize}
Global substitutions are to be handed up the AST, and local substitutions are to be handed down the AST.

When contract inferencing is complete, the global substitutions are applied first and local substitutions second.
However, these local substitutions will refer to old global contract variables, so the global group of substitutions must first be applied to the local substitutions before finally applying the local substitutions to the updated contract to gain the final contract.

At first, it appears logical to apply these substitutions during code generation, and not during runtime, but this is not optimal.
Let us look at an example to see why.

\begin{lstlisting}[caption=Expanded version of the previous code snippet.]
f x = g x
g x = f [x]
z = (f 'a', f 5)
\end{lstlisting}

The example has been expanded to include function \code{g}, which is called by \code{f}.
The contract environment remains the same as before.
The inferred contract for both \code{f} and \code{g} is once again '(v1 >-> v1)'. \todo{This contract is incorrect, update.}
The contracted code for \code{z} is now correct:
\todo{This contract is incorrect, update.}

\begin{lstlisting}[caption=Contracted version of \code{z} now typechecks.]
z = (__app_f (true <@> isChar) 'a', __app_f (true <@> isNum) 5)
\end{lstlisting}

Let's look at the rest of the generated code:

\begin{lstlisting}[caption=Rest of the output of code generation.]
__app_f ctrt x = appParam (__contracted_f ctrt) x
__contracted_f ctrt = assertPos "f" ctrt funs
    where
        funs = (fun (\x -> __final_f x))
__final_f x = __app_g (v1 >-> (v2 <@> v1)) x

__app_g ctrt x = appParam (__contracted_g ctrt) x
__contracted_g ctrt = assertPos "g" ctrt funs
    where
        funs = fun (\x -> __final_g x)
__final_g x = [x]
\end{lstlisting}

Calling the contracted version of \code{f} will call the contracted version of \code{g}, but with a universally quantified contract!
In other words, the local substitutions which made the contract that was passed to \code{\_\_app\_f} more specific, are not utilized by \code{\_\_app\_g}.
The solution appears trivial: pass the local substitutions as another argument to the \code{\_\_app} and \code{\_\_contracted} functions and apply them at runtime.

\subsection{Applying substitutions at runtime}

Unfortunately, it is not so simple.
Doing substitutions at runtime instead of statically means a runtime conversion is necessary between the AST contract datatype and the datatype from the \code{typed-contracts} library:
The AST datatype is a simple UUAGC-generated datatype without a phantom type, and \code{typed-contracts}'s datatype is a GADT with a phantom type used for a type-level representation of the contract.
Conversion between the two means we need to be able to tell what this phantom type should be. This is especially a problem when we need to convert between property contracts (\code{Prop} and \code{PropInfo}), because each property contract has a different phantom type, and the only information available in the AST datatype equivalent is a \code{String}.
Several ideas were tested to complete the conversion, the first of which was to use a typeclass:

\begin{lstlisting}[caption=Attempt at using a typeclass to recover the extra type information.]
class ConvertContract aT where
 convert :: Contract -> (Contract aT)

instance ConvertContract aT where
 convert (CVar s _) = true
 convert (CProp s) = searchEnvTuple s envTuple

instance ConvertContract (aT :-> bT) where
 convert (CArr c1 c2) = (>->) (convert c1) (convert c2)

instance Bifunctor f => ConvertContract (f aT bT) where
 convert (CBifunctor o il ir) = (convert o) <@@> (convert il,convert ir)

instance Functor f => ConvertContract (f aT) where
 convert (CFunctor o i) = (convert o) <@> (convert i)
 
testEnvTuple
  :: (Functor f, Ord dT, Ord bT, RealFrac eT) =>
     ((String, Contract (f cT :-> [dT])),
      ((String, Contract aT),
       ((String, Contract [bT]),
        ((String, Contract Char),
         ((String, Contract eT), ([a], Contract fT))))))
testEnvTuple = ( ("isort",sortCtrt), ( ("ctrue",true), ( ("ord",ord), ( ("isChar_prop",isChar_prop), ( ("isInt_prop", isInt_prop), ([], true) ) ) ) ) )
\end{lstlisting}

Because of the different phantom types, a nested tuple was needed to house the property environment. \todo{Why didn't this work, again? I think the typechecker didn't want to play nice and kept trying to unify these types or something.}

A type annotation would be required for this solution, so the compiler knows which instance to select.
Statically generating such an annotation would have been perfectly feasible, although it would have suffered from the same issue as the one we were trying to solve: 
the annotation for the contracted version of 'g' would have been a generic one.

Another idea would be to add the phantom type to the AST datatype, making conversion trivial.
Unfortunately, an option for adding phantom types in a UUAGC-defined datatype could not be found.
Even if phantom types were supported, the generation code would have had to have been rewritten to use a nested tuple for the environment contract instead of a regular list.

What about using type synonyms and the aforementioned typeclass?

\begin{lstlisting}[caption=Attempt at using type synonyms to choose the correct instances.]
instance ConvertContract aT where
  convert (CVar s _) = true
type IsIntProp aT = aT
instance RealFrac (IsIntProp aT) => ConvertContract (IsIntProp aT) where
  convert (CProp p) | p == "isInt_prop" = isInt_prop
\end{lstlisting}

Unfortunately, when deciding an instance, any constraints are ignored, and because type synonyms are transparent to the compiler, these instances fully overlap.
Simon Peyton-Jones and Oleg Kiselyov (http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap) do describe a way to use overlapping instances and functional dependencies to achieve this, but it requires a lot of extra work for every property.

After type synonyms, newtypes were tried:

\begin{lstlisting}[caption=Attempt at using newtypes to choose the correct instances.]
newtype IsIntProp aT = IsIntProp aT
instance RealFrac (IsIntProp aT) => ConvertContract (IsIntProp aT) where
  convert (CProp p) | p == "isInt_prop" = isInt_prop
\end{lstlisting}

This seemed to work, but it required wrapping and unwrapping of values, which was incompatible with the generated code.
Recall the contracted version of \code{f}:

\begin{lstlisting}
__app_f ctrt x = appParam (__contracted_f ctrt) x
__contracted_f ctrt = assertPos "f" ctrt funs
    where
        funs = (fun (\x -> __final_f x))
__final_f x = __app_g (v1 >-> (v2 <@> v1)) x
\end{lstlisting}

The value \code{x} would have to be unwrapped before it could be passed to \code{\_\_final\_f}, and these unwrapping functions would all have a different name.
A typeclass could be used to provide a singular function to wrap and unwrap newtypes, but user-defined typeclasses are currently unsupported by the Helium compiler.
Apart from that, this seemed to be a promising solution.

A final "solution" that would not require the use of typeclasses, would have been to generate a monomorphic set of contracted functions for every single function application.
Naturally, this set would need to contain every single function that is called when evaluating that particular function application; a possibly daunting amount.
Importing other modules makes this solution even less feasible, as functions from those modules would also need to be included in the set.
Because of the multitude of issues, this solution was disregarded early in the process.

Some of the proposed solutions are promising, but could not be explored further due to time constraints.
As such, the current code generation system generates monomorphic code that may fail when a function is applied to different contracts.
Rolling back to the polymorphic version is, of course, still possible, and is left as future work (see section ~\ref{futurework}).

\chapter{Final system design}
This chapter explores the details of the final design of the entire code generation system.

First, we introduce the syntax for our abstract syntax tree (AST), which is a slightly modified version of the syntax Ask-Elle uses.
We will then follow the flow of the abstract syntax tree as it goes through the entire system, starting with several AST transformations, after which we will enter the code generation system, which consists of contract generation and -inferencing, and code generation.
The next two pages provide a visual overview of the system's flow.
Each node has a number that will be used when referring to it in the description.

\todo{Add these numbers to the image.}

\section{Syntax}
We have slightly modified the syntax used by the rest of the Ask-Elle system:
\begin{itemize}
	\item Fields to store range information were added. Range information consists of the line and column number of the node and its source (standard input, file, unknown) if this information is available.
	\item In Ask-Elle, constructors that use a list of patterns or expressions use the \code{Pats} and \code{Exprs} type synonyms, respectively. For example, expressions that describe a tuple or a list both use \code{Exprs}. However, from the viewpoint of contract inferencing, these expressions could not be more different! The solution is simple: tuples and lists in patterns and expressions use the type synonyms \code{ListPatsR}, \code{TuplePatsR}, \code{ListExprR} and \code{TupleExprR}. All other constructors remain unchanged.
\end{itemize}

This modified syntax can be downcast to the regular Ask-Elle syntax, and partially upcast to the Helium syntax, as during conversion from the Helium AST to the Ask-Elle syntax, some nodes are thrown away or only partially mapped.

\begin{lstlisting}[caption=Our modified Ask-Elle syntax.]
-- | A Haskell source module
data ModuleR
   | ModuleR
      name     :: MaybeNameR
      body     :: BodyR
      range    :: RangeR

data BodyR
   | BHoleR
      id       :: HoleIDR
      range    :: RangeR
   | BodyR
      decls    :: DeclsR
      range    :: RangeR

-- | Declarations
data DeclR
   | DHoleR
      id       :: HoleIDR
      range    :: RangeR
   | DEmptyR
      range    :: RangeR
   | DFunBindsR
      funbinds :: FunBindsR
      range    :: RangeR
   | DPatBindR
      pat      :: PatR
      rhs      :: RhsR
      range    :: RangeR

type DeclsR = [DeclR]

-- | Expressions
data ExprR
   | HoleR
      id       :: HoleIDR
      range    :: RangeR
   | FeedbackR
      feedback :: String
      expr     :: ExprR
      range    :: RangeR
   | MustUseR
      expr     :: ExprR
      range    :: RangeR
   | CaseR
      expr     :: ExprR
      alts     :: AltsR
      range    :: RangeR
   | ConR
      name     :: NameR
      range    :: RangeR
   | IfR
      cond     :: ExprR
      then     :: ExprR
      else     :: ExprR
      range    :: RangeR
   | InfixAppR
      left     :: MaybeExprR
      op       :: ExprR
      right    :: MaybeExprR
      range    :: RangeR
   | LambdaR
      pats     :: PatsR
      expr     :: ExprR
      range    :: RangeR
   | LetR
      decls    :: DeclsR
      expr     :: ExprR
      range    :: RangeR
   | LitR
      lit      :: LiteralR
      range    :: RangeR
   | AppR
      fun      :: ExprR
      args     :: ExprsR
      range    :: RangeR
   | ParenR
      expr     :: ExprR
      range    :: RangeR
   | TupleR
      exprs    :: TupleExprR
      range    :: RangeR
   | VarR
      name     :: NameR
      range    :: RangeR
   | EnumR
      from     :: ExprR
      then     :: MaybeExprR
      to       :: MaybeExprR
      range    :: RangeR
   | ListR
      exprs    :: ListExprR -- We use a new type here because for lists, the inferred contracts must hold on all elements.
      range    :: RangeR
   | NegR
      expr     :: ExprR
      range    :: RangeR

type ExprsR = [ExprR]
type ListExprR = [ExprR]
type TupleExprR = [ExprR]

data MaybeExprR
   | NoExprR
   | JustExprR
      expr     :: ExprR

-- | Alternatives
data AltR
   | AHoleR
      id       :: HoleIDR
      range    :: RangeR
   | AltR
      feedback :: {Maybe String}
      pat      :: PatR
      rhs      :: RhsR
      range    :: RangeR
   | AltEmptyR
      range    :: RangeR

type AltsR = [AltR]

-- | Function bindings
data FunBindR
   | FBHoleR
      id       :: HoleIDR
      range    :: RangeR
   | FunBindR
      feedback :: {Maybe String}
      name     :: NameR
      pats     :: PatsR
      rhs      :: RhsR
      range    :: RangeR

type FunBindsR = [FunBindR]

-- | Guarded expressions
data GuardedExprR
   | GExprR
      guard    :: ExprR
      expr     :: ExprR
      range    :: RangeR

type GuardedExprsR = [GuardedExprR]

-- | Literal values
data LiteralR
   | LCharR
      val      :: Char
      range    :: RangeR
   | LFloatR
      val      :: Float
      range    :: RangeR
   | LIntR
      val      :: Int
      range    :: RangeR
   | LStringR
      val      :: String
      range    :: RangeR

-- | Names
data NameR
   | IdentR
      name     :: String
      range    :: RangeR
   | OperatorR
      name     :: String
      range    :: RangeR
   | SpecialR
      name     :: String
      range    :: RangeR

data MaybeNameR
   | NoNameR
   | JustNameR
      name     :: NameR

-- | Patterns
data PatR
   | PHoleR
      id       :: HoleIDR
      range    :: RangeR
   | PConR
      name     :: NameR
      pats     :: PatsR
      range    :: RangeR
   | PInfixConR
      left     :: PatR
      name     :: NameR
      right    :: PatR
      range    :: RangeR
   | PListR  -- We use a new type here because for lists, the inferred contracts must hold on all elements.
      pats     :: ListPatsR
      range    :: RangeR
   | PLitR
      lit      :: LiteralR
      range    :: RangeR
   | PParenR
      pat      :: PatR
      range    :: RangeR
   | PTupleR
      pats     :: TuplePatsR
      range    :: RangeR
   | PVarR
      name     :: NameR
      range    :: RangeR
   | PAsR
      name     :: NameR
      pat      :: PatR
      range    :: RangeR
   | PWildcardR
      range    :: RangeR

type PatsR = [PatR]
type ListPatsR = [PatR]
type TuplePatsR = [PatR]

-- | Right hand side
data RhsR
   | RhsR
      expr     :: ExprR
      where    :: DeclsR
      range    :: RangeR
   | GRhsR
      gexprs   :: GuardedExprsR
      where    :: DeclsR
      range    :: RangeR

data RangeR
    | RangeR
        rangestart                    :: PositionR
        rangestop                     :: PositionR

data PositionR
    | PositionR
        filename                 :: String
        line                     :: Int
        column                   :: Int
    | UnknownR
\end{lstlisting}

\section{Overview}

\includepdf[pages={1}]{systemoverview.pdf}
\includepdf[pages={2}]{systemoverview.pdf}

\section{AST transformations}
Before passing the AST to the code generation system, we apply several transformations to it to facilitate contract inferencing and code generation.

\subsection{Capture lambdas}
Anonymous functions cannot be contracted, as a name is required to properly  perform code generation.
Our solution is simple: bind all lambda functions to a generated name and place them in the where-clause of the original definition.
A simple example:

\begin{lstlisting}
f = \x -> x
\end{lstlisting}

is transformed into

\begin{lstlisting}[caption=Result of lambda capture transformation.]
f = __lam0                   
 where                    
  __lam0 = \x -> x
\end{lstlisting}

Because of referential transparency, the behaviour of the program is not altered.

\subsection{Rewrite point-free functions}
The library of our choice, \code{typed-contracts}, does not support asserting partially applied functions.
Because of this, all function arguments are made available on the left-hand side and applied to the right-hand side of a definition.
To continue with our previous example,

\begin{lstlisting}
f = __lam0                   
 where                    
  __lam0 = \x -> x
\end{lstlisting}

is now transformed into

\begin{lstlisting}[caption=Result of $\eta$-abstraction transformation.]
f __a0 = (__lam0) __a0                
 where                    
  __lam0 __a0 = (\x -> x) __a0
\end{lstlisting}

This is essentially $\eta$-abstraction.
The information required for this transformation is provided by the type source,  which resides inside the code generation system.

\subsection{Rewrite infix function applications}
To cut down on duplicate code for both contract inferencing and code generation, we convert infix function applications to regular function applications.
In other words, we remove a layer of syntactic sugar.

\subsection{Expand function applications}
To keep contract inferencing simple, we split up function applications that are applied to multiple arguments into several nested function applications.
For example:

\begin{lstlisting}
f g x y z = g x y z
\end{lstlisting}

is transformed into

\begin{lstlisting}[caption=Result of function application expansion transformation.]
f g x y z = ((g x) y) z
\end{lstlisting}

This allows us to use Stutterheim's original contract inferencing code for function applications.

\subsection{Expand lambda arguments}
The reasons for this transformation are similar as the previous one: keeping contract inferencing simple and being able to reuse Stutterheim's contract inferencing code.
A lambda function with multiple arguments is split up into nested lambda functions:

\begin{lstlisting}
f = \g x y z -> g x y z
\end{lstlisting}

is transformed into

\begin{lstlisting}[caption=Result of lambda argument expansion transformation.]
f = \g -> (\x -> (\y -> (\z -> g x y z)))
\end{lstlisting}

\section{Source of types and initial contracts}
\label{sourceoftypes}
After these transformations, the AST is passed to the type source and to the code generator.

\subsection{Type source}
The type source takes the AST and calls a modified version of the Helium type inferencing code, which produces as doubly linked tree that resembles the input AST.
Each node in the tree holds an attribute list of a 3-tuple of information: 
\begin{itemize}
\item A textual representation of the piece of code, for debugging purposes.
\item A Helium AST of the piece of code.
\item If applicable, the type of the piece of code.
\end{itemize}

This "type tree" is generated in the \code{ModuleR} node of the AST, and is then passed down to the body of the module.

For the most part, the type tree format is the same as the code AST, the biggest discrepancies being situated in the following nodes:

\begin{description}
	\item{GRhsR:} The attribute list is of the form:
\begin{lstlisting}
[guard,expr,guard,expr,...,wheredecls]
\end{lstlisting}
	\item{CaseR:} An alternative has two entries in the attribute list: one for the left-hand side, and one for the right-hand side.
	\item{EnumR:} The type tree is ambiguous here: both \code{[1..2]} and \code{[1,2..]} return the same type tree. The code AST is inspected to determine what form is used, and the type tree is split up accordingly.
	\item{FunBindR:} A type is not available for a function binding, so we must synthesize one. This is done by concatenating all the types of any patterns of the function binding and the type of the right-hand side. 
\end{description}

Types are available for every constructor of the following AST types:
\begin{itemize}
	\item ExprR
	\item PatR
	\item AltR
	\item FunBindR
	\item RhsR
	\item GuardedExprR
\end{itemize}

\subsection{Initial contracts}
After providing types, a contract environment is constructed that holds the contracts for all identifiers (which consists of function identifiers and pattern identifiers) currently in scope at a certain node of the AST.

The initial contracts are generated by passing a \code{TpScheme} value (from the \code{top} library) to the \code{convertTopTypeToContract} function, which strips down the type scheme to its primitive type and inspects it, converting it appropriately.
This list shows which pattern match relates to which action:
\begin{description}
	\item{\code{(TVar i)} :} A \code{TVar} contains an integer \code{i} that corresponds to a specific type. That integer is prefixed with the character 'v' to indicate the initial contract is a universally quantified contract variable. For example, the type \code{a -> a} will be converted to the contract \code{v1 >-> v1}.
	\item{\code{(P.TApp (P.TApp (P.TCon "->") t1) t2)} :} A function application. \code{t1} and \code{t2} are also converted and put in a non-dependent function contract. For example, the type \code{a -> b} will be converted to the contract \code{v1 >-> v2}.
	\item{\code{(P.TApp (P.TCon x) t1) | x `elem` ["Maybe","[]"]} :} Both the \code{Maybe} type and the list type are converted to a functor contract.
	\item{\code{(P.TApp (P.TApp (P.TCon x) t1) t2) | x `elem` ["Either","(,)"]} :} Both the \code{Either} type and the 2-tuple type are converted to a bifunctor contract.
	\item{\code{(P.TCon x) | x `elem` ["Int","Char","Float","Bool","String"]} :} Literals of these types are converted to a universally quantified contract variable. Such a contract variable is provided with a fresh integer that does not collide with the set of integers used in the \code{TVar} constructors.
\end{description}

3-tuples and 4-tuples are also supported, but have been left out for brevity.

At the moment, user-defined data types are unsupported.
However, a data type environment is available and could be queried for the data type's general form and its name, allowing us to construct a pattern match.
Alternatively, one could generate a typeclass instance for each defined data type using Template Haskell or some other form of preprocessing.
Manually adding new data types to the conversion function is possible as well, of course.

These initial contracts are of great use for mutually recursive functions.
Let's look at the initial contracts that are generated for the following (not quite useful) example:

\begin{lstlisting}[caption=Simple mutually recursive function example.]
f x = g x
g x = f x
\end{lstlisting}

which generate the following types:
\begin{description}
	\item{\code{f} :} \code{v1 >-> v2}
	\item{\code{g} :} \code{v1 >-> v2}
\end{description}

From the types, it is obvious that the two functions are very closely intertwined, as they both take the same form of contracted input and the same form of contracted output.

These initial contracts are passed to the contract inferencing system to simplify inferencing greatly.

\section{Contract Inferencing}
Our contract inferencing system is based upon Stutterheim's work, and it is advised you read the chapters on contract inferencing if you are interested in the details, which we may leave out if they are the same.

Our algorithm is also based on the Damas and Milner type inferencing system, with a few modifications and simplifications due to our use of a type source.

Our goals for contract inferencing remain the same as Stutterheim's:
\begin{enumerate}
	\item Infer a well-typed contract for each function in a program;
	\item Inferred contracts must allow a (possibly non-strict) subset of the values that the type allows, and
	\item The most general contract inferred by the inferencing system must never fail during assertion.
\end{enumerate}

Because we use Algorithm \CW ~as a starting point, our algorithm, too, is based on Milner's Algorithm \W, and we make use of Robinson's unification algorithm as well.
The resulting algorithm is called Algorithm \CHW, and is discussed in

\subsection{Formal description of the contract language}
Figure \ref{fig:contract-grammar} described our contract language, which is a subset of that of Stutterheim's contract language.

While Stutterheim preferred to have specific terminals for data types literals, we felt this over-encumbered the contract language.
Instead, we have replaced this multitude of terminals with a single \code{literal} terminal.

\begin{figure}[ht]
\begin{center}
\begin{lstlisting}[mathescape]
  -- Contracts
  c ::=  $\rho_{\alpha}$			-- User-defined concrete contract
      |  $c_{\alpha}$ >-> $c_{\beta}$			-- Function contracts
      |  $c_{\alpha}$ <@> $c_{\beta}$			-- Functor contracts
      |  $c_{\alpha}$ <@@> ($c_{\beta}$, $c_{\gamma}$)		-- Bifunctor contracts
      |  $true_{\alpha}$			-- true contract
      |  $false_{\alpha}$			-- false contract
      |  $literal_{\alpha}$			-- literal contract
\end{lstlisting}
\end{center}
\caption{\label{fig:contract-grammar}Simplified grammar for the contract language.}
\end{figure}

Stutterheim describes several definitions, properties and relations between contracts in his thesis.
These remain valid in our system.

\todo{Most of this was done by Jurrien, although we can leave out some parts.}



\subsection{The contract inferencing system}
In this section, we will explore a system that allows us to infer a contract from an expression.
This system is based upon Stutterheim's work, and this section will roughly follow the same structure as the section in his thesis.

In our system, we use a contract environment $\Gamma$ which maps contract variables to contracts.
\todo{Should we just say that we use the same env system as Jurrien?}
A contract environment is defined as such:

\begin{figure}[ht]
$\Gamma ::= [\!~]\!~||\!~\Gamma_1[x \mapsto c]$
\end{figure}

So, $\Gamma$ can either be completely empty, or consist of an environment $\Gamma_1$ that is extended by a mapping from a contract variable $x$ to a contract $c$.

We use the same notation as Stutterheim for contract environments:
\begin{itemize}
	\item $\Gamma(x)=c$ means that the right-most binding for $x$ in $\Gamma$ maps $x$ to $c$.
	\item $\Gamma \vdash e : c$ denotes that, in environment $\Gamma$, the expression $e$ has the contract $c$.
	\item $fc(\sigma)$ indicates the set of $true$ contracts that are free in contract schema $\sigma$.
	\item $fc(\Gamma)$ indicates the set of $true$ contracts that are free in the codomain of $\Gamma$.
\end{itemize}

The \code{gen} and \code{inst} support functions used by Stutterheim are deprecated by our use of a type source, so we will omit them in our description.
In place of these functions, we define the support function \code{ts}, which takes an identifier $i$ and as many fresh $true$ contracts as necessary to perform a conversion from the type of $i$ to a contract $c$.

\subsubsection{Contracting rules}

We will begin the contracting rules with those for patterns, as many of the rules are similar to those for declarations, right-hand sides, (guarded) expressions and alternatives.

\begin{figure}[ht]
\begin{center}
  \RightLabel{\textsc{C-PHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PWildcard}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $* :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PCon}}
  \AxiomC{$\Gamma \vdash$ $e_1 :: c_2 \rightarrowtail c$}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c_2$}
  \BinaryInfC{$\Gamma \vdash$ $e_1$ $e_2 :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PVar}\quad}
  \AxiomC{$\forall{i}\in[0\ldots{n}]$ $fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $p :: ts(p,[true_0\ldots{true_n}])$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PAs}\quad}
  \AxiomC{$\forall{i}\in[0\ldots{n}]$ $fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $p@(ps) :: ts(p,[true_0\ldots{true_n}])$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PCons}\quad}
  \AxiomC{$\Gamma \vdash$ $x :: c$}
  \AxiomC{$\Gamma \vdash$ $xs :: list \functor c$}
  \BinaryInfC{$\Gamma \vdash$ $(x : xs) :: list \functor c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PNil}\quad}
  \AxiomC{$fresh(i, j)$}
  \UnaryInfC{$\Gamma \vdash$ $[] :: true_i \functor true_j$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PTuple}\quad}
  \AxiomC{$\forall{i}\in{[0\ldots{n}]} \Gamma \vdash$ $e_i :: c_i$}
  \AxiomC{$fresh(j)$}
  \BinaryInfC{$\Gamma \vdash$ $(e_0, .., e_i) :: true_j \bifunctor (c_1, .., c_i)$}
  \DisplayProof
  \vskip 0.5em
%  \RightLabel{\textsc{C-PTupleNil}\quad}
%  \AxiomC{$\forall{i}\in[0\ldots{n}]$ $\Gamma \vdash$ $t_i :: c_i$}
%  \AxiomC{$\forall{j}\in[0\ldots{n-1}]$ $fresh(j)$}
%  \BinaryInfC{$\Gamma \vdash$ $(t_0, ..., t_i) :: true_0 <@@> (c_0, true_1 <@@> (..., true_j <@@> (c_i-1, c_i) ) )$}
%  \DisplayProof
%  \vskip 0.5em
  \RightLabel{\textsc{C-PLit}}
  \AxiomC{l is a literal}
  \AxiomC{$fresh(i)$}
  \BinaryInfC{$\Gamma \vdash$ $l :: literal_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PParen}\quad}
  \AxiomC{$\Gamma \vdash$ $p :: c$}
  \UnaryInfC{$\Gamma \vdash$ $(p) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PInfixCon}}
  \AxiomC{$\Gamma \vdash$ $e_1 :: c_1$}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c_2$}
  \AxiomC{$\Gamma \vdash \oplus$ $:: c_1 \rightarrowtail c_2 \rightarrowtail c_3$}
  \TrinaryInfC{$\Gamma \vdash e_1 \oplus e_2 :: c_3$}
  \DisplayProof
\end{center}
\caption{\label{fig:pattern-inference-rules}Contracting rules for patterns.}
\end{figure}

Contracts for patterns are collected purely from the type source using the \code{ts} support function, which is used in the \code{C-PVar} and \code{C-PAs} contracting rules.
Let us go over the rules in figure \ref{fig:pattern-inference-rules}, except for \code{PCon}, which is the same as in Damas and Milner's work.

Please note that while our syntax contains a \code{PListR} data constructor, we use the two contracting rules \code{C-PCons} and \code{C-PNil} to describe its contracting behaviour. 
This is how the \code{PListR} constructor works behind the scenes.
We will follow this convention for all constructors that describe lists.

\begin{description}
	\item{\code{C-PHole} and \code{C-PWildcard} :} In both cases, a fresh contract is generated because a more specific contract cannot be provided.
	\item{\code{C-PVar} and \code{C-PAs} :} Because the type source may require a number of fresh contracts between $0$ and $n$, we ensure that we create sufficient fresh contracts. The pattern identifier $p$ is then passed to \code{ts} along with the fresh contracts, which generates the final contract for $p$.
	\item{\code{C-PNil} :} Because we know nothing about the inner or outer contract, we generate fresh $true$ contracts for both.
	\item{\code{C-PCons} :} In this case, we know about the contracts of the tail and head of the list. The inner contract of the list tail must be the same as the contract of the head of the list. The resulting contract is the same as the list tail.
	\item{\code{C-PTuple} :} For a tuple; we know about each contract of the tuple's members. We generate a nested bifunctor contract for tuples larger than 2, nesting in $c_2$ until we have accomodated every member of the tuple. For each bifunctor contract, we require a fresh contract for the outer contract, which means we require $n-1$ fresh contracts, $n$ being the size of the tuple.
	\item{\code{C-PLit} :} A pattern literal is given a fresh $literal$ contract.
	\item{\code{C-PParen} :} Parentheses simply copy the contract of the enclosed pattern.
	\item{\code{C-PInfixCon} :} An infix operator in Helium only supports two arguments, so the contracting rule is a slight variation of regular function application.
\end{description}

\begin{figure}[ht]
\begin{center}
  \RightLabel{\textsc{C-DHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-DEmpty}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $ :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-DFunBinds}}
  \AxiomC{$\Gamma \vdash$ $d :: c$}
  \UnaryInfC{$\Gamma \vdash$ $(d:ds) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-DPatBind}\quad}
  \AxiomC{$\forall{i}\in[0\ldots{n}]$ $fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $p = rhs :: ts(p,[true_0\ldots{true_n}])$}
  \DisplayProof
\end{center}
\caption{\label{fig:declaration-inference-rules}Contracting rules for declarations.}
\end{figure}

Figure \ref{fig:declaration-inference-rules} shows the contracting rules for declarations. The rules \code{C-DHole} and \code{C-DEmpty} are trivial, but the remaining two warrant a little more explanation:

\begin{description}
	\item{\code{C-DFunBinds} :} In this rule, we select the contract of the very first element of the list of function bindings and use that as the contract of the entire list. This makes sense because function bindings must have the same number of arguments and the same result, meaning that the contract is also the same.
	\item{\code{C-DPatBind} :} A pattern binding will look up its contract in the type source, in the same manner as \code{C-PVar}.
\end{description}

\begin{figure}[ht]
\begin{center}
  \RightLabel{\textsc{C-FBHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-FunBind}}
  \AxiomC{$\Gamma \vdash$ $ident :: c$}
  \UnaryInfC{$\Gamma \vdash$ $ident$ $ps = rhs :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:funbinds-inference-rules}Contracting rules for function bindings.}
\end{figure}

The contracting rules for function bindings in figure \ref{fig:funbinds-inference-rules} are straightforward: \code{C-FBHole} works as all others holes, and \code{C-FunBind} looks up the identifier in the contract environment and assigns that contract to the entire function binding.

\begin{figure}[ht]
\begin{center}
  \RightLabel{\textsc{C-Rhs}}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $e$ \textbf{where} $d :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-GRhs}}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $|$ $g = e$ \textbf{where} $d :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:rhs-inference-rules}Contracting rules for right-hand sides.}
\end{figure}

\begin{figure}[ht]
\begin{center}
  \RightLabel{\textsc{C-GExpr}}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $g$ $|$ $e :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:guardedexpr-inference-rules}Contracting rules for guarded expressions.}
\end{figure}

Right-hand side contracting rules (see figure \ref{fig:rhs-inference-rules}) are equally simple: the contract of $e$ is looked up in the contract environment and is used for the entire right-hand side.
The same is done for guarded expressions (figure \ref{fig:guardedexpr-inference-rules}).

\begin{figure}[ht]
\begin{center}
  \RightLabel{\textsc{C-Hole}\quad}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Feedback}\quad}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $e :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-MustUse}\quad}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $e :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Case}}
  \AxiomC{$\Gamma \vdash$ $m :: c_1$}
  \AxiomC{$\forall{i}\in[0\ldots{n}] \Gamma \vdash$ $p_i :: c_1$}
  \AxiomC{$\forall{i}\in{[0\ldots{n}]} \Gamma \vdash$ $e_i :: c_2$}
  \TrinaryInfC{$\Gamma \vdash$ \textbf{case} $m$ \textbf{of} \{${p_0 -> e_0; ...; p_n -> e_n}$\} $:: c_2$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Con}\quad}
  \AxiomC{$\Gamma(x) = c$}
  \UnaryInfC{$\Gamma \vdash$ $x :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-If}\quad}
  \AxiomC{$\Gamma \vdash$ $t :: c$}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \BinaryInfC{$\Gamma \vdash$ \textbf{if} $cond$ \textbf{then} $t$ \textbf{else} $e :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Lambda}\quad}
  \AxiomC{$\Gamma[x \mapsto c_1] \vdash$ $e :: c_2$}
  \UnaryInfC{$\Gamma \vdash$ $\ x -> e :: c_1 \rightarrowtail c_2$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Let}\quad}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c$}
  \UnaryInfC{$\Gamma \vdash$ \textbf{let x =} $e_1$ \textbf{in} $e_2 :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Lit}}
  \AxiomC{$l$ is a literal}
  \AxiomC{$fresh(i)$}
  \BinaryInfC{$\Gamma \vdash$ $l :: literal_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-App}\quad}
  \AxiomC{$\Gamma \vdash$ $e_1 :: c_2 \rightarrowtail c$}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c_2$}
  \BinaryInfC{$\Gamma \vdash$ $e_1$ $e_2 :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Paren}\quad}
  \AxiomC{$\Gamma \vdash$ $p :: c$}
  \UnaryInfC{$\Gamma \vdash$ $(p) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Tuple}\quad}
  \AxiomC{$\forall{i}\in{[0\ldots{n}]} \Gamma \vdash$ $e_i :: c_i$}
  \AxiomC{$fresh(j)$}
  \BinaryInfC{$\Gamma \vdash$ $(e_0, .., e_i) :: true_j \bifunctor (c_1, .., c_i)$}  
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Var}\quad}
  \AxiomC{$\Gamma(x) = c$}
  \UnaryInfC{$\Gamma \vdash$ $x :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Enum}\quad}
  \AxiomC{$fresh(i)$ $\Gamma \vdash$ $x :: c$}
  \AxiomC{$\Gamma \vdash$ $y :: c$}
  \AxiomC{$\Gamma \vdash$ $z :: c$}
  \TrinaryInfC{$\Gamma \vdash$ [$x$ .. ($y$) .. ($z$)] $ :: true_i \functor c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Cons}\quad}
  \AxiomC{$\Gamma \vdash$ $x :: c$}
  \AxiomC{$\Gamma \vdash$ $xs :: list \functor c$}
  \BinaryInfC{$\Gamma \vdash$ $(x : xs) :: list \functor c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Nil}\quad}
  \AxiomC{$fresh(i, j)$}
  \UnaryInfC{$\Gamma \vdash$ $[] :: true_i \functor true_j$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Neg}\quad}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $-e :: c$}
  \DisplayProof
  \vskip 0.5em
\end{center}
\caption{\label{fig:expr-inference-rules}Contracting rules for expressions.}
\end{figure}

Figure \ref{fig:expr-inference-rules} details the contracting rules for expressions, which have large overlaps with those for patterns.
Note how there is no rule \code{C-InfixApp}.
This is because infix function applications are converted to regular function applications before contract inferencing occurs.
As such, there is no need for such a rule.

Rules that are either trivial or similar to those of patterns are: \code{C-Hole}, \code{C-Feedback}, \code{C-MustUse}, \code{C-Lit}, \code{C-App}, \code{C-Paren}, \code{C-Tuple}, \code{C-Cons}, \code{C-Nil} and \code{C-Neg}.
The rest of the contracting rules are discussed hereafter.

\begin{description}
	\item{\code{C-Case} :} This rule describes contracting of a case statement for an arbitrary number of cases. The contract of the expression being evaluated, $m$, must be the same as the contracts of the patterns $p_i$, namely $c_1$. The contract of the entire case statement is $c_2$, which is the contract that is given to each alternative.
	\item{\code{C-If} :} Syntactic sugar for a boolean case statement. Like its generalized version, the contract of the entire statement is the same of each alternative, in this case $c$. 
	\item{\code{C-Lam} :} This contracting rule is the same as in Damas \& Milner's work.
	\item{\code{C-Let} :} A non-generalized let. This is not necessary because every contract variable is polymorphic in the global contract environment. 
	\item{\code{C-Enum} :} A list generator. $y$ and $z$ are fully optional, but if they are present, they must have the same contract as that of $x$, namely $c$. A fresh outer contract is generated to complete the final contract.
\end{description}

\begin{figure}[ht]
\begin{center}
  \RightLabel{\textsc{C-AHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-AltEmpty}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $ :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Alt}}
  \AxiomC{$\Gamma \vdash$ $rhs :: c$}
  \UnaryInfC{$\Gamma \vdash$ $p$ $\rightarrow$ $rhs :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:alternatives-inference-rules}Contracting rules for alternatives.}
\end{figure}

The contracting rules for alternatives in figure \ref{fig:alternatives-inference-rules} are quite simple. \code{C-AHole} and \code{C-AltEmpty} are trivial, and \code{C-Alt} takes the contract of the right-hand side as the contract of the entire alternative.

\section{Providing richer feedback}
\label{providingricherfeedback}
\todo{Might have to split some of this stuff up and move it to Approach and initial research}

\subsection{Modifications to typed-contracts}
\label{modificationstotypedcontracts}
In order to provide adequate feedback to the user, we modified the typed-contracts library by Jeuring et al to produce more specific feedback in a language that the user can understand.
The original library code provides error messages that refer to contract violations and (higher-order) blame of expressions, concepts that are foreign to the average user and thus do not provide any useful feedback.

Three modifications were made to the original library code.
Firstly, the Contract GADT was modified to include the PropInfo constructor, which takes an additional argument: a function that, given the position of which argument or result that the property is being applied to, returns an appropriate error message.

\begin{lstlisting}
type PosInfo = (Int,Int)
PropInfo   ::  (aT -> Bool) -> (PosInfo -> String) -> Contract aT
Prop       ::  (aT -> Bool) -> Contract aT
\end{lstlisting}

For example, the position (0,1) indicates the first argument of a function that has one argument.
The position (1,1) indicates the result of such a function.
Given this information, it is possible to generate a detailed error message.
Here is an example of an error message generated by the property that an integer must lie in the domain of the natural numbers, and which is applied at the first argument of a function: 

"The first supplied argument of this function does not fullfil the following property: the number must always be a natural number."

This form of feedback is richer than the default form and can be invoked in the message generation function if desired.
For example:

\begin{lstlisting}
isBiggerThan_prop = PropInfo (\x -> fromEnum x > 5 ) (\p -> mkErrorMsg p "the number must be larger than five.")

mkErrorMsg p text = posInfoText p ++ "does not fullfil the following property: " ++ text

posInfoText (pos,arity) | pos < arity  = "The " ++ showPos (pos+1) ++ " supplied argument of this function "
                        | pos == arity = "The result of this function "
                        | (pos,arity) == (-1,-1) = "An unknown position "

showPos p | p == 1 = "first"
          | p == 2 = "second"
          | p == 3 = "third"
          | p == 4 = "fourth"
          | p == 5 = "fifth"
          | p == 6 = "sixth"
          | otherwise = show p
\end{lstlisting}

Furthermore, two functions were added: 'assert''' and 'assertPos'.

'assert''' is a modified version of 'assert'' that records position information.
'assertPos' kickstarts this position information, filling in the arity of the entire contract:

\begin{lstlisting}
assertPos :: String -> String -> Contract aT -> aT -> aT
assertPos s pos c = assert'' c (0, ctrtarity c) (makeloc (Def (s ++ pos)))
 where
  ctrtarity :: Contract aT -> Int
  ctrtarity (Function c1 c2) = 1 + ctrtarity (c2 undefined)
  ctrtarity _                = 0
\end{lstlisting}

There may be situations, however, where using the position information is not necessary.
For example, position information may be recorded outside of the library and passed as a string to 'assertPos'.
Our generated code does this, as well as providing the user with a string representation of the value that triggered the offending contract by means of a call to 'show'.
But what about functions or infinite data structures? Calling 'show' on these will result in either an error or non-termination.
In these situations, it is be useful to use the recorded position information to be able to pinpoint the offending argument without having to resort to showing it.

At the moment, code is generated that assumes that every argument applied to a contracted function has a 'Show' instance. Because Quickcheck should not generate infinite structures (quite the contrary!), this seems to be a reasonable assumption.

'Show' instances for functions would still be required, but those can be provided:

\begin{lstlisting}
instance Show (aT :-> bT) where
	showsPrec a = showString "<function>"
\end{lstlisting}

\subsection{Code generation}
\label{codegeneration}

In section~\ref{codegeneration}, we discuss the details of the generation of contracted code.
This generated code produces detailed feedback messages composed of both dynamic and static information.

Generating such rich feedback is quite hard in the case of higher-order functions; how does one print the offending value if that value is a function?

One possibility is to include a string representation of each argument that is passed to a contracted function.
However, a string representation loses all notions of the original structure, which makes passing these values around in higher-order functions useless.
In a contracted higher-order function, one of the function arguments may fail to meet its contract and produce a contract violation.
For example, let's say we apply the map function to an appropriate function and the list [1,2,3].
Code is generated that replaces the original call with a contracted version of map, to which we pass the tuple ("[1,2,3]",[1,2,3]).
The contracted map function then applies its function argument to the first item in the list.
This list item causes a contract violation, but the only visual information we have available is a string representation of the entire list.
Clearly, this doesn't work.

A better approach is to dynamically show the value using the Show class, but this means we lose the ability to show functions.
We were able to do this previously because we statically generated a string representation during code generation.

While we are unable to say what function caused the contract violation in a higher-order function, we are able to indicate which arguments of both the higher-order function and the function argument failed.
We are able to use this information to still generate highly detailed feedback, as can be seen with this snippet of generated code:

\begin{lstlisting}
g f x = f x
\end{lstlisting}

becomes

\begin{lstlisting}
(fun (\ __x21 -> (fun (\ __x22 -> __final_g (\ a0 -> (appParam __x21 (concat "the application of the higher-order function 'g' ",(generatePositionData posinfo),". g has a function as its first argument."," The first argument of that function",", namely ",show a0]) a0)) __x22))))
\end{lstlisting}

Note how the arguments to the function argument \_\_x21 are applied with a very detailed feedback message.
In the case that a contract violation occurs at that position, the feedback could look like this:

A part of your code, or a supplied argument to a function, does not fullfil a required property. This occurred at the application of the higher-order function 'g' at line number 1, column number 1. g has a function as its first argument. The first argument of that function, namely -5, does not fulfill the following property: the number must always be a natural number.

From this feedback, the user can deduce the following:
\begin{itemize}
\item Which application of a higher-order function caused the contract violation.
\item Which argument of the higher-order function is the function that caused the contract violation.
\item Which argument of that function caused the violation.
\item Possibly, the offending value.
\end{itemize}

\subsection{Reusing QuickCheck properties}

The Ask-Elle programming tutor supports QuickCheck properties that are executed to verify the correctness of code that cannot be reduced to a known strategy.
A very interesting idea is to derive contracts from such properties automatically and use them to construct contracts that can be used to contract the result of the function.
However, remember that we are limited to non-dependent contracts, so we only have access to a single argument or the result of the function in a contract.
Most QuickCheck properties, however, refer to one or more arguments of the function.

A simple QuickCheck property of the palindrome function illustrates the problem well:

\begin{lstlisting}
prop_Main = \xs -> whenFail (putStrLn "This function does not correctly check for palindromes.") 
 ( (palindrome xs) == (reverse xs == xs) )  
\end{lstlisting}

The input xs must be captured with a dependent contract before it can be referred to.
This means that we are unable to derive a contract useful for contract inferencing.

The only QuickCheck properties that are of use to us to derive a contract from, are properties that only refer to the result of the function.
For these kinds of properties, we can construct a contract of the following form:

\begin{lstlisting}
Prop (\result -> ...)
\end{lstlisting}

As you can see, we are severely limited in the the range of properties that we can use.
For this reason, we do not further develop a contract deriving mechanism for QuickCheck properties.
 
\todo {Explain how we can't use QuickCheck properties that are predefined for many Ask-Elle exercises. It had to do with how QuickCheck properties may require dependent contracts if it takes more than a single input.}

\section{Code Generation}
\label{codegeneration}

\review

Now that we have inferenced contracts for every function application, we can generate contracted code.

We go over the AST again and for every function definition X, we generate the following new functions:

\_\_contracted\_X
\_\_app\_X
\_\_final\_X

These functions ensure that all function calls are contracted. Let us go over what each one does.

\subsection{\_\_contracted\_X}
This function calls the assertPos function of the typed-contracts library, will dynamically assert the contract provided to it.


Let us look at the template:

\begin{lstlisting}
__contracted_X ctrt posinfo = assertPos [function info] (generatePositionData posinfo) ctrt funs
  where funs = [contracted function definition]
\end{lstlisting}

A generated function takes two arguments, ctrt and posinfo.
ctrt is a Contract that is passed to the assertPos function. 
Different function calls can thus have differing contracts assigned;
in other words, the generated function is polymorphic in its contract.

posinfo is simply a tuple of the line and column position of a function call, and is used to generate specific feedback at runtime if there is a contract violation.

There are two placeholders that are replaced during code generation:
the placeholder [function info] is replaced by a string that informs the user what kind of function violated its contract.
Two examples of such generated messages are:

"At the application of the higher-order function 'foldr'"
"At the application of the function 'insert'"

The other placeholder, [contracted function definition], is replaced by a contracted version of the original function.
For example, a contracted version of the identity function looks like this:

\begin{lstlisting}
fun (\__x01 -> __final_id __x01)
\end{lstlisting}

For each argument, an extra layer of fun is applied to capture them and make them available to the original function.

A higher-order argument requires a bit more work, as it itself must be contracted before being passed to the original function.
For example,

\begin{lstlisting}
g f x = f x
\end{lstlisting}

will generate the following replacement for the [contracted function definition] placeholder:

\begin{lstlisting}
(fun (\ __x21 -> (fun (\ __x22 -> __final_g (\ a0 -> (appParam __x21 (concat "the application of the higher-order function 'g' ",(generatePositionData posinfo),". g has a function as its first argument."," The first argument of that function",", namely ",show a0]) a0)) __x22))))
\end{lstlisting}

The \_\_contracted version of a function is referenced in the \_\_app version, which we will review next.

\subsection{\_\_app\_X}

This function captures information for use in feedback, wraps it appropriately, and passes it to the \_\_contracted version of the function.

Again, let us first examine the template:

\begin{lstlisting}
__app_X ctrt posinfo [argument patterns] = [applied arguments]
\end{lstlisting}

The arguments ctrt and posinfo appear here again: both are passed to the \_\_contracted version of the function. Note again that this generated function is polymorphic with respect to its contract.

The placeholders [argument patterns] and [applied arguments] are relatively simple.

[argument patterns] generates a triple for each argument, which contains a string representation of the argument, the position of the argument, and the argument itself.

[applied arguments] uses this extra information to provide richer feedback at runtime and applies the arguments to the contracted version of the function.

Let us revisit a previous example:

\begin{lstlisting}
g f x = f x
\end{lstlisting}

will generate the following code:
\begin{lstlisting}
__app_g ctrt posinfo (posa,a) (posb,b) =
 appParam (appParam (__contracted_g ctrt posinfo) (show a ++ generatePositionData posa) a) (show b ++ generatePositionData posb) b
\end{lstlisting}

The contracted version of the function is fed arguments using appParam, and are accompanied by feedback strings containing the argument as a string and its position in the source code.

\subsection{\_\_final\_X}

Lastly, this generated function ties everything together by transforming the original function definition, replacing normal function calls with their contracted equivalents.

For example, the foldr function is transformed into the following:

\begin{lstlisting}
__final_foldr f b (x:xs) = f x (__app_foldr [ctrt] [pos] (_,f) (_,b) (_,xs))
__final_foldr f b [] = b
\end{lstlisting}

We leave out the generated information for brevity.

Note how the recursive call is also contracted, and how f can consume its arguments in the normal manner while being a contracted function itself.

What about function applications that have higher-order arguments?

In those cases, the higher-order argument is not replaced with a call to its \_\_app version, but with a call to its \_\_contracted version.
For example, the expression

\begin{lstlisting}
foldr insert [] [5,4,7,0,10]
\end{lstlisting}

will generate the following \_\_final version:

\begin{lstlisting}
__app_foldr (_,_,__contracted_insert [ctrt] [pos]) (_,[]) (_,[5,4,7,0,10])
\end{lstlisting}

This expression is a good example of what the user will provide.
Of course, if the user provides a partially applied function, there is not much that can be done, in the same manner as the uncontracted version of the code.

\chapter{Discussion and future work}
\label{futurework}

\section{Using paramorphisms to tackle dependent contracts}
Johan Jeuring provided a wonderful idea to be able to run contract inferencing on some catamorphisms with dependent contracts by converting them to a paramorphism, which is a catamorphism that provides its function argument with the original input as well:

\begin{lstlisting}
para  :: (a -> [a] -> b -> b) -> b -> [a] -> b
foldr :: (a ->        b -> b) -> b -> [a] -> b

para  c n (x : xs) = c x xs (para c n xs)
foldr c n (x : xs) = c x    (foldr c n xs)
para  c n []       = n
foldr c n []       = n
\end{lstlisting}
\todo{Courtesy of pigworker, http://stackoverflow.com/questions/13317242/what-are-paramorphisms}

This functionality is of great use for dependent contracts that need access to the original argument, as can be seen in the following example code (courtesy of Johan Jeuring):

\begin{lstlisting}
-- GList      ::  Contract aT -> ([aT] -> Bool) -> Contract [aT]
sortc =  GList int (const True) >-> \xs -> GList int (\r -> nonDesc r && isPerm xs r)
isPerm xs ys = null (xs \\ ys)

sort_perm'         :: Ord a => [a] -> [a]
sort_perm'         =  foldr insert_notPerm []
insert_notPerm ::  Ord a => a -> [a] -> [a]
insert_notPerm x []                    =  [x]
insert_notPerm x (y:ys)  |  x <= y     =  x:y:ys
                         |  otherwise  =  insert_notPerm x ys
                         
sort_permWrong        =  foldr insert_notPerm [] 
sort_permNotViolated  =  assert sortc sort_permWrong [3,2,4]
\end{lstlisting}

In the above example the input, \code{xs}, is needed in the \code{sortc} contract to be able to express the permutation property, but this introduces a dependent contract, which means the contract cannot be used for contract inferencing.

This is where the paramorphism comes in, as it provides that \code{xs} value.
The contract for the \code{para} function is, then:

\begin{lstlisting}
parac
  :: Contract aT
     -> ([aT] -> Bool)
     -> ([aT] -> Contract bT)
     -> Contract ((aT -> [aT] -> bT -> bT) -> bT -> [aT] -> bT)
parac aT p bT =   (aT >-> \x -> GList aT p >-> \xs -> bT xs >- bT (x:xs))
              >-  bT []
              >-  GList aT p
              >-> \xs -> bT xs
              
psort  =  para (\x xs ys -> insert_correct x ys) []
\end{lstlisting}

Unifying \code{sortc} and \code{parac} gives us:

\begin{lstlisting}
GList aT  p             >->  \xs -> bT xs
GList int (const True)  >->  \xs -> GList int (\r -> nonDesc r && isPerm xs r)

aT  :=  int
p   :=  const True
bT  :=  \xs -> GList int (\r -> nonDesc r && isPerm xs r)
\end{lstlisting}

Applying these substitutions, we see that \code{bT []} will get the contract:  

\begin{lstlisting}
GList int (\r -> nonDesc r && isPerm [] r)
\end{lstlisting}

And the contract for \code{insert} becomes:

\begin{lstlisting}
insertc'  =    int 
          >->  \x  -> GList int (const True) 
          >->  \xs -> GList int (\r -> nonDesc r && isPerm xs r)
          >-   GList int (\r -> nonDesc r && isPerm (x:xs) r)
cinsert_notPerm_violated = assert insertc' (\x xs ys -> insert_notPerm x ys) 3 [2,4] [2,4]
\end{lstlisting}

Note that by using a paramorphism instead of a catamorphism, \code{insert} is supplied with an argument it does not require, so it is wrapped in a lambda function and the superfluous argument is ignored.

How do we relate this contracted paramorphism to the original user's \code{foldr} call?
By defining \code{foldr} as a paramorphism, which is quite simple:

\begin{lstlisting}
pfoldr f e = para (\x xs r -> f x r) e
sort_perm''        =  pfoldr insert_notPerm []
sort_permViolated' =  assert sortc' sort_perm'' [3,2,4]
\end{lstlisting}

In short, this implies it is possible to convert some functions that use catamorphisms with dependent contracts, into paramorphisms with non-dependent contracts.

Some feedback problems do pop up: how do we meaningfully inform the user of a violated contract in  \code{(\textbackslash x xs r -> f x r)} ? 
And what if the \code{para} contract is violated, how do we report that?
It is possible to modify the feedback messages in contract generation to "cloak" the use of a paramorphism, but this has not yet been investigated further.


\end{document}
