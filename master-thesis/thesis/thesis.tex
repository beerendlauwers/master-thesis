\documentclass[10pt]{report}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[numbers]{natbib}
\usepackage{bussproofs}
\usepackage{color}
\usepackage{listings}
\usepackage{ amssymb }
\usepackage{courier}
\usepackage[pdftex]{graphicx}
\lstset{language=Haskell}
\lstset{breaklines=true}
\lstset{basicstyle=\scriptsize\sffamily}
\lstset{frame=single}
\lstset{showstringspaces=false}
\lstset{captionpos=b}
\usepackage{url}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{pdfpages}

\usepackage{attrib}
\usepackage{framed}

\newcommand{\functor}{<\!\!\!@\!\!\!>}
\newcommand{\bifunctor}{<\!\!\!@\!\!@\!\!\!>}

\newcommand{\W}{$\mathcal{W}$}
\newcommand{\CW}{$\mathcal{CW}$}
\newcommand{\CHW}{$\mathcal{CHW}$}

\newcommand{\sref}[1]{Section~\ref{#1}}
\newcommand{\annotate}[3]{
	\begin{scriptsize}
	\textcolor{#1}{\textbf{#2}~\textit{#3}}
	\end{scriptsize}\newline}
\newcommand{\todo}[1]{\annotate{red} {TODO:} {#1}}
\newcommand{\review}{\annotate{blue} {REVIEW:} {Please review the following text. \newline}}

\newcommand{\explain}[1]{\quad\{\;\text{#1}\;\}}
\newcommand{\justify}[1]{\quad\{\;\text{#1}\;\}}
\newcommand{\johan}[1]{[\textit{Johan says:}~#1]}
\newcommand{\augusto}[1]{[\textit{Augusto says:}~#1]}


\definecolor{light-gray}{gray}{0.95}
\newcommand{\code}[1]{%
  {% open a group for a local setting
   \setlength{\fboxsep}{-2\fboxrule}% the rule will be inside the box boundary
   \fcolorbox{black}{light-gray}{\hspace{1.5pt}\strut\texttt{#1}\hspace{1.5pt}}% print the box, with some padding at the left and right
  }% close the group
}

\author{
	Beerend Lauwers\\
	Utrecht University, The Netherlands}
\date{\today}
\title{Embedding Contract Inferencing for Functional Programs In Ask-Elle}
\begin{document}

\maketitle


\chapter{Abstract}
\todo{Finish up abstract}
Ask-Elle is a programming tutor created by Alex \citet{Gerdes:2012:phd} for his PhD Thesis. It utilizes (transformations of) model solutions to provide feedback to students on their progress.
However, if a student's program cannot be reduced to such a model solution, providing helpful feedback becomes hard to do. 
The Master Thesis of Jurri\"en \citet{Stutterheim:2013:thesis} focuses on the development of a contract inferencing system for functional programs, with the goal to embed this functionality in the Ask-Elle programming tutor, so as to provide a new source of meaningful feedback to students using the tutor.
In the "Future Work" section of the thesis, Stutterheim notes that the actual integration of the contract inferencing system in Ask-Elle still remains to be done.
This research proposal explores what needs to be done in order to attain that goal, as well as the effects it would have upon the tutor's capability to provide meaningful feedback.

\tableofcontents

\chapter{Introduction}
\todo{Talk about Ask-Elle and Jurriens work}
In this thesis, we extend the contract inferencing system developed by Jurri\"en Stutterheim and integrate it with the Ask-Elle programming tutor.

There are three main parts to this thesis:
firstly, the modifications to the original contract inferencing system are discussed and implemented. Secondly, code generation of contracted code is explained; Thirdly, the integration with the Ask-Elle programming tutor is laid out and developed.

\chapter{Problem description}
\section{Research question}
Having embedded contract inferencing in Ask-Elle, does this new functionality provide students with more detailed feedback than without?
Three main research goals are set up to achieve this.

\begin{description}
	\item{\textbf{Goal one}} Embed the contract inferencing system as described in Stutterheim's thesis.
	\item{\textbf{Goal two}} Perform tests with students to check if the newly-implemented functionality adds value to the provided feedback.
	\item{\textbf{Goal three}} Analyze the testing results and report our findings.
\end{description}

\subsection{Goal One: Embedding the contract inferencing system}


Figure depicts an overview of the steps involved in using the contract inferencing system.
The blue dashed-dotted arrows and boxes represent functionality that is not yet present in Ask-Elle, but is required for the contract inferencing system to be of use.
Let us step through the system and inspect the goals and requirements of each element in more detail.

Currently, if conventional 'diagnosis' of the student program fails, a QuickCheck example is generated, after which it is displayed to the user (this arrow is not shown).
Alongside the counterexample, the AST of the student program must be generated such that it can be used by the contract inferencing system.
The ASTs used by the Ask-Elle programming tutor and the contract inferencing system differ; Ask-Elle uses Helium as its back-end for Haskell, and Algorithm CW is based upon a small lambda language. So the first step towards embedding the system will be:

\begin{description}
	\item{\textbf{Step 1}} Modify and extend Algorithm CW to accept the AST generated by Ask-Elle, and embed it in Ask-Elle.
\end{description}

Initial work of this step has already been undertaken by research assistants (\todo{Who?}).
After completing Step 1, it should be possible to infer a contract for any arbitrary AST generated by Ask-Elle.

The next step is to use the contract-typed AST to generate an error message.
There are two ways of doing this:

\begin{enumerate}
	\item Use the QuickCheck-provided counterexample to transform the contract-typed AST directly, and then convert it back to an executable program and run it. We suspect that this functionality will be required for dependent function contracts.
	\item Convert the contract-typed AST back to an executable program immediately, and apply the counterexample to it.
\end{enumerate}

Replacing parts of the contract-typed AST with a counterexample was touched upon in Stutterheim's thesis, but an automated way of determining what should be replaced and where does not seem to be available.
Hence, this  is the next step:
\begin{description}
	\item{\textbf{Step 2}} Investigate an automated way of modifying the contract-typed AST with a counterexample, and implement this functionality.
\end{description}

After (not) modifying the contract-typed AST, it must be converted back into an executable program.
We assume the Helium-compiler has a way of feeding it an AST and returning an executable program.
However, keeping the well-known saying about assumptions in mind, we will have to investigate further:

\begin{description}
	\item{\textbf{Step 3}} Investigate if it is possible to feed a contract-typed AST to the Helium compiler. If not, investigate if this functionality can be implemented.
\end{description}

If all has gone well, we should end up with an error message generated by the Helium compiler, caused by a contract violation.
However, returning this error message to the student will not result in useful feedback.
Therefore, we must transform the error message by replacing the details of the contract violation with those of the function wrapped by the violated contract.
This transformed error message will be returned to the student. The final step of this subsection, then, is as follows:

\begin{description}
	\item{\textbf{Step 4}} Implement an error message transformer that "cleans up" the generated error message so it is understandable by the student, and feed it to the Ask-Elle feedback mechanism.
\end{description}

\subsection{Goal Two: Perform testing with students}

In August, Utrecht University hosts an Applied Functional Programming summer school.
This summer school course specifically targets students and participants who are not yet very knowledgeable about functional programming in general, and Haskell in particular.
This is an excellent opportunity to test the functionality described in Goal One.
Let us again go through each step that must be taken to complete this goal.

The first step is relatively simple, but nonetheless crucial:

\begin{description}
	\item{\textbf{Step 1}} Organize the practical aspects of the testing on time. Contact the coordinators of the summer school and request a time slot during which testing can take place.
\end{description}

After that, we must provide two versions of the Ask-Elle tutor: one with the new contract inferencing system embedded, and the original, unmodified one.
We require two versions to perform a simple A/B test: for each exercise, a version of Ask-Elle is randomly selected and presented to the student.
Thus, we require a way to randomly serve one of the versions to a student:

\begin{description}
	\item{\textbf{Step 2}} Prepare two versions of the Ask-Elle tutor, and set up access in such a way that, for each exercise, one of the versions is randomly served to the student.
\end{description}

After completing an exercise in Ask-Elle (there are around fifteen exercises in total), the student will fill out a very small survey if he or she encountered feedback containing a counterexample.
The feedback will be shown above the survey.
The following questions will then be visible below the feedback:

\fbox {
    \parbox{\linewidth}{
For each question, please mark the circle that corresponds with your opinion.
\begin{enumerate}
	\item The feedback above provided me with sufficient information to help me find the mistake in my code. \newline
[Strongly disagree] 0 - 0 - 0 - 0 - 0 [Strongly agree]
	\item The feedback above should indicate a more specific part of the code.\newline
[Strongly disagree] 0 - 0 - 0 - 0 - 0 [Strongly agree]
\end{enumerate}
    }
}

As this survey is quite small, it could be made multi-lingual if this makes students more inclined to take part in the survey.

With the results of these surveys, we are able to discern which version of Ask-Elle students prefer when they encounter feedback containing a counterexample.

So, our final steps for this goal are:

\begin{description}
	\item{\textbf{Step 3}} Build a small survey system that acquires any feedback containing a counterexample from the Ask-Elle tutor and presents the survey mentioned above, then writes the answers back to a database.
	\item{\textbf{Step 4}} Test the entire system beforehand, and ensure it is operational for use by the students.
	\item{\textbf{Step 5}} Collect survey results.
\end{description}

\subsection{Goal Three: Analyze the testing results and report findings}

Having collected the survey results, all that remains to be done is to analyze them and determine if the embedding of the contract inferencing system in Ask-Elle has increased the usefulness of feedback containing a counterexample provided to students, or not:

\begin{description}
	\item{\textbf{Step 1}} Analyze the survey results to answer the research question.
\end{description}

After processing the results, we will present our findings in a presentation, as is customary:

\begin{description}
	\item{\textbf{Step 2}} Report findings and problems encountered / lessons learned during this thesis in a presentation.
\end{description}

\chapter{Background}

\review

In this chapter, we will familiarize the reader with some concepts that will be used in the rest of this thesis, the most important ones being contracts and the notion of inferring types and contracts.

This thesis concerns itself with contract inferencing.
Let us break up these terms and investigate them thoroughly before moving on.

\section{Contracts}
In programming, a $contract$ is very much like its real-world counterpart: it stipulates prerequisites and guarantees between two parties.
In our case, the parties are the function being called (the $callee$) and the function receiving the result (the $caller$).

As a simple example, one could specify a contract that a function will only accept a natural number: a prerequisite.
Likewise, it is possible to state that a function must also always return a natural number: a guarantee.
By combining prerequisites and guarantees for arguments and results, respectively, it is possible to construct very specific contracts that are quite useful for tracking down bugs.
Just like in real life, these contracts can be violated, which will halt the program with an exception detailing which contract was violated at what position in the code.

When this happens, blame must be assigned.
A prerequisite violation is to be blamed on the $caller$: it was this function that should have provided a valid argument.
Likewise, a guarantee violation is to be blamed on the $callee$: there is a fault in the function being called that causes it to return an invalid result.

In other words, adding contracts to one's code adds an element of automated testing and aids in debugging any faults that may arise by being able to specify what exactly went wrong, and where.

This thesis builds upon the thesis of Stutterheim \cite{Stutterheim:2013:thesis}, who developed an algorithm for contract inferencing on a simple recursive let lambda language with support for holes.
While Stutterheim's contract grammar is library-agnostic, he chose to generate code for the 'typed-contracts' library by Hinze et al. \cite{Hinze06typedcontracts}. 
Also of interest is the library by Chitil \cite{Chitil:2012ua}, which is based on the work of Hinze et al.

\subsection{The 'typed-contracts' library}
Let us examine the library for which code will be generated.
Contracts in the 'typed-contracts' library are of the same shape as the type of the function that it being defined for.
This makes it possible to go over the type and generate a generic contract for a function, a capability that will be of great use during contract inferencing.
But we are getting ahead of ourselves; let us first look at a few simple examples of function contracts.

The very first example is the one we used when first introducing the concept of contracts, namely a contract that constrains a function such that it demands a natural number as its input, and the guarantee that it will return a natural number, too:

\begin{lstlisting}[mathescape]
natInNatOut :: Contract (int $\rightarrowtail$ int)
natInNatOut = nat $\rightarrowtail$ nat
\end{lstlisting}

We need a way to attach this contract to such a function, which is what the \code{assert} function is for:

\begin{lstlisting}[mathescape]
increase :: Int $\rightarrow$ Int
increase = assert natInNatOut (\n $\rightarrow$ 1 + n)
\end{lstlisting}

Note how the type of \code{increase} does not reflect the constraints imposed by the contract, because the contract is asserted at runtime.
An advantage of this is that the contracted version of a function can replace its regular version without issue.
In other words, the \code{assert} function acts as a partial identity function, because it either raises an exception during contract violation, or it returns the constrained value unmodified.
This behaviour is clearly reflected in the type of \code{assert}:

\begin{lstlisting}[mathescape]
assert :: Contract a $\rightarrow$ (a $\rightarrow$ a)
\end{lstlisting}

Hinze et al. define the \code{Contract} type using a GADT:

\begin{lstlisting}[mathescape]
data Contract aT where
   Prop      ::  (aT -> Bool) -> Contract aT
   Function  ::  Contract aT -> (aT -> Contract bT) -> Contract (aT >-> bT)
   Pair      ::  Contract aT -> (aT -> Contract bT) -> Contract (aT, bT)
   List      ::  Contract aT -> Contract [aT]
   Functor   ::  Functor f => Contract aT -> Contract (f aT)
   Bifunctor ::  Bifunctor f => Contract aT -> Contract bT -> Contract (f aT bT)
   And       ::  Contract aT -> Contract aT -> Contract aT
\end{lstlisting}

Let us go over each data constructor:
\begin{description}
	\item{\code{Prop} } is what one uses to actually define a constraint or property on a value. Given a function that expects a value of type \code{aT} and which returns a Boolean, it produces a contract for something of type \code{aT}. In other words, it lifts a function to a contract.
	\item{\code{Function} } is used to define a dependent function contract.
	\item{\code{Pair} } similarly defines a dependent pair contract.
	\item{\code{List} } is straightforward: it lifts contracts to the list level.
	\item{\code{Functor} } is a container that can house types of kind * -> *.
	\item{\code{Bifunctor} } is the same as \code{Functor}, but takes types of kind * -> * -> * into account.
	\item{\code{And} } is used to chain several contracts together: all of them are asserted when a value is provided. 
\end{description}

Now that we know how a \code{Contract} is constructed, let us see how it is applied, or asserted, to a compatible value by examining the definition of \code{assert}.
Note that we will simplify the definition somewhat, leaving out arguments pertaining to location information.

\begin{lstlisting}[mathescape]
assert ::  Contract aT $\rightarrow$ (aT $\rightarrow$ aT)

assert (Prop p)         a   = if p a then a else error "contract failed"

assert (Function c$_1$ c$_2$) f	    = ($\lambda$x $\rightarrow$ (assert (c$_2$ x) . f) x) . assert c$_1$

assert (Pair c$_1$ c$_2$) (a$_1$,a$_2$)     = ($\lambda$a$'_1 \rightarrow$(a$'_1$,assert (c$_2$ a$'_1$) a$_2$)) (assert c$_1$ a$_1$)

assert (List c)         as  = map (assert c) as

assert (Functor f)      as  = fmap (assert f) as

assert (Bifunctor c$_1$ c$_2$) as   = bimap (assert c$_1$) (assert c$_2$s) as

assert (And c$_1$ c$_2$)        a   = (assert c$_2$ . assert c$_1$) a
\end{lstlisting}

Let's go over each pattern match to understand what happens:

\begin{description}
	\item{\code{Prop} :} When asserting a property, we apply the predicate to the supplied value. If the predicate holds, this function acts as the identity function. If it does not hold, however, an exception is raised. In the unabridged code, the exception message also includes the position of the violation in the source code.
	\item{\code{Function} :} For a \code{Function} contract, we first assert $c_1$ on the input of the function $f$. If this assertion holds, we pass the value $x$ to $f$, as can be seen in the lambda function. The result of $f x$ is then used to assert the codomain of the function using $c_2$.
	\item{\code{Pair} :} Similarly, the \code{Pair} contract first asserts the contract $c_1$ to the first element in the pair. Provided it succeeds, the first element is passed to $c_2$. The resulting contract $(c_2$ $a'_1)$ is then used to assert the second element of the pair.
	\item{\code{List}, \code{Functor}, \code{Bifunctor} :} These are all quite similar. The contract to be asserted is mapped over the elements of a container.
	\item{\code{And} :} This contract is used to combine two contracts, so asserting one implies that both contracts hold on the provided value.
\end{description}

Now that we know how contracts are constructed and asserted, let us look at some convenience functions that will be used throughout this thesis:

\begin{lstlisting}[mathescape]
c$_1$ $\rightarrowtail$ c$_2$		= Function c$_1$ (const c$_2$)
(&)		= And
c$_1$ $\functor$ c$_2$		= c$_1$ & Functor c$_2$
c$_1$ $\bifunctor$ (c$_2$,c$_2$)	= c$_1$ & Bifunctor c$_2$ c$_3$
\end{lstlisting}

The first definition allows us to define a non-dependent function contract, and the second is some simple syntactical sugar.
The last two definitions merit some more detail.
Along with (a) contract(s) for the elements of a container, a contract for the container in its entirety is provided as well in the form of $c_1$.
A simple example why this is useful, is the guarantee that a list is sorted when it is returned by a sorting function.
Such a property cannot be captured by any contract for a container's elements, as these elements only know about themselves, and not about other elements in the container.
Therefore, we require container-wide contracts, which are also called "outer contracts".
Conversely, contracts for a container's elements are referred to as "inner contracts".

With these functions, we can easily describe complex contracts.
Let us look at an example.
First, we define two fundamental contracts, namely \code{true} and \code{false}, which always succeed and always fail, respectively, regardless of its input:

\begin{lstlisting}[mathescape]
true, false :: Contract aT
true  = Prop ($\lambda$_ $\rightarrow$ True)
false = Prop ($\lambda$_ $\rightarrow$ False)
\end{lstlisting}

Let us construct a few contracts for the \code{head} function that will not raise an exception.
The very first contract is simply the \code{true} contract itself, which will take the entire \code{head} function as an argument.
But the contract could be made more specific:

\begin{lstlisting}[mathescape]
true $\rightarrowtail$ true :: Contract (aT $\rightarrowtail$ aT)
\end{lstlisting}

In this case, the \code{true} contract is asserted on both the input and output of the \code{head} function, but no longer on the function in its entirety.
We can make it even more specific:

\begin{lstlisting}[mathescape]
(true $\functor$ true) $\rightarrowtail$ true :: Contract ([aT] $\rightarrowtail$ aT)
\end{lstlisting}

Using the functor contract $\functor$, the \code{true} contract is asserted on the input list in its entirety, as well as each of its elements, along with the output of the function.

Up until now, we've only used the \code{true} contract.
But we can also use contract variables to express relations between the input and output of a function. 
A further refinement of the contract for \code{head} exemplifies this:

\begin{lstlisting}[mathescape]
(c$_{out}$ $\functor$ c$_{in}$) $\rightarrowtail$ c$_{in}$ :: Contract ([aT] $\rightarrowtail$ aT)
\end{lstlisting}

It makes sense that the element that is extracted from the list still obeys the contract $c_{in}$.
With this knowledge, let us look at a higher-order example: \code{fmap}.
By using the functor contract again, we can define a contract for \code{fmap}:

\begin{lstlisting}[mathescape]
(c$_1$ $\rightarrowtail$ c$_2$) $\rightarrowtail$ (c$_3$ $\functor$ c$_1$) $\rightarrowtail$ (c$_4$ $\functor$ c$_2$)
\end{lstlisting}

Note how the contract variables of the contract are very similar to the type variables of the type of \code{fmap}:

\begin{lstlisting}[mathescape]
fmap :: (a $\rightarrow$ b) $\rightarrow$ f a $\rightarrow$ f b
\end{lstlisting}

The contract variables $c_1$ and $c_2$ correspond to type variables $a$ and $b$, respectively.
Generally, we cannot perform such a mapping over containers, so they are assigned different contract variables: $c_3$ and $c_4$.
During a process called inferencing, it may turn out that these variables are equal, but this information is usually not deducible from the function's type.

Section \ref{background-inferencing} will explain the concept of inferencing and its use in refining contracts even further.

\section{Contract inferencing}
\label{background-inferencing}

In computer science, the notion of \textit{inference} most often refers to the method of \textit{type inferencing}, which automatically deduces types for expressions written in a programming language.

For functional programs, the Hindley-Milner type inferencing system described by Damas and Milner \cite{Damas:1982ve} is the most well-known.
The thesis of Stutterheim \cite{Stutterheim:2013:thesis} builds upon this system, producing an algorithm for deducing \textit{contracts} from expressions written in a simple let-polymorphic lambda calculus.

\subsection{Goals of contract inferencing}
Stutterheim set out three goals for his contract inferencing system, shown in figure \ref{fig:goals-stutterheim-contract-inferencing}.

\begin{figure}[htps]
\begin{framed}
\begin{center}
\begin{itemize}
	\item Infer a well-typed contract for every function in a program
	\item Inferred contracts must allow a (non-strict) subset of the values allowed
by the types
	\item The most general inferred contract must never fail an assertion
\end{itemize}
\end{center}
\end{framed}
\attrib{{\em{Contract Inferencing for Functional Programs}}, page 12}
\caption{\label{fig:goals-stutterheim-contract-inferencing}Stutterheim's goals for contract inferencing.}
\end{figure}

The first goal describes the notion of a \textit{fully contracted} expression: every function application is provided with a contract that can be used to assert it.
The second goal is sensible: any values constrained by the contract of an expression should be a subset of the inhabitants of the type of that expression.
Lastly, the third goal implies that asserting any inferred contract is equal to the identity function.

\subsection{Language used}

The contract inferencing algorithm works on $\lambda_c$, a let-polymorphic lambda calculus:

\begin{figure}[htps]
\begin{lstlisting}[mathescape]
$expr$      ::=   x				-- Variable
        |   $\lambda$$expr$ $\rightarrow$ $expr$				-- Lambda abstraction
        |   $expr$ $expr$				-- Application
        |   let $expr$ = $expr$ in $expr$			-- Let binding
        |   case $expr$ of			-- Case block
              { $expr$ $\rightarrow$ $expr$ (; $expr$ $\rightarrow$ $expr$)* }
        |   $const$				-- Constants
        |   $expr$ : $expr$				-- List cons constructor
        |   []				-- List nil constructor
        |   Just $expr$			-- Maybe Just constructor
        |   Nothing			-- Maybe Nothing constructor
        |   ($expr$, $expr$)			-- Pair
        |   Left $expr$			-- Either left constructor
        |   Right $expr$			-- Either right constructor
        |   $expr$ $\oplus$ $expr$				-- Binary operation
        |   ?				-- Holes


$const$      ::=   n				-- Integers
        |   b				-- Booleans
        |   c				-- Characters
        |   s				-- Strings
\end{lstlisting}
\caption{The $\lambda_c$ language.}
\end{figure}

\subsection{Contract grammar}

Contracts are generated in an intermediate language-agnostic grammar, which can be converted to library-specific contracts (figure \ref{fig:stutterheim-intermediate-contract-grammar}).

\begin{figure}[htps]
\begin{center}
\begin{lstlisting}[mathescape]
  -- Contracts
  c ::=  $\rho_{\alpha}$			-- User-defined concrete contract
      |  $true_{\alpha}$			-- true contract
      |  $false_{\alpha}$			-- false contract
      |  $c_{\alpha} \rightarrowtail c_{\beta}$			-- Function contracts
      |  $c_{\alpha} \functor c_{\beta}$			-- Functor contracts
      |  $c_{\alpha} \bifunctor (c_{\beta}, c_{\gamma})$			-- Bifunctor contracts
      |  $int_{\alpha}$			-- Succeeds for all integers
      |  $bool_{\alpha}$			-- Succeeds for all booleans
      |  $char_{\alpha}$			-- Succeeds for all characters
      |  $string_{\alpha}$			-- Succeeds for all strings
      |  $list_{\alpha}$			-- Succeeds for all lists
      |  $either_{\alpha}$			-- Succeeds for all $Either$s
      |  $maybe_{\alpha}$			-- Succeeds for all $Maybe$s
      |  $pair_{\alpha}$			-- Succeeds for all pairs
  -- Contract schemes
  $\sigma$ ::=  $c$			-- Contract
      |    $\forall{true_{\alpha}}.\sigma$			-- Universal quantification for contract 
				-- indices
\end{lstlisting}
\end{center}
\caption{\label{fig:stutterheim-intermediate-contract-grammar}Intermediate grammar for the contracts.}
\end{figure}

We have already seen some examples of user-defined contracts as well as the definitions of the \code{true} and \code{false} contracts.
But in this grammar, these contracts also have an index $\alpha$ that is used to differentiate between different instances of the same type of contract.
This index serves the same purpose as fresh type variables in Algorithm \W.
"Generating a fresh contract" is a commonly used phrase that refers to a fresh indexed \code{true} contract.

Before the algorithm itself is described, Stutterheim defines relations between contracts by "regarding contracts as sets of Haskell values" and using set-theoretic operations on these sets.
He uses these relations to formally define the notion of \textit{contract refinement}, where a contract that constrains a set of values is replaced by another contract that constrains a subset of those values.
This concept is what drives the contract inferencing algorithm.

\subsection{Algorithm \CW}
The algorithm itself is very much alike Algorithm \W:

\begin{itemize}
	\item A contract environment $\Gamma$ is defined that maps variables to contracts.
	\item Use of generalization and instantiation to introduce and remove universally quantified \code{true} contracts, respectively.
	\item A modified version of Robinson's unification algorithm that checks for free \textit{contracts} during the occurs check. It also ensures that substitutions always refine the contract.
\end{itemize}

Stutterheim proves that the algorithm is sound with respect to the contracting rules in his thesis.
For brevity, we do not replicate the proofs, contracting rules, unification rules nor code for Algorithm \CW ~here.
These elements can be found in subsection 3.4 of Stutterheim's thesis \cite{Stutterheim:2013:thesis}.


















%Can we refine the contract even more without risking raising an exception?
%It appears we cannot: we have reached a fixed point for a contract that will never raise an exception, regardless of the values it is provided.
%
%In section 3.3 of his thesis, Stutterheim defines relations between contracts by "regarding contracts as sets of Haskell values" and using set-theoretic operations on these sets.
%With these relations, he is able to define the notion of a \textit{most specific} contract:
%
%\begin{quotation}
%"..the inferred contract is also the most specific contract. I.e., the semantics of the inferred contract is a subset of any other contract that can be described in the contract system. (..) Intuitively, this seems true, because \textit{(contract inferencing algorithm)} \CW ~will infer contracts specific to certain types."
%\end{quotation}
%
%The contract in figure \ref{fig:head-contract-fixed-point} is close to being a \textit{most specific} contract.
%The only difference between our contract and the most specific contract, is that latter has been passed through Stutterheim's contract inferencing algorithm.
%
%Comparing this contract with the type of \code{head} shows that they are very similar:
%
%\begin{figure}[htbp]
%\begin{lstlisting}[mathescape]
%head_ctrt :: Contract ([aT] $\rightarrowtail$ aT)
%head_ctrt = (true $\functor$ true) $\rightarrowtail$ true
%
%head :: [a] $\rightarrow$ a
%\end{lstlisting}
%\caption{\label{fig:resemblance-contract-type}A strong resemblance between contracts and types.}
%\end{figure}
%
%This is not a random occurence: in Conjecture 1 of Stutterheim's thesis, he speculates that, 
%
%
%
%The example we have just viewed showed us how we can increase the specificity of a contract, starting from the \code{true} contract and working towards a very specific contract from there.
%This is how Stutterheim's contract inferencing system operates.
%In this thesis, we will exploit the resemblance shown in figure \ref{resemblance-contract-type} to simplify contract inferencing by providing the inferencing algorithm with the generalized version of the most specific contract for a given expression.
%A generalized contract is one that purely uses 
%
% relation the fact that we can generate a most specific contract from a type
%
%In fact, it is possible to generate a most specific generic contract from the type of the expression.

\section{Related work}
The concept of contracts dates back to the Eiffel programming language \cite{Meyer:1988wp} in 1988, which included it as a language feature.
Many other languages support contracts, or have libraries available to achieve the same functionality.

In a functional setting, contracts are less popular, but there has been a lot of research in this field.
Initial steps were taken by Findler and Felleisen \cite{Findler:2002:CHF:583852.581484}, who defined a typed lambda calculus with support for contracts for higher-order functions in the Scheme language.
For Haskell, Hinze et al. \cite{Hinze06typedcontracts} developed a dynamic contract library that builds upon Findler and Felleisen's findings. 
A static approach was taken by Xu et al. \cite{Xu:2006ul, Xu:2009:SCC:1594834.1480889}, allowing contracts to be checked using symbolic computation at compile-time. This technique is similar to that of refinement types, which we will cover in a later paragraph.

Degen et al. \cite{DegenThiemannWehr2009} provide an overview of contract implementation in lazy languages and their pitfalls, demonstrating how each form of dynamic contract monitoring (eager, semi-eager and lazy) is inherently flawed, either changing program behavior or ignoring contract violations.
The article also touches upon Xu's work on static contract systems, which the authors argue is similar to the eager monitoring style they discuss in their article.
Eager contract monitoring is preferred by the authors as all contracts defined in it are faithful: they will always evaluate to their actual value, which implies that, if a program terminates, all of the contracts within it will have evaluated to true.

Other researchers have explored enriching the type system to replace the functionality offered by contracts, producing what is commonly called "refinement types".
Rondon et al. \cite{rondon2008liquid} have developed a set of data types called Logically Qualified Data Types, often shortened to Liquid Types.
Using liquid types, they are able to embed a decidable subset of dependent typing functionality in a Hindley-Milner typing system.
With only the HM types and a predefined set of logical qualifiers, their algorithm is able to infer liquid types, which are dependent types that consist of conjunctions of the aforementioned logical qualifiers.
After inferring these liquid types, they can be resolved using an SMT solver.
In the end, one ends up with the strongest constraint possible on the expression that can be generated with the provided set of logical qualifiers.
Implementations of liquid typing are available for OCaml \cite{rondon2008liquid} and Haskell (using GHC) \cite{rondon2013refinement}.
The Haskell implementation is able to provide feedback if type checking fails, indicating the position(s) in the source code where things have gone wrong.
Additionally, a HTML file is generated of the processed source code annotated with the inferred types.

A similar approach was taken by Vytiniotis et al. \cite{Vytiniotis:2013ww}, whose framework converts contracts written in Haskell into a simpler lambda calculus, which itself is translated into first-order logic formulae.
Finally, these formulae are solved using an off-the-shelf theorem solver.

Terauchi \cite{terauchi2010dependent} also builds upon the recent developments in refinement types to present a system that is able to infer dependent types for a subset of the OCaml language without external input.
Instead of taking a user-provided set of formulas, the algorithm uses counterexample guided abstraction refinement (CEGAR) to iteratively refine a lattice of candidate dependent types.
Counterexamples are parts of the program that are untypable with the current lattice of candidate types.
The algorithm then attempts to type the program with all available types instead of the lattice.
If typing succeeds, the new candidates are added to the lattice and a new counterexample is selected.
If it fails, then the program is untypable.
As the algorithm itself generates the set of candidates, users can be sure that if the program is untypable, it really is untypable.
On the other hand, because the types are inferred automatically, they are not necessarily the strongest types available.

Ranjit et al. \cite{jhala2010refinement} take another route to attain refinement types: they first attain refinement type constraints using the implementation of Rondon et al. \cite{rondon2008liquid}, and then translate these types to a first-order imperative program.
If and only if the assertions of this imperative program hold, the higher-order program typechecks.
This verification can be done using several abstract interpretation techniques (of which CEGAR is one), which have readily available implementations for imperative languages.
The proof of safety of the imperative program translates to the solutions of the refinement type constraints.
Thus, these can be used to annotate the original higher-order program, obtaining the refinement types.

Cousot et al. \cite{cousotabstract} have implemented automatic contract inference for method extraction, a common refactoring technique.
The inferred contract satisfies four requirements: (i) it is valid for the extracted method; (ii) the contract takes into account language and programmer assertions; (iii) the contract of the refactored code is as precise as the non-refactored code, and (iv) the contract is as general as possible.
The authors use an iterative approximation algorithm to attain contracts that fulfil these requirements, and prove that an exact solution is uncomputable.

The articles of Dimoulas \& Felleisen \cite{Dimoulas:2011:CSH:2039346.2039348} and Greenberg et al. \cite{Greenberg:2010:CMM:1707801.1706341} provide an excellent overview of recent developments pertaining to contracts, as well as as detailed comparisons between the different libraries and frameworks. \cite{Dimoulas:2011:CSH:2039346.2039348} also goes into greater detail of the semantics of contract satisfaction.

Another form of type enrichment that enforces constraints is dimensional typing.
In short, a (usually numerical) value is given a dimension (time, length, mass, etc.).
Either through static analysis and inferencing or through type-level programming, these constraints can be enforced, ensuring that nonsensical operations, such as adding a time value and a mass value, are caught at compile-time.
Kennedy's thesis \cite{langanddim} explores this domain extensively for the ML language. 
A number of dimensional typing libraries are available for Haskell, most of which are defined using type-level programming or using type families.
Some simply constrain the input and output of functions, while others perform automatic conversion between compatible types, for example between meters and inches.

\chapter{Approach}

The contract inferencing system devised by Stutterheim is a solid base upon which we can build to support a language such as Haskell:

\begin{itemize}
	\item The grammar to describe a contract is library-agnostic. It takes several elements from the 'typed-contracts' library by Hinze et al. \cite{Hinze06typedcontracts}, which it uses as the example library to describe its code generation procedure.
	\item Using simple set-theoretic operations, Stutterheim defines relations between contracts, which he uses to prove how a contract can be more general than another.
	\item The language used, $\lambda_c$, is a simple let-polymorphic lambda calculus.
	\item His contract inferencing algorithm \CW ~is based upon Milner's Algorithm \W ~and uses Robinson's unification algorithm, two well-understood algorithms.
\end{itemize}

There are a few limitations in Stutterheim's system that we address:

\begin{itemize}
	\item A system for code generation is left implicit in Stutterheim's thesis. Feedback towards a user is also not discussed.
	\item Substitutions generated by algorithm \CW ~are in placed in a global set. Conflicting substitutions may result in an inferred contract causing a violation during assertion.
\end{itemize}

We improve upon Stutterheim's system in the following ways:
\begin{itemize}
	\item The language we use is a slightly simplified version of the Helium language, a dialect of Haskell that is a subset of the Haskell 98 specification.
	\item Using type information, we perform AST transformations to simplify the contract inferencing algorithm.
	\item With the same information, we generate a set of initial contracts that simplify contract inferencing even further. \todo{Does it also allow us to ignore mutually recursive functions??? Does stutterheim's system allow mutrecs?}
	\item Algorithm \CW ~is extended to support the Helium dialect, producing Algorithm \CHW.
	\item Substitutions are divided into two sets: global and local. This avoids the problem of contract violations by inferred contracts inherent in the original system.
	\item We provide a system to generate code for the 'typed-contracts' library.
\end{itemize}

Furthermore, we modify the 'typed-contracts' library to allow for a richer form of feedback.



\chapter{Approach}

\review

Our first order of affairs was to read and test the source code provided by Stutterheim, which contained the contract inferencing system and the code generation system.
The latter system had some issues, and working those out provided the first step to our final code generation system.
On the way, we encountered several more problems, which we will discuss in the remainder of this section.
Each subsection focuses on initial research and attempts at solving the problem, and concludes with a reference to a section describing the workings of the final solution.

\section{Overview}

\begin{itemize}
\item Stutterheim's code generation system did not work correctly out of the box, and required some tinkering to get to work, a short description of which can be found at subsection ~\ref{figuringoutcodegeneration}. A more detailed overview of the final code generation system can be found at section ~\ref{codegeneration}.
\item The existing 'typed-contracts' library provided poor feedback messages and required expansion. Section ~\ref{modificationstotypedcontracts} explains the modifications to the library in depth.
\item Code generation and some AST transformations required a reliable and robust source of types. The attempts can be found subsection ~\ref{attemptssourceoftypes}, and a description of the workings of the final system is at section ~\ref{sourceoftypes}.
\item The last problem encountered was an underestimated one: moving from monomorphic to polymorphic contracts. Further exploration of this problem is located in subsection ~\ref{monotopolyproblem}.
\end{itemize} 

\section{Figuring out code generation}
\label{figuringoutcodegeneration}

\subsection{Short description}
Stutterheim's code generation system takes the AST of the code to be contracted along with information about identifiers' types and contracts, and uses those to transform the original code into a fully-contracted version.

A very simple example:

\begin{lstlisting}[caption=A simple expression in Stutterheim's $\lambda_c$ language.]
let g x = x
in let f x = g x
   in (\x -> f x)
\end{lstlisting}

This would be converted into something like:

\begin{lstlisting}[caption=The same expression after going through code generation.]
let g x = x
in let __ctrt_g ctrt x = apply (assert "g" ctrt) (app (fun (g x)))
   in let f x = __ctrt_g {CONTRACT} x
      in let __ctrt_f ctrt x = apply (assert "f" ctrt) (app (fun (f x)))
         in (\x -> __ctrt_f {CONTRACT} x)
\end{lstlisting}

In short, the AST is traversed and every function definition receives a contracted version which calls the original code.
On top of that, every function application is replaced with this contracted version and a contract is added as another parameter.

\subsection{Issues in original code}
The code generation proof-of-concept in Stutterheim's thesis did not generate code that compiled in GHC, as it contained several errors:

\begin{itemize}
\item Capture and application of arguments using the \code{fun} and \code{app} functions, respectively, was done incorrectly, resulting in an incorrectly typed contract (if valid at all). 
\item Higher-order functions were not taken into account.
\end{itemize}

Function arguments of a higher-order function  should be not replaced by a fully-applied contracted version of the function, but by something else.
We began by splitting up the application of arguments to a contracted function and the definition and assertion of a contracted function itself.
As an example, the function definition

\begin{lstlisting}
f x = x
\end{lstlisting}

would now generate two more definitions:

\begin{lstlisting}
__contracted_f ctrt = assert "f" ctrt funs
 where funs = fun (\x -> f x)
__app_f ctrt x = app (__contracted_f ctrt) 0 x
\end{lstlisting}

This allowed us to use the \_\_contracted version for a function argument,
and the \_\_app version for fully-applied function applications of \code{f}.

Expanding the code generation system was necessary to accommodate for this feature.
But to be able to do so, we needed some information about the type of a function, namely its arity and the arity of its arguments.
Using this information, it would be possible to differentiate between partially-applied and fully applied function applications.
This source of type information was recovered from the contracts themselves, which closely mimick the type of a function.

Differentiating between these two versions uncovered another issue, however:
function arguments in a higher-order function must be expanded to be able to apply any other arguments to it.
Another example:

\begin{lstlisting}
f g x = g x
\end{lstlisting}

generates the following \code{\_\_contracted} definition:

\begin{lstlisting}[caption=Output of the \_\_contracted function definition of the above example.]
__contracted_f ctrt = assert "f" ctrt funs
 where funs = fun (\g -> (fun (\x -> f (\y -> app g y) x)))
\end{lstlisting}

This is because the argument \code{g} passed to \code{f} is already a contracted version of \code{g}.
Hence, we need to use \code{app} to apply \code{y} to \code{g}.

After these modifications, code was correctly generated for Stutterheim's simple language.

Of course, we still lacked many features that were required for the successful (and useful!) contracting of Helium code:

\begin{itemize}
\item The use of nested lets made use of mutually recursive functions hard to do.
\item Because of a global list of substitutions, applying a function twice to different arguments resulted in one of the functions being contracted incorrectly. In this sense, generated code was monomorphic with regard to contracts.
\item There was no way to point to a certain location in the code, and feedback was minimal.
\item Anonymous functions were not contracted.
\item It wasn't obvious where we could get the types from for the Helium AST.
\end{itemize}

Supporting mutually recursive functions proved to be relatively easy if we modeled the non-inferenced contracts after the types from the Helium compiler \todo{make section?}.

Making generated code polymorphic with regard to contracts needed far more attention, the details of which can be found in subsection ~\ref{monotopolyproblem}.

Providing rich feedback was also a goal. Details can be found in section ~\ref{providingricherfeedback}.

\todo{Section for transformations done?}

Finding a reliable source of types proved daunting, which is what the next subsection will cover.

\section{Attempts at finding a source of types}
\label{attemptssourceoftypes}
While developing the code generation code, it quickly became clear that the types of an identifier would be required.

There were two main uses for these types:
\begin{enumerate}
\item Calculating the arity of a type and the arity of each of the arguments of a function. This information proved necessary for code generation of higher-order functions and several AST transformations.
\item Basing an identifier's contract upon its type made contract inferencing easier and simpler. It also prevented the need for an analysis of mutually recursive structures during contract inferencing, as that analysis had already been done by the type system. \todo{Is this true? Verify!}
\end{enumerate}

\subsection{Initial attempt}

A first attempt at producing such a source of types was very ad-hoc: 
an initial type environment was produced by taking the string representation of the code and passing it to the Helium compiler, which returned the types of all top-level identifiers.
Identifiers defined in patterns were given a type by breaking it up piece by piece and passing it through the AST.
This meant that we needed to be able to identify each constructor, fetch its type, and break up the type into appropriate parts.
Every time a where-clause or let-binding was encountered, the environment would be passed to the Helium compiler along with the string version of the code block.
Then, the existing environment would be updated accordingly and passed downwards in the AST.
Lambda functions and case statements were even worse, needing to be first converted into a declaration AST before being able to be passed to the Helium compiler.
Because of this iterated process, some information was lost, such as type class prerequisites.
In turn, this caused compilation errors when the Helium compiler expected an identifier to have a type class prerequisite it did not have.
The system was cumbersome, buggy and most certainly not very efficient time- and spacewise.
It sorely needed replacement.

\subsection{Finding an alternative}
Looking through the Helium compiler options did not show any way of solely extracting the types from a piece of code and returning it in a structured manner.

However, in the Helium codebase, we discovered a function named 'proximaTypeInferencing' that returned a list of tuples that contained a range and a type scheme.

Intrigued, we dug deeper and discovered that it first collected the types of the entire AST in a doubly-linked tree data structure that closely resembled the original Helium AST.

Through some trial and error, it was possible to deconstruct this "type tree" as it was passed downwards through an AST.
The information this tree held was very rich indeed: not only did it have types for every identifier in patterns and expressions, but those types were also the final ones.
Most importantly, the integers that represented a unique type variable could be used to seed an initial contract for each identifier.
Because type inferencing had already taken place, contract inferencing could piggyback on the relations between the types of different identifiers.

With this new source in place, it was trivial to keep a type environment updated without too much changes required to the rest of the codebase.
As an added bonus, this type collection needed to be ran only once: a vast improvement compared to the first type source.

Further details on the final source of types can be found in section ~\ref{sourceoftypes}.

\section{Exploring the conversion from monomorphic to polymorphic contracts}
\label{monotopolyproblem}

Stutterheim's contract inferencing algorithm is monomorphic with relation to contracts.
What this means is that if a contracted function is applied more than once, to different arguments, only one of the function applications will yield a valid contract.
Naturally, we would like to be able to apply a function to different arguments without issue.

Let's look at a short example to clarify the problem.

\subsection{Problem example}
We want to run contract inferencing on the following piece of code:

\begin{lstlisting}[caption=An example code snippet that may generate incorrect code under Stutterheim's contract inferencing algorithm.]
f x = [x]
z = (f 'a', f 5)
\end{lstlisting}

We can either leave the contract environment empty, or seed it with some initial values, as you can see in listing \ref{lst.contractz}.

\begin{lstlisting}[caption=Contract of \code{z}.,label=lst.contractz]
true <@@> (true <@> isChar, true <@> isNum)}
\end{lstlisting}

The used contract are as follows: \code{true} is the most general contract you can have and never fails. \code{isChar} and \code{isNum} check if the argument that is provided to them is a character or a number, respectively.
\todo{We should write this all a bit more formally, of course.}

With this environment, contract inferencing generates the following substitutions:

\begin{lstlisting}[caption=List of substitutions generated by running Stutterheim's contract inferencing algorithm.]
(m8 +-> (true <@> isNum)) `o` (m7 +-> (true <@> isChar)) `o` (v1 +-> m8) `o` (v1 +-> m7)
\end{lstlisting}

Contract variables prefixed with a 'v' are universally quantified variables, or 'global' variables, and those prefixed with an 'm' are 'local' variables.
Local variables are only relevant to the function application from which they were generated.
Both types of variables are converted to the \code{true} contract during code generation if they have not been replaced by property contracts.

Armed with this knowledge, let's look at the universally quantified contract for \code{f}:

\todo{This contract is incorrect, update.}
\begin{lstlisting}[caption=The inferred contract for \code{f}.]
(v1 >-> v1)
\end{lstlisting}

The problem with placing local substitutions among global ones becomes apparent: whichever way we choose to apply the list of substitutions (left-to-right or right-to-left), one of the function applications will always have an incorrect contract!

In our example, the contracted version of \code{z} could be as follows:

\todo{This contract is incorrect, update.}
\begin{lstlisting}[caption=Contracted version of \code{z} that will fail typechecking.]
z = (__app_f (true <@> isNum) 'a', __app_f (true <@> isNum) 5)
\end{lstlisting}

Obviously, \code{'a'} is not a number.
This particular generated code will fail to compile because the compiler recognizes that the \code{Char} type does not have a class instance for the \code{Num} typeclass, but contracts that do not rely on such prerequisites will typecheck without issue.
For instance, it is possible to have a contract that checks if a number is a natural number.
If such a contract were to be erroneously applied to a number that is not a natural number, the generated code would typecheck, but fail during runtime.
This breaks Stutterheim's proposition that "(an) inferred contract will never fail assertion for that expression". \todo{Source diiis}

\subsection{Proposed solution}
Global and local substitutions must be kept apart from each other.
Whenever unification between two contracts takes place, the resulting substitutions are to be split up in a global and local group:
\begin{itemize}
\item The global group holds all substitutions that go from polymorphic contracts to other polymorphic contracts.
\item The local group holds all substitutions that go from polymorphic contracts to monomorphic contracts, as well as those that go from monomorphic contracts to other monomorphic contracts.
\end{itemize}
Global substitutions are to be handed up the AST, and local substitutions are to be handed down the AST.

When contract inferencing is complete, the global substitutions are applied first and local substitutions second.
However, these local substitutions will refer to old global contract variables, so the global group of substitutions must first be applied to the local substitutions before finally applying the local substitutions to the updated contract to gain the final contract.

At first, it appears logical to apply these substitutions during code generation, and not during runtime, but this is not optimal.
Let us look at an example to see why.

\begin{lstlisting}[caption=Expanded version of the previous code snippet.]
f x = g x
g x = f [x]
z = (f 'a', f 5)
\end{lstlisting}

The example has been expanded to include function \code{g}, which is called by \code{f}.
The contract environment remains the same as before.
The inferred contract for both \code{f} and \code{g} is once again '(v1 >-> v1)'. \todo{This contract is incorrect, update.}
The contracted code for \code{z} is now correct:
\todo{This contract is incorrect, update.}

\begin{lstlisting}[caption=Contracted version of \code{z} now typechecks.]
z = (__app_f (true <@> isChar) 'a', __app_f (true <@> isNum) 5)
\end{lstlisting}

Let's look at the rest of the generated code:

\begin{lstlisting}[caption=Rest of the output of code generation.]
__app_f ctrt x = appParam (__contracted_f ctrt) x
__contracted_f ctrt = assertPos "f" ctrt funs
    where
        funs = (fun (\x -> __final_f x))
__final_f x = __app_g (v1 >-> (v2 <@> v1)) x

__app_g ctrt x = appParam (__contracted_g ctrt) x
__contracted_g ctrt = assertPos "g" ctrt funs
    where
        funs = fun (\x -> __final_g x)
__final_g x = [x]
\end{lstlisting}

Calling the contracted version of \code{f} will call the contracted version of \code{g}, but with a universally quantified contract!
In other words, the local substitutions which made the contract that was passed to \code{\_\_app\_f} more specific, are not utilized by \code{\_\_app\_g}.
The solution appears trivial: pass the local substitutions as another argument to the \code{\_\_app} and \code{\_\_contracted} functions and apply them at runtime.

\subsection{Applying substitutions at runtime}

Unfortunately, it is not so simple.
Doing substitutions at runtime instead of statically means a runtime conversion is necessary between the AST contract datatype and the datatype from the \code{typed-contracts} library:
The AST datatype is a simple UUAGC-generated datatype without a phantom type, and \code{typed-contracts}'s datatype is a GADT with a phantom type used for a type-level representation of the contract.
Conversion between the two means we need to be able to tell what this phantom type should be. This is especially a problem when we need to convert between property contracts (\code{Prop} and \code{PropInfo}), because each property contract has a different phantom type, and the only information available in the AST datatype equivalent is a \code{String}.
Several ideas were tested to complete the conversion, the first of which was to use a typeclass:

\begin{lstlisting}[caption=Attempt at using a typeclass to recover the extra type information.]
class ConvertContract aT where
 convert :: Contract -> (Contract aT)

instance ConvertContract aT where
 convert (CVar s _) = true
 convert (CProp s) = searchEnvTuple s envTuple

instance ConvertContract (aT :-> bT) where
 convert (CArr c1 c2) = (>->) (convert c1) (convert c2)

instance Bifunctor f => ConvertContract (f aT bT) where
 convert (CBifunctor o il ir) = (convert o) <@@> (convert il,convert ir)

instance Functor f => ConvertContract (f aT) where
 convert (CFunctor o i) = (convert o) <@> (convert i)
 
testEnvTuple
  :: (Functor f, Ord dT, Ord bT, RealFrac eT) =>
     ((String, Contract (f cT :-> [dT])),
      ((String, Contract aT),
       ((String, Contract [bT]),
        ((String, Contract Char),
         ((String, Contract eT), ([a], Contract fT))))))
testEnvTuple = ( ("isort",sortCtrt), ( ("ctrue",true), ( ("ord",ord), ( ("isChar_prop",isChar_prop), ( ("isInt_prop", isInt_prop), ([], true) ) ) ) ) )
\end{lstlisting}

Because of the different phantom types, a nested tuple was needed to house the property environment. \todo{Why didn't this work, again? I think the typechecker didn't want to play nice and kept trying to unify these types or something.}

A type annotation would be required for this solution, so the compiler knows which instance to select.
Statically generating such an annotation would have been perfectly feasible, although it would have suffered from the same issue as the one we were trying to solve: 
the annotation for the contracted version of 'g' would have been a generic one.

Another idea would be to add the phantom type to the AST datatype, making conversion trivial.
Unfortunately, an option for adding phantom types in a UUAGC-defined datatype could not be found.
Even if phantom types were supported, the generation code would have had to have been rewritten to use a nested tuple for the environment contract instead of a regular list.

What about using type synonyms and the aforementioned typeclass?

\begin{lstlisting}[caption=Attempt at using type synonyms to choose the correct instances.]
instance ConvertContract aT where
  convert (CVar s _) = true
type IsIntProp aT = aT
instance RealFrac (IsIntProp aT) => ConvertContract (IsIntProp aT) where
  convert (CProp p) | p == "isInt_prop" = isInt_prop
\end{lstlisting}

Unfortunately, when deciding an instance, any constraints are ignored, and because type synonyms are transparent to the compiler, these instances fully overlap.
Simon Peyton-Jones and Oleg Kiselyov (http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap) do describe a way to use overlapping instances and functional dependencies to achieve this, but it requires a lot of extra work for every property.

After type synonyms, newtypes were tried:

\begin{lstlisting}[caption=Attempt at using newtypes to choose the correct instances.]
newtype IsIntProp aT = IsIntProp aT
instance RealFrac (IsIntProp aT) => ConvertContract (IsIntProp aT) where
  convert (CProp p) | p == "isInt_prop" = isInt_prop
\end{lstlisting}

This seemed to work, but it required wrapping and unwrapping of values, which was incompatible with the generated code.
Recall the contracted version of \code{f}:

\begin{lstlisting}
__app_f ctrt x = appParam (__contracted_f ctrt) x
__contracted_f ctrt = assertPos "f" ctrt funs
    where
        funs = (fun (\x -> __final_f x))
__final_f x = __app_g (v1 >-> (v2 <@> v1)) x
\end{lstlisting}

The value \code{x} would have to be unwrapped before it could be passed to \code{\_\_final\_f}, and these unwrapping functions would all have a different name.
A typeclass could be used to provide a singular function to wrap and unwrap newtypes, but user-defined typeclasses are currently unsupported by the Helium compiler.
Apart from that, this seemed to be a promising solution.

A final "solution" that would not require the use of typeclasses, would have been to generate a monomorphic set of contracted functions for every single function application.
Naturally, this set would need to contain every single function that is called when evaluating that particular function application; a possibly daunting amount.
Importing other modules makes this solution even less feasible, as functions from those modules would also need to be included in the set.
Because of the multitude of issues, this solution was disregarded early in the process.

Some of the proposed solutions are promising, but could not be explored further due to time constraints.
As such, the current code generation system generates monomorphic code that may fail when a function is applied to different contracts.
Rolling back to the polymorphic version is, of course, still possible, and is left as future work (see section ~\ref{futurework}).

\chapter{Final system design}

\review

This chapter explores the details of the final design of the entire code generation system.

First, we introduce the syntax for our abstract syntax tree (AST), which is a slightly modified version of the syntax Ask-Elle uses.
We will then follow the flow of the abstract syntax tree as it goes through the entire system, starting with several AST transformations, after which we will enter the code generation system, which consists of contract generation and -inferencing, and code generation.
The next two pages provide a visual overview of the system's flow.
Each node has a number that will be used when referring to it in the description.

\todo{Add these numbers to the image.}

\section{Syntax}
We have slightly modified the syntax used by the rest of the Ask-Elle system:
\begin{itemize}
	\item Fields to store range information were added. Range information consists of the line and column number of the node and its source (standard input, file, unknown) if this information is available.
	\item In Ask-Elle, constructors that use a list of patterns or expressions use the \code{Pats} and \code{Exprs} type synonyms, respectively. For example, expressions that describe a tuple or a list both use \code{Exprs}. However, from the viewpoint of contract inferencing, these expressions could not be more different! The solution is simple: tuples and lists in patterns and expressions use the type synonyms \code{ListPatsR}, \code{TuplePatsR}, \code{ListExprR} and \code{TupleExprR}. All other constructors remain unchanged.
\end{itemize}

This modified syntax can be downcast to the regular Ask-Elle syntax, and partially upcast to the Helium syntax, as during conversion from the Helium AST to the Ask-Elle syntax, some nodes are thrown away or only partially mapped.

\begin{lstlisting}[caption=Our modified Ask-Elle syntax.]
-- | A Haskell source module
data ModuleR
   | ModuleR
      name     :: MaybeNameR
      body     :: BodyR
      range    :: RangeR

data BodyR
   | BHoleR
      id       :: HoleIDR
      range    :: RangeR
   | BodyR
      decls    :: DeclsR
      range    :: RangeR

-- | Declarations
data DeclR
   | DHoleR
      id       :: HoleIDR
      range    :: RangeR
   | DEmptyR
      range    :: RangeR
   | DFunBindsR
      funbinds :: FunBindsR
      range    :: RangeR
   | DPatBindR
      pat      :: PatR
      rhs      :: RhsR
      range    :: RangeR

type DeclsR = [DeclR]

-- | Expressions
data ExprR
   | HoleR
      id       :: HoleIDR
      range    :: RangeR
   | FeedbackR
      feedback :: String
      expr     :: ExprR
      range    :: RangeR
   | MustUseR
      expr     :: ExprR
      range    :: RangeR
   | CaseR
      expr     :: ExprR
      alts     :: AltsR
      range    :: RangeR
   | ConR
      name     :: NameR
      range    :: RangeR
   | IfR
      cond     :: ExprR
      then     :: ExprR
      else     :: ExprR
      range    :: RangeR
   | InfixAppR
      left     :: MaybeExprR
      op       :: ExprR
      right    :: MaybeExprR
      range    :: RangeR
   | LambdaR
      pats     :: PatsR
      expr     :: ExprR
      range    :: RangeR
   | LetR
      decls    :: DeclsR
      expr     :: ExprR
      range    :: RangeR
   | LitR
      lit      :: LiteralR
      range    :: RangeR
   | AppR
      fun      :: ExprR
      args     :: ExprsR
      range    :: RangeR
   | ParenR
      expr     :: ExprR
      range    :: RangeR
   | TupleR
      exprs    :: TupleExprR
      range    :: RangeR
   | VarR
      name     :: NameR
      range    :: RangeR
   | EnumR
      from     :: ExprR
      then     :: MaybeExprR
      to       :: MaybeExprR
      range    :: RangeR
   | ListR
      exprs    :: ListExprR -- We use a new type here because for lists, the inferred contracts must hold on all elements.
      range    :: RangeR
   | NegR
      expr     :: ExprR
      range    :: RangeR

type ExprsR = [ExprR]
type ListExprR = [ExprR]
type TupleExprR = [ExprR]

data MaybeExprR
   | NoExprR
   | JustExprR
      expr     :: ExprR

-- | Alternatives
data AltR
   | AHoleR
      id       :: HoleIDR
      range    :: RangeR
   | AltR
      feedback :: {Maybe String}
      pat      :: PatR
      rhs      :: RhsR
      range    :: RangeR
   | AltEmptyR
      range    :: RangeR

type AltsR = [AltR]

-- | Function bindings
data FunBindR
   | FBHoleR
      id       :: HoleIDR
      range    :: RangeR
   | FunBindR
      feedback :: {Maybe String}
      name     :: NameR
      pats     :: PatsR
      rhs      :: RhsR
      range    :: RangeR

type FunBindsR = [FunBindR]

-- | Guarded expressions
data GuardedExprR
   | GExprR
      guard    :: ExprR
      expr     :: ExprR
      range    :: RangeR

type GuardedExprsR = [GuardedExprR]

-- | Literal values
data LiteralR
   | LCharR
      val      :: Char
      range    :: RangeR
   | LFloatR
      val      :: Float
      range    :: RangeR
   | LIntR
      val      :: Int
      range    :: RangeR
   | LStringR
      val      :: String
      range    :: RangeR

-- | Names
data NameR
   | IdentR
      name     :: String
      range    :: RangeR
   | OperatorR
      name     :: String
      range    :: RangeR
   | SpecialR
      name     :: String
      range    :: RangeR

data MaybeNameR
   | NoNameR
   | JustNameR
      name     :: NameR

-- | Patterns
data PatR
   | PHoleR
      id       :: HoleIDR
      range    :: RangeR
   | PConR
      name     :: NameR
      pats     :: PatsR
      range    :: RangeR
   | PInfixConR
      left     :: PatR
      name     :: NameR
      right    :: PatR
      range    :: RangeR
   | PListR  -- We use a new type here because for lists, the inferred contracts must hold on all elements.
      pats     :: ListPatsR
      range    :: RangeR
   | PLitR
      lit      :: LiteralR
      range    :: RangeR
   | PParenR
      pat      :: PatR
      range    :: RangeR
   | PTupleR
      pats     :: TuplePatsR
      range    :: RangeR
   | PVarR
      name     :: NameR
      range    :: RangeR
   | PAsR
      name     :: NameR
      pat      :: PatR
      range    :: RangeR
   | PWildcardR
      range    :: RangeR

type PatsR = [PatR]
type ListPatsR = [PatR]
type TuplePatsR = [PatR]

-- | Right hand side
data RhsR
   | RhsR
      expr     :: ExprR
      where    :: DeclsR
      range    :: RangeR
   | GRhsR
      gexprs   :: GuardedExprsR
      where    :: DeclsR
      range    :: RangeR

data RangeR
    | RangeR
        rangestart                    :: PositionR
        rangestop                     :: PositionR

data PositionR
    | PositionR
        filename                 :: String
        line                     :: Int
        column                   :: Int
    | UnknownR
\end{lstlisting}

\section{Overview}

\includepdf[pages={1}]{systemoverview.pdf}
\includepdf[pages={2}]{systemoverview.pdf}

\section{AST transformations}
Before passing the AST to the code generation system, we apply several transformations to it to facilitate contract inferencing and code generation.

\subsection{Capture lambdas}
Anonymous functions cannot be contracted, as a name is required to properly  perform code generation.
Our solution is simple: bind all lambda functions to a generated name and place them in the where-clause of the original definition.
A simple example:

\begin{lstlisting}
f = \x -> x
\end{lstlisting}

is transformed into

\begin{lstlisting}[caption=Result of lambda capture transformation.]
f = __lam0                   
 where                    
  __lam0 = \x -> x
\end{lstlisting}

Because of referential transparency, the behaviour of the program is not altered.

\subsection{Rewrite point-free functions}
The library of our choice, \code{typed-contracts}, does not support asserting partially applied functions.
Because of this, all function arguments are made available on the left-hand side and applied to the right-hand side of a definition.
To continue with our previous example,

\begin{lstlisting}
f = __lam0                   
 where                    
  __lam0 = \x -> x
\end{lstlisting}

is now transformed into

\begin{lstlisting}[caption=Result of $\eta$-abstraction transformation.]
f __a0 = (__lam0) __a0                
 where                    
  __lam0 __a0 = (\x -> x) __a0
\end{lstlisting}

This is essentially $\eta$-abstraction.
The information required for this transformation is provided by the type source,  which resides inside the code generation system.

\subsection{Rewrite infix function applications}
To cut down on duplicate code for both contract inferencing and code generation, we convert infix function applications to regular function applications.
In other words, we remove a layer of syntactic sugar.

\subsection{Expand function applications}
To keep contract inferencing simple, we split up function applications that are applied to multiple arguments into several nested function applications.
For example:

\begin{lstlisting}
f g x y z = g x y z
\end{lstlisting}

is transformed into

\begin{lstlisting}[caption=Result of function application expansion transformation.]
f g x y z = ((g x) y) z
\end{lstlisting}

This allows us to use Stutterheim's original contract inferencing code for function applications.

\subsection{Expand lambda arguments}
The reasons for this transformation are similar as the previous one: keeping contract inferencing simple and being able to reuse Stutterheim's contract inferencing code.
A lambda function with multiple arguments is split up into nested lambda functions:

\begin{lstlisting}
f = \g x y z -> g x y z
\end{lstlisting}

is transformed into

\begin{lstlisting}[caption=Result of lambda argument expansion transformation.]
f = \g -> (\x -> (\y -> (\z -> g x y z)))
\end{lstlisting}

\section{Source of types and initial contracts}
\label{sourceoftypes}
After these transformations, the AST is passed to the type source and to the code generator.

\subsection{Type source}
The type source takes the AST and calls a modified version of the Helium type inferencing code, which produces as doubly linked tree that resembles the input AST.
Each node in the tree holds an attribute list of a 3-tuple of information: 
\begin{itemize}
\item A textual representation of the piece of code, for debugging purposes.
\item A Helium AST of the piece of code.
\item If applicable, the type of the piece of code.
\end{itemize}

This "type tree" is generated in the \code{ModuleR} node of the AST, and is then passed down to the body of the module.

For the most part, the type tree format is the same as the code AST, the biggest discrepancies being situated in the following nodes:

\begin{description}
	\item{GRhsR:} The attribute list is of the form:
\begin{lstlisting}
[guard,expr,guard,expr,...,wheredecls]
\end{lstlisting}
	\item{CaseR:} An alternative has two entries in the attribute list: one for the left-hand side, and one for the right-hand side.
	\item{EnumR:} The type tree is ambiguous here: both \code{[1..2]} and \code{[1,2..]} return the same type tree. The code AST is inspected to determine what form is used, and the type tree is split up accordingly.
	\item{FunBindR:} A type is not available for a function binding, so we must synthesize one. This is done by concatenating all the types of any patterns of the function binding and the type of the right-hand side. 
\end{description}

Types are available for every constructor of the following AST types:
\begin{itemize}
	\item ExprR
	\item PatR
	\item AltR
	\item FunBindR
	\item RhsR
	\item GuardedExprR
\end{itemize}

\subsection{Contract generation}
\label{subsection:contractgeneration}
After providing types, a contract environment is constructed that holds the contracts for all identifiers (which consists of function identifiers and pattern identifiers) currently in scope at a certain node of the AST.

The initial contracts are generated by passing a \code{TpScheme} value (from the \code{top} library) to the \code{convertTopTypeToContract} function, which strips down the type scheme to its primitive type and inspects it, converting it appropriately.
This list shows which pattern match relates to which action:
\begin{description}
	\item{\code{(TVar i)} :} A \code{TVar} contains an integer \code{i} that corresponds to a specific type. That integer is prefixed with the character 'v' to indicate the initial contract is a universally quantified contract variable. For example, the type \code{a -> a} will be converted to the contract \code{v1 >-> v1}.
	\item{\code{(P.TApp (P.TApp (P.TCon "->") t1) t2)} :} A function application. \code{t1} and \code{t2} are also converted and put in a non-dependent function contract. For example, the type \code{a -> b} will be converted to the contract \code{v1 >-> v2}.
	\item{\code{(P.TApp (P.TCon x) t1) | x `elem` ["Maybe","[]"]} :} Both the \code{Maybe} type and the list type are converted to a functor contract.
	\item{\code{(P.TApp (P.TApp (P.TCon x) t1) t2) | x `elem` ["Either","(,)"]} :} Both the \code{Either} type and the 2-tuple type are converted to a bifunctor contract.
	\item{\code{(P.TCon x) | x `elem` ["Int","Char","Float","Bool","String"]} :} Literals of these types are converted to a universally quantified contract variable. Such a contract variable is provided with a fresh integer that does not collide with the set of integers used in the \code{TVar} constructors.
\end{description}

3-tuples and 4-tuples are also supported, but have been left out for brevity.

At the moment, user-defined data types are unsupported.
However, a data type environment is available and could be queried for the data type's general form and its name, allowing us to construct a pattern match.
Alternatively, one could generate a typeclass instance for each defined data type using Template Haskell or some other form of preprocessing.
Manually adding new data types to the conversion function is possible as well, of course.

These initial contracts are of great use for mutually recursive functions.
Let's look at the initial contracts that are generated for the following (not quite useful) example:

\begin{lstlisting}[caption=Simple mutually recursive function example.]
f x = g x
g x = f x
\end{lstlisting}

which generate the following types:
\begin{description}
	\item{\code{f} :} \code{v1 >-> v2}
	\item{\code{g} :} \code{v1 >-> v2}
\end{description}

From the types, it is obvious that the two functions are very closely intertwined, as they both take the same form of contracted input and the same form of contracted output.

These initial contracts are passed to the contract inferencing system to simplify inferencing greatly.

\section{Contract Inferencing}
Our contract inferencing system is based upon Stutterheim's work, and it is advised you read the chapters on contract inferencing if you are interested in the details, which we may leave out if they are the same.

Our algorithm is also based on the Damas and Milner type inferencing system, with a few modifications and simplifications due to our use of a type source.

Our goals for contract inferencing remain the same as Stutterheim's:
\begin{enumerate}
	\item Infer a well-typed contract for each function in a program;
	\item Inferred contracts must allow a (possibly non-strict) subset of the values that the type allows, and
	\item The most general contract inferred by the inferencing system must never fail during assertion.
\end{enumerate}

Because we use Algorithm \CW ~as a starting point, our algorithm, too, is based on Milner's Algorithm \W, and we make use of Robinson's unification algorithm as well.
The resulting algorithm is called Algorithm \CHW, and is discussed in

\subsection{Formal description of the contract language}
Figure \ref{fig:contract-grammar} described our contract language, which is a subset of that of Stutterheim's contract language.

While Stutterheim preferred to have specific terminals for data types literals, we felt this over-encumbered the contract language.
Instead, we have replaced this multitude of terminals with a single \code{literal} terminal.

\begin{figure}[htbp]
\begin{center}
\begin{lstlisting}[mathescape]
  -- Contracts
  c ::=  $\rho_{\alpha}$			-- User-defined concrete contract
      |  $c_{\alpha} \rightarrowtail c_{\beta}$			-- Function contracts
      |  $c_{\alpha} \functor c_{\beta}$			-- Functor contracts
      |  $c_{\alpha} \bifunctor (c_{\beta}, c_{\gamma})$			-- Bifunctor contracts
      |  $true_{\alpha}$			-- true contract
      |  $false_{\alpha}$			-- false contract
      |  $literal_{\alpha}$			-- literal contract
\end{lstlisting}
\end{center}
\caption{\label{fig:contract-grammar}Simplified grammar for the contract language.}
\end{figure}

Stutterheim describes several definitions, properties and relations between contracts in his thesis.
These remain valid in our system.

\todo{Most of this was done by Jurrien, although we can leave out some parts.}



\subsection{The contract inferencing system}
In this section, we will explore a system that allows us to infer a contract from an expression.
This system is based upon Stutterheim's work, and this section will roughly follow the same structure as the section in his thesis.

In our system, we use a contract environment $\Gamma$ which maps contract variables to contracts.
\todo{Should we just say that we use the same env system as Jurrien?}
A contract environment is defined as such:

\begin{figure}[htbp]
$\Gamma ::= [\!~]\!~||\!~\Gamma_1[x \mapsto c]$
\end{figure}

So, $\Gamma$ can either be completely empty, or consist of an environment $\Gamma_1$ that is extended by a mapping from a contract variable $x$ to a contract $c$.

We use the same notation as Stutterheim for contract environments:
\begin{itemize}
	\item $\Gamma(x)=c$ means that the right-most binding for $x$ in $\Gamma$ maps $x$ to $c$.
	\item $\Gamma \vdash e : c$ denotes that, in environment $\Gamma$, the expression $e$ has the contract $c$.
	\item $fc(\sigma)$ indicates the set of $true$ contracts that are free in contract schema $\sigma$.
	\item $fc(\Gamma)$ indicates the set of $true$ contracts that are free in the codomain of $\Gamma$.
\end{itemize}

The \code{gen} and \code{inst} support functions used by Stutterheim are deprecated by our use of a type source, so we will omit them in our description.
In place of these functions, we define the support function \code{ts}, which takes an identifier $i$ and as many fresh $true$ contracts as necessary to perform a conversion from the type of $i$ to a contract $c$.

\subsubsection{Contracting rules}

We will begin the contracting rules with those for patterns, as many of the rules are similar to those for declarations, right-hand sides, (guarded) expressions and alternatives.

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-PHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PWildcard}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $* :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PCon}}
  \AxiomC{$\Gamma \vdash$ $e_1 :: c_2 \rightarrowtail c$}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c_2$}
  \BinaryInfC{$\Gamma \vdash$ $e_1$ $e_2 :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PVar}\quad}
  \AxiomC{$\forall{i}\in[0\ldots{n}]$ $fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $p :: ts(p,[true_0\ldots{true_n}])$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PAs}\quad}
  \AxiomC{$\forall{i}\in[0\ldots{n}]$ $fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $p@(ps) :: ts(p,[true_0\ldots{true_n}])$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PCons}\quad}
  \AxiomC{$\Gamma \vdash$ $x :: c$}
  \AxiomC{$\Gamma \vdash$ $xs :: list \functor c$}
  \BinaryInfC{$\Gamma \vdash$ $(x : xs) :: list \functor c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PNil}\quad}
  \AxiomC{$fresh(i, j)$}
  \UnaryInfC{$\Gamma \vdash$ $[] :: true_i \functor true_j$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PTuple}\quad}
  \AxiomC{$\forall{i}\in{[0\ldots{n}]} \Gamma \vdash$ $e_i :: c_i$}
  \AxiomC{$fresh(j)$}
  \BinaryInfC{$\Gamma \vdash$ $(e_0, .., e_i) :: true_j \bifunctor (c_1, .., c_i)$}
  \DisplayProof
  \vskip 0.5em
%  \RightLabel{\textsc{C-PTupleNil}\quad}
%  \AxiomC{$\forall{i}\in[0\ldots{n}]$ $\Gamma \vdash$ $t_i :: c_i$}
%  \AxiomC{$\forall{j}\in[0\ldots{n-1}]$ $fresh(j)$}
%  \BinaryInfC{$\Gamma \vdash$ $(t_0, ..., t_i) :: true_0 <@@> (c_0, true_1 <@@> (..., true_j <@@> (c_i-1, c_i) ) )$}
%  \DisplayProof
%  \vskip 0.5em
  \RightLabel{\textsc{C-PLit}}
  \AxiomC{l is a literal}
  \AxiomC{$fresh(i)$}
  \BinaryInfC{$\Gamma \vdash$ $l :: literal_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PParen}\quad}
  \AxiomC{$\Gamma \vdash$ $p :: c$}
  \UnaryInfC{$\Gamma \vdash$ $(p) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PInfixCon}}
  \AxiomC{$\Gamma \vdash$ $e_1 :: c_1$}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c_2$}
  \AxiomC{$\Gamma \vdash \oplus$ $:: c_1 \rightarrowtail c_2 \rightarrowtail c_3$}
  \TrinaryInfC{$\Gamma \vdash e_1 \oplus e_2 :: c_3$}
  \DisplayProof
\end{center}
\caption{\label{fig:pattern-inference-rules}Contracting rules for patterns.}
\end{figure}

Contracts for patterns are collected purely from the type source using the \code{ts} support function, which is used in the \code{C-PVar} and \code{C-PAs} contracting rules.
Let us go over the rules in figure \ref{fig:pattern-inference-rules}, except for \code{PCon}, which is the same as in Damas and Milner's work.

Please note that while our syntax contains a \code{PListR} data constructor, we use the two contracting rules \code{C-PCons} and \code{C-PNil} to describe its contracting behaviour. 
This is how the \code{PListR} constructor works behind the scenes.
We will follow this convention for all constructors that describe lists.

\begin{description}
	\item{\code{C-PHole} and \code{C-PWildcard} :} In both cases, a fresh contract is generated because a more specific contract cannot be provided.
	\item{\code{C-PVar} and \code{C-PAs} :} Because the type source may require a number of fresh contracts between $0$ and $n$, we ensure that we create sufficient fresh contracts. The pattern identifier $p$ is then passed to \code{ts} along with the fresh contracts, which generates the final contract for $p$.
	\item{\code{C-PNil} :} Because we know nothing about the inner or outer contract, we generate fresh $true$ contracts for both.
	\item{\code{C-PCons} :} In this case, we know about the contracts of the tail and head of the list. The inner contract of the list tail must be the same as the contract of the head of the list. The resulting contract is the same as the list tail.
	\item{\code{C-PTuple} :} For a tuple; we know about each contract of the tuple's members. We generate a nested bifunctor contract for tuples larger than 2, nesting in $c_2$ until we have accomodated every member of the tuple. For each bifunctor contract, we require a fresh contract for the outer contract, which means we require $n-1$ fresh contracts, $n$ being the size of the tuple.
	\item{\code{C-PLit} :} A pattern literal is given a fresh $literal$ contract.
	\item{\code{C-PParen} :} Parentheses simply copy the contract of the enclosed pattern.
	\item{\code{C-PInfixCon} :} An infix operator in Helium only supports two arguments, so the contracting rule is a slight variation of regular function application.
\end{description}

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-DHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-DEmpty}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $ :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-DFunBinds}}
  \AxiomC{$\Gamma \vdash$ $d :: c$}
  \UnaryInfC{$\Gamma \vdash$ $(d:ds) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-DPatBind}\quad}
  \AxiomC{$\forall{i}\in[0\ldots{n}]$ $fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $p = rhs :: ts(p,[true_0\ldots{true_n}])$}
  \DisplayProof
\end{center}
\caption{\label{fig:declaration-inference-rules}Contracting rules for declarations.}
\end{figure}

Figure \ref{fig:declaration-inference-rules} shows the contracting rules for declarations. The rules \code{C-DHole} and \code{C-DEmpty} are trivial, but the remaining two warrant a little more explanation:

\begin{description}
	\item{\code{C-DFunBinds} :} In this rule, we select the contract of the very first element of the list of function bindings and use that as the contract of the entire list. This makes sense because function bindings must have the same number of arguments and the same result, meaning that the contract is also the same.
	\item{\code{C-DPatBind} :} A pattern binding will look up its contract in the type source, in the same manner as \code{C-PVar}.
\end{description}

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-FBHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-FunBind}}
  \AxiomC{$\Gamma \vdash$ $ident :: c$}
  \UnaryInfC{$\Gamma \vdash$ $ident$ $ps = rhs :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:funbinds-inference-rules}Contracting rules for function bindings.}
\end{figure}

The contracting rules for function bindings in figure \ref{fig:funbinds-inference-rules} are straightforward: \code{C-FBHole} works as all others holes, and \code{C-FunBind} looks up the identifier in the contract environment and assigns that contract to the entire function binding.

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-Rhs}}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $e$ \textbf{where} $d :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-GRhs}}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $|$ $g = e$ \textbf{where} $d :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:rhs-inference-rules}Contracting rules for right-hand sides.}
\end{figure}

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-GExpr}}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $g$ $|$ $e :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:guardedexpr-inference-rules}Contracting rules for guarded expressions.}
\end{figure}

Right-hand side contracting rules (see figure \ref{fig:rhs-inference-rules}) are equally simple: the contract of $e$ is looked up in the contract environment and is used for the entire right-hand side.
The same is done for guarded expressions (figure \ref{fig:guardedexpr-inference-rules}).

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-Hole}\quad}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Feedback}\quad}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $e :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-MustUse}\quad}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $e :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Case}}
  \AxiomC{$\Gamma \vdash$ $m :: c_1$}
  \AxiomC{$\forall{i}\in[0\ldots{n}] \Gamma \vdash$ $p_i :: c_1$}
  \AxiomC{$\forall{i}\in{[0\ldots{n}]} \Gamma \vdash$ $e_i :: c_2$}
  \TrinaryInfC{$\Gamma \vdash$ \textbf{case} $m$ \textbf{of} \{${p_0 -> e_0; ...; p_n -> e_n}$\} $:: c_2$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Con}\quad}
  \AxiomC{$\Gamma(x) = c$}
  \UnaryInfC{$\Gamma \vdash$ $x :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-If}\quad}
  \AxiomC{$\Gamma \vdash$ $t :: c$}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \BinaryInfC{$\Gamma \vdash$ \textbf{if} $cond$ \textbf{then} $t$ \textbf{else} $e :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Lambda}\quad}
  \AxiomC{$\Gamma[x \mapsto c_1] \vdash$ $e :: c_2$}
  \UnaryInfC{$\Gamma \vdash$ $\ x -> e :: c_1 \rightarrowtail c_2$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Let}\quad}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c$}
  \UnaryInfC{$\Gamma \vdash$ \textbf{let x =} $e_1$ \textbf{in} $e_2 :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Lit}}
  \AxiomC{$l$ is a literal}
  \AxiomC{$fresh(i)$}
  \BinaryInfC{$\Gamma \vdash$ $l :: literal_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-App}\quad}
  \AxiomC{$\Gamma \vdash$ $e_1 :: c_2 \rightarrowtail c$}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c_2$}
  \BinaryInfC{$\Gamma \vdash$ $e_1$ $e_2 :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Paren}\quad}
  \AxiomC{$\Gamma \vdash$ $p :: c$}
  \UnaryInfC{$\Gamma \vdash$ $(p) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Tuple}\quad}
  \AxiomC{$\forall{i}\in{[0\ldots{n}]} \Gamma \vdash$ $e_i :: c_i$}
  \AxiomC{$fresh(j)$}
  \BinaryInfC{$\Gamma \vdash$ $(e_0, .., e_i) :: true_j \bifunctor (c_1, .., c_i)$}  
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Var}\quad}
  \AxiomC{$\Gamma(x) = c$}
  \UnaryInfC{$\Gamma \vdash$ $x :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Enum}\quad}
  \AxiomC{$fresh(i)$ $\Gamma \vdash$ $x :: c$}
  \AxiomC{$\Gamma \vdash$ $y :: c$}
  \AxiomC{$\Gamma \vdash$ $z :: c$}
  \TrinaryInfC{$\Gamma \vdash$ [$x$ .. ($y$) .. ($z$)] $ :: true_i \functor c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Cons}\quad}
  \AxiomC{$\Gamma \vdash$ $x :: c$}
  \AxiomC{$\Gamma \vdash$ $xs :: list \functor c$}
  \BinaryInfC{$\Gamma \vdash$ $(x : xs) :: list \functor c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Nil}\quad}
  \AxiomC{$fresh(i, j)$}
  \UnaryInfC{$\Gamma \vdash$ $[] :: true_i \functor true_j$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Neg}\quad}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $-e :: c$}
  \DisplayProof
  \vskip 0.5em
\end{center}
\caption{\label{fig:expr-inference-rules}Contracting rules for expressions.}
\end{figure}

Figure \ref{fig:expr-inference-rules} details the contracting rules for expressions, which have large overlaps with those for patterns.
Note how there is no rule \code{C-InfixApp}.
This is because infix function applications are converted to regular function applications before contract inferencing occurs.
As such, there is no need for such a rule.

Rules that are either trivial or similar to those of patterns are: \code{C-Hole}, \code{C-Feedback}, \code{C-MustUse}, \code{C-Lit}, \code{C-App}, \code{C-Paren}, \code{C-Tuple}, \code{C-Cons}, \code{C-Nil} and \code{C-Neg}.
The rest of the contracting rules are discussed hereafter.

\begin{description}
	\item{\code{C-Case} :} This rule describes contracting of a case statement for an arbitrary number of cases. The contract of the expression being evaluated, $m$, must be the same as the contracts of the patterns $p_i$, namely $c_1$. The contract of the entire case statement is $c_2$, which is the contract that is given to each alternative.
	\item{\code{C-If} :} Syntactic sugar for a boolean case statement. Like its generalized version, the contract of the entire statement is the same of each alternative, in this case $c$. 
	\item{\code{C-Lam} :} This contracting rule is the same as in Damas \& Milner's work.
	\item{\code{C-Let} :} A non-generalized let. This is not necessary because every contract variable is polymorphic in the global contract environment. 
	\item{\code{C-Enum} :} A list generator. $y$ and $z$ are fully optional, but if they are present, they must have the same contract as that of $x$, namely $c$. A fresh outer contract is generated to complete the final contract.
\end{description}

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-AHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-AltEmpty}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $ :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Alt}}
  \AxiomC{$\Gamma \vdash$ $rhs :: c$}
  \UnaryInfC{$\Gamma \vdash$ $p$ $\rightarrow$ $rhs :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:alternatives-inference-rules}Contracting rules for alternatives.}
\end{figure}

The contracting rules for alternatives in figure \ref{fig:alternatives-inference-rules} are quite simple. \code{C-AHole} and \code{C-AltEmpty} are trivial, and \code{C-Alt} takes the contract of the right-hand side as the contract of the entire alternative.

\todo{May want to add contracting rules for interesting lists like those for alts.}

\todo{A few simple examples of applying the rules?}

\subsubsection{Substitutions and unification}

We use the same substitutions grammar as that of Stutterheim.
Our unification algorithm, too, is identical to that of Stutterheim, which itself is based upon Robinson's unification algorithm.
We refer you to subsection 3.4.2 of Stutterheim's thesis for a description of the unification algorithm and the substitutions it generates.
When you are done reading, we will note a caveat in his description of the algorithm.

It merits mentioning that although Stutterheim's unification algorithm supports concrete contract refinement in theory, in code this is unsupported.
In fact, the example posed by Stutterheim

\begin{figure}[htbp]
$\mathcal{U}$ $(int,nat)$
\end{figure}

results in an error message, as evidenced by the following relevant pattern matches of the \code{unifyC} function:

\begin{lstlisting}
unifyC :: Contract -> Contract -> Subst
unifyC c1              c2 | c1 == c2   = SId
unifyC v@CVar{}        c               = unifyCVars v c
unifyC c               v@CVar{}        = unifyCVars v c
...
unifyC c1 c2 = unifyErr "No such unification case when" c1 c2
\end{lstlisting}

This is because the $int$ and $nat$ contracts are in fact defined as user-defined concrete contracts in the system's code.
The default contracts that Stutterheim refers to in figure 3.2 of his thesis do not exist in the Haskell data type, which only supports the inhabitants of our simplified grammar as show in figure \ref{fig:contract-grammar}.
Relations between contracts that allow for refinement are thus non-existent.
While these relations can be mapped out manually, a better idea would be to look towards true refinement types. \todo{Finish up refinement type info stuff, refer to it here.}

%\begin{figure}[htbp]
%\begin{center}
%\begin{lstlisting}[mathescape]
%$\theta$  ::=  Id		-- Identity substitution
%    |    $\theta_1 \circ \theta_2$		-- Substitution composition
%    |    [$c_1 \mapsto c_2$]		-- Substitution for $c_1$ with a contract $c_2$
%\end{lstlisting}
%\end{center}
%\caption{\label{fig:subst-grammar} The substitution grammar as defined by Stutterheim.}
%\end{figure}

\subsubsection{Algorithm \CHW}
Now that we have reviewed the contracting rules and the unification algorithm, let us define the contract inferencing algorithm \CHW.
This algorithm takes a \code{Module} and infers contracts for each declaration, pattern, right-hand side, (guarded) expression and alternative that resides in the module.

Our starting point was Stuterheim's algorithm $\mathcal{CW}$, which has been extensively modified.

To infer a contract, a number of elements are required:
\begin{enumerate}
	\item The contract environment $\Gamma$, which has been populated beforehand with initial contracts from the type source as described in subsection \ref{subsection:contractgeneration}.
	\item The type source $\Xi$, which contains the raw types of the contractable non-terminals. When needed, these raw types will be converted to a unique initial contract. An example of this would be the list constructor, which for obvious reasons must have a unique initial contract every time it is encountered.
\end{enumerate}


\section{Providing richer feedback}
\label{providingricherfeedback}
\todo{Might have to split some of this stuff up and move it to Approach and initial research}

\subsection{Modifications to typed-contracts}
\label{modificationstotypedcontracts}
In order to provide adequate feedback to the user, we modified the typed-contracts library by Jeuring et al to produce more specific feedback in a language that the user can understand.
The original library code provides error messages that refer to contract violations and (higher-order) blame of expressions, concepts that are foreign to the average user and thus do not provide any useful feedback.

Three modifications were made to the original library code.
Firstly, the Contract GADT was modified to include the PropInfo constructor, which takes an additional argument: a function that, given the position of which argument or result that the property is being applied to, returns an appropriate error message.

\begin{lstlisting}
type PosInfo = (Int,Int)
PropInfo   ::  (aT -> Bool) -> (PosInfo -> String) -> Contract aT
Prop       ::  (aT -> Bool) -> Contract aT
\end{lstlisting}

For example, the position (0,1) indicates the first argument of a function that has one argument.
The position (1,1) indicates the result of such a function.
Given this information, it is possible to generate a detailed error message.
Here is an example of an error message generated by the property that an integer must lie in the domain of the natural numbers, and which is applied at the first argument of a function: 

"The first supplied argument of this function does not fullfil the following property: the number must always be a natural number."

This form of feedback is richer than the default form and can be invoked in the message generation function if desired.
For example:

\begin{lstlisting}
isBiggerThan_prop = PropInfo (\x -> fromEnum x > 5 ) (\p -> mkErrorMsg p "the number must be larger than five.")

mkErrorMsg p text = posInfoText p ++ "does not fullfil the following property: " ++ text

posInfoText (pos,arity) | pos < arity  = "The " ++ showPos (pos+1) ++ " supplied argument of this function "
                        | pos == arity = "The result of this function "
                        | (pos,arity) == (-1,-1) = "An unknown position "

showPos p | p == 1 = "first"
          | p == 2 = "second"
          | p == 3 = "third"
          | p == 4 = "fourth"
          | p == 5 = "fifth"
          | p == 6 = "sixth"
          | otherwise = show p
\end{lstlisting}

Furthermore, two functions were added: 'assert''' and 'assertPos'.

'assert''' is a modified version of 'assert'' that records position information.
'assertPos' kickstarts this position information, filling in the arity of the entire contract:

\begin{lstlisting}
assertPos :: String -> String -> Contract aT -> aT -> aT
assertPos s pos c = assert'' c (0, ctrtarity c) (makeloc (Def (s ++ pos)))
 where
  ctrtarity :: Contract aT -> Int
  ctrtarity (Function c1 c2) = 1 + ctrtarity (c2 undefined)
  ctrtarity _                = 0
\end{lstlisting}

There may be situations, however, where using the position information is not necessary.
For example, position information may be recorded outside of the library and passed as a string to 'assertPos'.
Our generated code does this, as well as providing the user with a string representation of the value that triggered the offending contract by means of a call to 'show'.
But what about functions or infinite data structures? Calling 'show' on these will result in either an error or non-termination.
In these situations, it is be useful to use the recorded position information to be able to pinpoint the offending argument without having to resort to showing it.

At the moment, code is generated that assumes that every argument applied to a contracted function has a 'Show' instance. Because Quickcheck should not generate infinite structures (quite the contrary!), this seems to be a reasonable assumption.

'Show' instances for functions would still be required, but those can be provided:

\begin{lstlisting}
instance Show (aT :-> bT) where
	showsPrec a = showString "<function>"
\end{lstlisting}

\subsection{Code generation}
\label{codegeneration}

In section~\ref{codegeneration}, we discuss the details of the generation of contracted code.
This generated code produces detailed feedback messages composed of both dynamic and static information.

Generating such rich feedback is quite hard in the case of higher-order functions; how does one print the offending value if that value is a function?

One possibility is to include a string representation of each argument that is passed to a contracted function.
However, a string representation loses all notions of the original structure, which makes passing these values around in higher-order functions useless.
In a contracted higher-order function, one of the function arguments may fail to meet its contract and produce a contract violation.
For example, let's say we apply the map function to an appropriate function and the list [1,2,3].
Code is generated that replaces the original call with a contracted version of map, to which we pass the tuple ("[1,2,3]",[1,2,3]).
The contracted map function then applies its function argument to the first item in the list.
This list item causes a contract violation, but the only visual information we have available is a string representation of the entire list.
Clearly, this doesn't work.

A better approach is to dynamically show the value using the Show class, but this means we lose the ability to show functions.
We were able to do this previously because we statically generated a string representation during code generation.

While we are unable to say what function caused the contract violation in a higher-order function, we are able to indicate which arguments of both the higher-order function and the function argument failed.
We are able to use this information to still generate highly detailed feedback, as can be seen with this snippet of generated code:

\begin{lstlisting}
g f x = f x
\end{lstlisting}

becomes

\begin{lstlisting}
(fun (\ __x21 -> (fun (\ __x22 -> __final_g (\ a0 -> (appParam __x21 (concat "the application of the higher-order function 'g' ",(generatePositionData posinfo),". g has a function as its first argument."," The first argument of that function",", namely ",show a0]) a0)) __x22))))
\end{lstlisting}

Note how the arguments to the function argument \_\_x21 are applied with a very detailed feedback message.
In the case that a contract violation occurs at that position, the feedback could look like this:

A part of your code, or a supplied argument to a function, does not fullfil a required property. This occurred at the application of the higher-order function 'g' at line number 1, column number 1. g has a function as its first argument. The first argument of that function, namely -5, does not fulfill the following property: the number must always be a natural number.

From this feedback, the user can deduce the following:
\begin{itemize}
\item Which application of a higher-order function caused the contract violation.
\item Which argument of the higher-order function is the function that caused the contract violation.
\item Which argument of that function caused the violation.
\item Possibly, the offending value.
\end{itemize}

\subsection{Reusing QuickCheck properties}

The Ask-Elle programming tutor supports QuickCheck properties that are executed to verify the correctness of code that cannot be reduced to a known strategy.
A very interesting idea is to derive contracts from such properties automatically and use them to construct contracts that can be used to contract the result of the function.
However, remember that we are limited to non-dependent contracts, so we only have access to a single argument or the result of the function in a contract.
Most QuickCheck properties, however, refer to one or more arguments of the function.

A simple QuickCheck property of the palindrome function illustrates the problem well:

\begin{lstlisting}
prop_Main = \xs -> whenFail (putStrLn "This function does not correctly check for palindromes.") 
 ( (palindrome xs) == (reverse xs == xs) )  
\end{lstlisting}

The input xs must be captured with a dependent contract before it can be referred to.
This means that we are unable to derive a contract useful for contract inferencing.

The only QuickCheck properties that are of use to us to derive a contract from, are properties that only refer to the result of the function.
For these kinds of properties, we can construct a contract of the following form:

\begin{lstlisting}
Prop (\result -> ...)
\end{lstlisting}

As you can see, we are severely limited in the the range of properties that we can use.
For this reason, we do not further develop a contract deriving mechanism for QuickCheck properties.
 
\todo {Explain how we can't use QuickCheck properties that are predefined for many Ask-Elle exercises. It had to do with how QuickCheck properties may require dependent contracts if it takes more than a single input.}

\section{Code Generation}
\label{codegeneration}

\review

Now that we have inferenced contracts for every function application, we can generate contracted code.

We go over the AST again and for every function definition X, we generate the following new functions:

\_\_contracted\_X
\_\_app\_X
\_\_final\_X

These functions ensure that all function calls are contracted. Let us go over what each one does.

\subsection{\_\_contracted\_X}
This function calls the assertPos function of the typed-contracts library, will dynamically assert the contract provided to it.


Let us look at the template:

\begin{lstlisting}
__contracted_X ctrt posinfo = assertPos [function info] (generatePositionData posinfo) ctrt funs
  where funs = [contracted function definition]
\end{lstlisting}

A generated function takes two arguments, ctrt and posinfo.
ctrt is a Contract that is passed to the assertPos function. 
Different function calls can thus have differing contracts assigned;
in other words, the generated function is polymorphic in its contract.

posinfo is simply a tuple of the line and column position of a function call, and is used to generate specific feedback at runtime if there is a contract violation.

There are two placeholders that are replaced during code generation:
the placeholder [function info] is replaced by a string that informs the user what kind of function violated its contract.
Two examples of such generated messages are:

"At the application of the higher-order function 'foldr'"
"At the application of the function 'insert'"

The other placeholder, [contracted function definition], is replaced by a contracted version of the original function.
For example, a contracted version of the identity function looks like this:

\begin{lstlisting}
fun (\__x01 -> __final_id __x01)
\end{lstlisting}

For each argument, an extra layer of fun is applied to capture them and make them available to the original function.

A higher-order argument requires a bit more work, as it itself must be contracted before being passed to the original function.
For example,

\begin{lstlisting}
g f x = f x
\end{lstlisting}

will generate the following replacement for the [contracted function definition] placeholder:

\begin{lstlisting}
(fun (\ __x21 -> (fun (\ __x22 -> __final_g (\ a0 -> (appParam __x21 (concat "the application of the higher-order function 'g' ",(generatePositionData posinfo),". g has a function as its first argument."," The first argument of that function",", namely ",show a0]) a0)) __x22))))
\end{lstlisting}

The \_\_contracted version of a function is referenced in the \_\_app version, which we will review next.

\subsection{\_\_app\_X}

This function captures information for use in feedback, wraps it appropriately, and passes it to the \_\_contracted version of the function.

Again, let us first examine the template:

\begin{lstlisting}
__app_X ctrt posinfo [argument patterns] = [applied arguments]
\end{lstlisting}

The arguments ctrt and posinfo appear here again: both are passed to the \_\_contracted version of the function. Note again that this generated function is polymorphic with respect to its contract.

The placeholders [argument patterns] and [applied arguments] are relatively simple.

[argument patterns] generates a triple for each argument, which contains a string representation of the argument, the position of the argument, and the argument itself.

[applied arguments] uses this extra information to provide richer feedback at runtime and applies the arguments to the contracted version of the function.

Let us revisit a previous example:

\begin{lstlisting}
g f x = f x
\end{lstlisting}

will generate the following code:
\begin{lstlisting}
__app_g ctrt posinfo (posa,a) (posb,b) =
 appParam (appParam (__contracted_g ctrt posinfo) (show a ++ generatePositionData posa) a) (show b ++ generatePositionData posb) b
\end{lstlisting}

The contracted version of the function is fed arguments using appParam, and are accompanied by feedback strings containing the argument as a string and its position in the source code.

\subsection{\_\_final\_X}

Lastly, this generated function ties everything together by transforming the original function definition, replacing normal function calls with their contracted equivalents.

For example, the foldr function is transformed into the following:

\begin{lstlisting}
__final_foldr f b (x:xs) = f x (__app_foldr [ctrt] [pos] (_,f) (_,b) (_,xs))
__final_foldr f b [] = b
\end{lstlisting}

We leave out the generated information for brevity.

Note how the recursive call is also contracted, and how f can consume its arguments in the normal manner while being a contracted function itself.

What about function applications that have higher-order arguments?

In those cases, the higher-order argument is not replaced with a call to its \_\_app version, but with a call to its \_\_contracted version.
For example, the expression

\begin{lstlisting}
foldr insert [] [5,4,7,0,10]
\end{lstlisting}

will generate the following \_\_final version:

\begin{lstlisting}
__app_foldr (_,_,__contracted_insert [ctrt] [pos]) (_,[]) (_,[5,4,7,0,10])
\end{lstlisting}

This expression is a good example of what the user will provide.
Of course, if the user provides a partially applied function, there is not much that can be done, in the same manner as the uncontracted version of the code.

\subsection{Generation of final contracts}

\chapter{Discussion and future work}
\label{futurework}

\section{Using paramorphisms to tackle dependent contracts}

\review

Johan Jeuring provided a wonderful idea to be able to run contract inferencing on some catamorphisms with dependent contracts by converting them to a paramorphism, which is a catamorphism that provides its function argument with the original input as well:

\begin{figure}[htps]
\begin{lstlisting}
para  :: (a -> [a] -> b -> b) -> b -> [a] -> b
foldr :: (a ->        b -> b) -> b -> [a] -> b

para  c n (x : xs) = c x xs (para c n xs)
foldr c n (x : xs) = c x    (foldr c n xs)
para  c n []       = n
foldr c n []       = n
\end{lstlisting}
\texttt{\scriptsize{Source: http://stackoverflow.com/questions/13317242/what-are-paramorphisms}}
\end{figure}

This functionality is of great use for dependent contracts that need access to the original argument, as can be seen in the following example code (courtesy of Johan Jeuring):

\begin{lstlisting}
-- GList      ::  Contract aT -> ([aT] -> Bool) -> Contract [aT]
sortc =  GList int (const True) >-> \xs -> GList int (\r -> nonDesc r && isPerm xs r)
isPerm xs ys = null (xs \\ ys)

sort_perm'         :: Ord a => [a] -> [a]
sort_perm'         =  foldr insert_notPerm []
insert_notPerm ::  Ord a => a -> [a] -> [a]
insert_notPerm x []                    =  [x]
insert_notPerm x (y:ys)  |  x <= y     =  x:y:ys
                         |  otherwise  =  insert_notPerm x ys
                         
sort_permWrong        =  foldr insert_notPerm [] 
sort_permNotViolated  =  assert sortc sort_permWrong [3,2,4]
\end{lstlisting}

In the above example the input, \code{xs}, is needed in the \code{sortc} contract to be able to express the permutation property, but this introduces a dependent contract, which means the contract cannot be used for contract inferencing.

This is where the paramorphism comes in, as it provides that \code{xs} value.
The contract for the \code{para} function is, then:

\begin{lstlisting}
parac
  :: Contract aT
     -> ([aT] -> Bool)
     -> ([aT] -> Contract bT)
     -> Contract ((aT -> [aT] -> bT -> bT) -> bT -> [aT] -> bT)
parac aT p bT =   (aT >-> \x -> GList aT p >-> \xs -> bT xs >- bT (x:xs))
              >-  bT []
              >-  GList aT p
              >-> \xs -> bT xs
              
psort  =  para (\x xs ys -> insert_correct x ys) []
\end{lstlisting}

Unifying \code{sortc} and \code{parac} gives us:

\begin{lstlisting}
GList aT  p             >->  \xs -> bT xs
GList int (const True)  >->  \xs -> GList int (\r -> nonDesc r && isPerm xs r)

aT  :=  int
p   :=  const True
bT  :=  \xs -> GList int (\r -> nonDesc r && isPerm xs r)
\end{lstlisting}

Applying these substitutions, we see that \code{bT []} will get the contract:  

\begin{lstlisting}
GList int (\r -> nonDesc r && isPerm [] r)
\end{lstlisting}

And the contract for \code{insert} becomes:

\begin{lstlisting}
insertc'  =    int 
          >->  \x  -> GList int (const True) 
          >->  \xs -> GList int (\r -> nonDesc r && isPerm xs r)
          >-   GList int (\r -> nonDesc r && isPerm (x:xs) r)
cinsert_notPerm_violated = assert insertc' (\x xs ys -> insert_notPerm x ys) 3 [2,4] [2,4]
\end{lstlisting}

Note that by using a paramorphism instead of a catamorphism, \code{insert} is supplied with an argument it does not require, so it is wrapped in a lambda function and the superfluous argument is ignored.

How do we relate this contracted paramorphism to the original user's \code{foldr} call?
By defining \code{foldr} as a paramorphism, which is quite simple:

\begin{lstlisting}
pfoldr f e = para (\x xs r -> f x r) e
sort_perm''        =  pfoldr insert_notPerm []
sort_permViolated' =  assert sortc' sort_perm'' [3,2,4]
\end{lstlisting}

In short, this implies it is possible to convert some functions that use catamorphisms with dependent contracts, into paramorphisms with non-dependent contracts.

Some feedback problems do pop up: how do we meaningfully inform the user of a violated contract in  \code{(\textbackslash x xs r -> f x r)} ? 
And what if the \code{para} contract is violated, how do we report that?
It is possible to modify the feedback messages in contract generation to "cloak" the use of a paramorphism, but this has not yet been investigated further.

\bibliographystyle{plain}
\bibliography{bibliography}
\end{document}
