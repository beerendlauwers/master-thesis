\documentclass[10pt]{report}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[numbers]{natbib}
\usepackage{bussproofs}
\usepackage{color}
\usepackage{listings}
\usepackage{ amssymb }
\usepackage{courier}
\usepackage[pdftex]{graphicx}
\lstset{language=Haskell}
\lstset{breaklines=true}
\lstset{basicstyle=\scriptsize\sffamily}
\lstset{frame=single}
\lstset{showstringspaces=false}
\lstset{captionpos=b}
\usepackage{url}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{pdfpages}

\setlength{\parskip}{\baselineskip}%
\setlength{\parindent}{0pt}%

\usepackage{multicol}

\usepackage{attrib}
\usepackage{framed}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\newcommand{\functor}{<\!\!\!@\!\!\!>}
\newcommand{\bifunctor}{<\!\!\!@\!\!@\!\!\!>}

\newcommand{\W}{$\mathcal{W}$}
\newcommand{\CW}{$\mathcal{CW}$}
\newcommand{\CHW}{$\mathcal{CHW}$}

\newcommand{\ctrttemplate}{\underline{\hspace{1.5em}}contracted\_\code{X}}
\newcommand{\finaltemplate}{\underline{\hspace{1.5em}}final\_\code{X}}
\newcommand{\apptemplate}{\underline{\hspace{1.5em}}app\_\code{X}}

\newcommand{\sref}[1]{Section~\ref{#1}}
\newcommand{\annotate}[3]{
	\begin{scriptsize}
	\textcolor{#1}{\textbf{#2}~\textit{#3}}
	\end{scriptsize}\newline}
\newcommand{\todo}[1]{\annotate{red} {TODO:} {#1}}
\newcommand{\review}{\annotate{blue} {REVIEW:} {Please review the following text. \newline}}

\newcommand{\explain}[1]{\quad\{\;\text{#1}\;\}}
\newcommand{\justify}[1]{\quad\{\;\text{#1}\;\}}
\newcommand{\johan}[1]{[\textit{Johan says:}~#1]}
\newcommand{\augusto}[1]{[\textit{Augusto says:}~#1]}


\definecolor{light-gray}{gray}{0.95}
\newcommand{\code}[1]{%
  {% open a group for a local setting
   \setlength{\fboxsep}{-2\fboxrule}% the rule will be inside the box boundary
   \fcolorbox{black}{light-gray}{\hspace{1.5pt}\strut\texttt{#1}\hspace{1.5pt}}% print the box, with some padding at the left and right
  }% close the group
}

%\author{Beerend Lauwers\\ (ICA-XXXXXXX)\\ \\ Department of Computing Science \\ Utrecht University, The Netherlands\\ \\ \\ Supervisor:\\ dr. Johan Jeuring}
%\date{\today}
%\title{Contract Inference for the Ask-Elle Programming Tutor}
\begin{document}

\begin{titlepage}
\begin{center}

% Upper part of the page
\includegraphics[width=0.6\textwidth]{./uulogo}\\[0.75cm]

\textsc{\Large Department of Computing Science}\\[1.5cm]

\textsc{\Large MSc Thesis, ICA-XXXXXXX}\\[0.5cm]

% Title
\HRule \\[0.4cm]
{ \huge \bfseries Contract Inference for the Ask-Elle Programming Tutor}\\[0.4cm]

\HRule \\[1.5cm]

% Author and supervisor
\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Author:}\\
Beerend \textsc{Lauwers}
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Supervisor:} \\
Prof. dr.~J.T. \textsc{Jeuring}
\end{flushright}
\end{minipage}

\vfill

% Bottom of the page
{\large \today}

\end{center}
\end{titlepage}

\begin{abstract}
Ask-Elle \cite{Gerdes:2012:phd} is a programming tutor that utilizes (transformations of) model solutions to provide feedback to students on their progress.
If a student's program cannot be reduced to such a model solution, providing helpful feedback becomes hard. 
The Master Thesis of Jurri\"en Stutterheim \cite{Stutterheim:2013:thesis} focuses on the development of a contract inference system for functional programs, with the goal to embed this functionality in the Ask-Elle programming tutor to provide a new source of meaningful feedback to students using it.
This thesis builds upon his work, extending the contract inference algorithm to work with the language used by Ask-Elle: Helium.
This language is a subset of the Haskell functional programming language.
Additionally, a code generation system  for the \textit{typed-contracts} Haskell library is developed that annotates an arbitrary section of Helium code with contracts inferred by the extended contract inference algorithm.
We provide some examples of the improved feedback of our system compared to the less-detailed feedback of Ask-Elle given the same inputs.
\end{abstract}

\tableofcontents

\chapter{Introduction}

The Ask-Elle \cite{Gerdes:2012:phd} programming tutor is a web-based programming tutor that provides feedback on a student's progress in programming exercises in a language similar to Haskell, named Helium.
To facilitate this, the system is given several solutions to an exercise when defining an exercise.
It then uses strategies to reduce a student's input to one of these solutions, even identifying how many steps the input is removed from the solution.
Ask-Elle can then provide hints and other forms of feedback to help along the student.
Because it is possible that a student may come up with a solution that is not among the solutions provided to Ask-Elle, QuickCheck \cite{Claessen:2000p592} properties, which describe the properties of a correct solution, can be defined for an exercise.
For instance, one of the properties of a sorting function is that the sorted list must be a permutation of the original list: no elements may be removed or added during sorting.


To test the student's solution, inputs are randomly generated and applied to the proposed solution until an input causes a violation of the properties (called a \textit{counter-example}) or a testing limit is reached.
In the case of a failed test, Ask-Elle provides the student with the counter-example as feedback.
Compared to the rich feedback when a solution strategy can be identified, this information requires the student to take the counterexample and step through his code to attempt locating the programming error.

The motivation behind the Master Thesis of Jurri\"en Stutterheim \cite{Stutterheim:2013:thesis} is to fill this void in the system's feedback.
To do so, he develops a contract inference system for functional programs, producing a contract inference algorithm for a simply-typed lambda calculus and proving the algorithm sound.

Stutterheim aimed to combine the QuickCheck properties with the contract inference algorithm to generate contracted code that, in the event of a contract violation due to a counter-example generated by QuickCheck, would pinpoint exactly where the issue lies in a student's code.
The integration of the contract inference system in the Ask-Elle programming tutor remained future work.

This thesis builds upon Stutterheim's work, extending the contract inference algorithm to work with the syntax Ask-Elle uses to represent a student's code.
This syntax is a slightly leaner version of the full Helium syntax, itself a subset of the Haskell programming language.
More precisely, Helium is a subset of the Haskell 98 language specification.

Additionally, a code generation system is developed for the \textit{typed-contracts} library by Hinze et al.\cite{Hinze06typedcontracts}, a Haskell library to define and assert contracts on functions.
This code generation system is largely library-agnostic and can be extended or adapted to generate code for different libraries.

In the following chapter, we provide the reader with a background on contracts in functional programming languages, using examples from the \textit{typed-contracts} library to explain the concept.
Furthermore, we quickly go through the results of Stutterheim's thesis to understand the foundations upon which this thesis is built.
Related work in contracts and contract inference is discussed, as well.
Chapter \ref{chapter-overview} provides an overview of our improvements upon Stutterheim's work.
Chapter \ref{chapter-system-design} follows the flow of a code module as it goes through the entire system, the main parts consisting of the contract inference and code generation subsystems.
As we encounter each subsystem, we explain key concepts, definitions and how the system differs from Stutterheim's original work (if applicable).
In Chapter \ref{futurework}, we discuss improvements that can be made to our contract inference algorithm and other future work.
We conclude in Chapter \ref{chapter-conclusion}.

\chapter{Background}

In this chapter, we familiarize the reader with some concepts that are used in the rest of this thesis, the most important ones being \textit{contracts} and the notion of \textit{inferring} types and contracts.

This thesis concerns itself with \textit{contract inference}.
Let us break up this term and investigate each element thoroughly before moving on.

\section{Contracts}
In programming, a $contract$ is very much like its real-world counterpart: it stipulates prerequisites and guarantees between two parties.
In our case, the parties are the function being called (the $callee$) and the function receiving the result (the $caller$).

As a simple example, one could specify a contract that a function will only accept a natural number: a prerequisite.
Likewise, it is possible to state that a function must also always return a natural number: a guarantee.
By combining prerequisites and guarantees for arguments and results, respectively, it is possible to construct very specific contracts that are quite useful for tracking down bugs.
Just like in real life, these contracts can be violated.

Checking for violations can be done during compile time or at runtime.
If done at compile time, the compiler will produce an error message.
If contract checking is done during runtime, the program will halt with an exception.
In both cases, the message details which contract was violated at what position in the code.

When a contract violation happens, blame must be assigned.
A prerequisite violation is to be blamed on the $caller$: it was this function that should have provided a valid argument.
Likewise, a guarantee violation is to be blamed on the $callee$: there is a fault in the function being called that causes it to return an invalid result.

In other words, adding contracts to one's code adds an element of automated testing and aids in debugging any faults that may arise by being able to specify what exactly went wrong, and where.

This thesis builds upon the thesis of Stutterheim \cite{Stutterheim:2013:thesis}, who developed an algorithm for contract inference on a simple recursive let lambda language with support for holes.
While Stutterheim's contract grammar is library-agnostic, he chose to generate code for the \textit{typed-contracts} library by Hinze et al. \cite{Hinze06typedcontracts}. 
Also of interest is the library by Chitil \cite{Chitil:2012ua}, which is based on the work of Hinze et al.
This newer library preserves a program's lazy semantics, which the \code{typed-contracts} library does not.

\subsection{The \textit{typed-contracts} library}
Let us examine the library for which code will be generated.
Hinze et al. define the \code{Contract} type using a GADT:

\begin{lstlisting}[mathescape]
data Contract a where
   Prop      :: (a $\rightarrow$ Bool) $\rightarrow$ Contract a
   Function  :: Contract a $\rightarrow$ (a $\rightarrow$ Contract b) $\rightarrow$ Contract (a $\rightarrowtail$ b)
   Pair      :: Contract a $\rightarrow$ (a $\rightarrow$ Contract b) $\rightarrow$ Contract (a, b)
   List      :: Contract a $\rightarrow$ Contract [a]
   Functor   :: Functor f $\Rightarrow$ Contract a $\rightarrow$ Contract (f a)
   Bifunctor :: Bifunctor f $\Rightarrow$ Contract a $\rightarrow$ Contract b $\rightarrow$ Contract (f a b)
   And       :: Contract a $\rightarrow$ Contract a $\rightarrow$ Contract a
\end{lstlisting}

Let us go over each data constructor:
\begin{description}
	\item{\code{Prop} } is what one uses to actually define a constraint or property on a value. Given a function that expects a value of type \code{a} and which returns a Boolean, it produces a contract for something of type \code{a}. In other words, it lifts a function to a contract.
	\item{\code{Function} } is used to define a dependent function contract, depicted as a tailed function arrow: \code{$\rightarrowtail$}.
	\item{\code{Pair} } similarly defines a dependent pair contract.
	\item{\code{List} } is straightforward: it lifts contracts to the list level.
	\item{\code{Functor} } is a container that can house types of kind $* \rightarrow *$.
	\item{\code{Bifunctor} } is the same as \code{Functor}, but takes types of kind $* \rightarrow * \rightarrow *$ into account.
	\item{\code{And} } is used to chain several contracts together: all of them are asserted when a value is provided. 
\end{description}

Now that we know how a \code{Contract} can be constructed, let us look at a few examples. 
The very first example is the one we used when first introducing the concept of contracts, namely a contract that constrains a function such that it demands a natural number as its input, and the guarantee that it will return a natural number, too:

\begin{lstlisting}[mathescape]
natInNatOut :: Contract (Int $\rightarrowtail$ Int)
natInNatOut = nat $\rightarrowtail$ nat
\end{lstlisting}

We need a way to attach this contract to such a function, which is what the \code{assert} function is for:

\begin{lstlisting}[mathescape]
increase :: Int $\rightarrowtail$ Int
increase = assert "increase" natInNatOut (fun ($\lambda$n $\rightarrow$ 1 + n))
\end{lstlisting}

Note how the type of \code{increase} does not reflect the natural number constraints imposed by the contract, because the contract is asserted at runtime.

The \code{fun} function lifts a function to a contracted one, one argument at a time:

\begin{lstlisting}[mathescape]
fun :: (a $\rightarrow$ b) $\rightarrow$ (a $\rightarrowtail$ b)
\end{lstlisting}

Conversely, the \code{app} function lifts function application to contracts:

\begin{lstlisting}[mathescape]
app :: (a $\rightarrowtail$ b) $\rightarrow$ Int $\rightarrow$ a $\rightarrow$ b
\end{lstlisting}

The integer provided to \code{app} is used to tag the function application and is referred to during feedback.

By applying these functions, the contracted version of a function can replace its regular version without issue.
In this way, the contract mechanism acts as a partial identity function, because it either raises an exception when a contract is violated, or it returns the asserted value unmodified.
This behaviour is clearly reflected in the type of \code{assert}:

\begin{lstlisting}[mathescape]
assert :: String $\rightarrow$ Contract a $\rightarrow$ (a $\rightarrow$ a)
\end{lstlisting}

From this type, we also see why functions must be lifted to the contract level before they can be asserted.
For example, if \code{a} maps to \code{Int $\rightarrowtail$ Int}, as it does for the \code{increase} example, the \code{assert} function expects a contract of type \code{Contract (Int $\rightarrowtail$ Int)}, and a contracted function of type \code{Int $\rightarrowtail$ Int}.

To clearly illustrate how \code{assert} works, we leave out the first \code{String} argument, which is used in feedback. We also omit some code pertaining to location information, also used for feedback purposes.

\begin{lstlisting}[mathescape]
assert (Prop p)         a   = if p a then a else error "contract failed"

assert (Function c$_1$ c$_2$) f	    = ($\lambda$x $\rightarrow$ (assert (c$_2$ x) . f) x) . assert c$_1$

assert (Pair c$_1$ c$_2$) (a$_1$,a$_2$)     = ($\lambda$a$'_1 \rightarrow$(a$'_1$,assert (c$_2$ a$'_1$) a$_2$)) (assert c$_1$ a$_1$)

assert (List c)         as  = map (assert c) as

assert (Functor f)      as  = fmap (assert f) as

assert (Bifunctor c$_1$ c$_2$) as   = bimap (assert c$_1$) (assert c$_2$s) as

assert (And c$_1$ c$_2$)        a   = (assert c$_2$ . assert c$_1$) a
\end{lstlisting}

Let's go over each case to understand what happens:

\begin{description}
	\item{\code{Prop} :} When asserting a property, we apply the predicate to the supplied value. If the predicate holds, this function acts as the identity function. If it does not hold, however, an exception is raised. In the unabridged code, the exception message also includes the position of the violation in the source code.
	\item{\code{Function} :} For a \code{Function} contract, we first assert $c_1$ on the input of the function $f$. If this assertion holds, we pass the value $x$ to $f$, as can be seen in the lambda function. The result of $f x$ is then used to assert the codomain of the function using $c_2$.
	\item{\code{Pair} :} Similarly, the \code{Pair} contract first asserts the contract $c_1$ to the first element in the pair. Provided it succeeds, the first element is passed to $c_2$. The resulting contract $(c_2$ $a'_1)$ is then used to assert the second element of the pair.
	\item{\code{List}, \code{Functor}, \code{Bifunctor} :} These are all quite similar. The contract to be asserted is mapped over the elements of a container.
	\item{\code{And} :} This contract is used to combine two contracts, so asserting one implies that both contracts hold on the provided value.
\end{description}

Now that we know how contracts are constructed and asserted, let us look at some convenience functions that will be used throughout this thesis:

\begin{lstlisting}[mathescape]
c$_1$ $\rightarrowtail$ c$_2$		= Function c$_1$ (const c$_2$)
(&)		= And
c$_1$ $\functor$ c$_2$		= c$_1$ & Functor c$_2$
c$_1$ $\bifunctor$ (c$_2$,c$_2$)	= c$_1$ & Bifunctor c$_2$ c$_3$
\end{lstlisting}

The first definition allows us to define a non-dependent function contract, and the second is some simple syntactical sugar.
The last two definitions merit some more detail.
Along with (a) contract(s) for the elements of a container, a contract for the container in its entirety is provided as well in the form of $c_1$.
A simple example why this is useful, is the guarantee that a list is sorted when it is returned by a sorting function.
Such a property cannot be captured by any contract for a container's elements, as these elements only know about themselves and not about other elements in the container.
Therefore, we require container-wide contracts, which are also called "outer contracts".
Conversely, contracts for a container's elements are referred to as "inner contracts".

With these functions, we can easily describe complex contracts.
Let us look at an example.
First, we define two fundamental contracts, namely \code{true} and \code{false}, which always succeed and always fail, respectively, regardless of their input:

\begin{lstlisting}[mathescape]
true, false :: Contract a
true  = Prop ($\lambda$_ $\rightarrow$ True)
false = Prop ($\lambda$_ $\rightarrow$ False)
\end{lstlisting}

Let us construct a few contracts for the \code{head} function that will not raise an exception.
The very first contract is simply the \code{true} contract itself, which will take the entire \code{head} function as an argument.
But the contract could be made more specific:

\begin{lstlisting}[mathescape]
true $\rightarrowtail$ true :: Contract ([a] $\rightarrowtail$ a)
\end{lstlisting}

In this case, the \code{true} contract is asserted on both the input and output of the \code{head} function, but no longer on the function in its entirety.
We can make it even more specific:

\begin{lstlisting}[mathescape]
(true $\functor$ true) $\rightarrowtail$ true :: Contract ([a] $\rightarrowtail$ a)
\end{lstlisting}

Using the functor contract $\functor$, the \code{true} contract is asserted on the input list in its entirety, as well as each of its elements, along with the output of the function.

Up until now, we've only used the \code{true} contract.
But we can also use contract variables to express relations between the input and output of a function. 
A further refinement of the contract for \code{head} exemplifies this:

\begin{lstlisting}[mathescape]
(c$_{outer}$ $\functor$ c$_{inner}$) $\rightarrowtail$ c$_{inner}$ :: Contract ([a] $\rightarrowtail$ a)
\end{lstlisting}

It makes sense that the element that is extracted from the list still obeys the contract $c_{inner}$.
With this knowledge, let us look at a higher-order example: \code{fmap}.
By using the functor contract again, we can define a contract for \code{fmap}:

\begin{lstlisting}[mathescape]
(c$_1$ $\rightarrowtail$ c$_2$) $\rightarrowtail$ (c$_3$ $\functor$ c$_1$) $\rightarrowtail$ (c$_4$ $\functor$ c$_2$)
\end{lstlisting}

Note how the contract variables of the contract are very similar to the type variables of the type of \code{fmap}:

\begin{lstlisting}[mathescape]
fmap :: (a $\rightarrow$ b) $\rightarrow$ f a $\rightarrow$ f b
\end{lstlisting}

The contract variables $c_1$ and $c_2$ correspond to type variables $a$ and $b$, respectively.
Generally, we cannot perform such a mapping over containers, so they are assigned different contract variables: $c_3$ and $c_4$.
During a process called inference, it may turn out that these variables are equal, but this information is usually not deducible from the function's type.

To understand why, let us look at the following example:

\begin{lstlisting}[mathescape]
listPlus, listId :: [Int] $\rightarrow$ [Int]
listPlus = map (+1)
listId = map id

atMostTen :: Contract Int
atMostTen = Prop ($\lambda$n $\rightarrow$ n <= 10)

mapContract = (true $\rightarrowtail$ true) $\rightarrowtail$ (c$_3$ $\functor$ true) $\rightarrowtail$ (c$_4$ $\functor$ true)
\end{lstlisting}

When asserting \code{listId [1..10]} with the contract \code{mapContract}, we can safely replace both $c_3$ (which must be valid for the input) and $c_4$ (which must be valid for the output) with \code{atMostTen} without causing a contract violation.
If we do the same for \code{listPlus [1..10]}, however, we \textit{will} cause a contract violation, as the resulting list will contain an integer larger than 10.

Section \ref{background-inference} explains the concept of inference and its use in refining contracts even further.

At the moment, we have learned how contracts are composed and how they can be attached to functions that are lifted using the \code{fun} function.
We have also briefly encountered the \code{app} function, which lifts function application to contracts.
Apart from applying something to a contracted function, this function provides crucial information for use in feedback:

\begin{lstlisting}[mathescape]
app :: (a $\rightarrowtail$ b) $\rightarrow$ Int $\rightarrow$ a $\rightarrow$ b
app f loc x = apply f (makeloc (App loc)) x
\end{lstlisting}

In order to be able to precisely blame the expression that caused a violation, \code{app} expects an integer to be used as a location label in the feedback.

Here is an example of a contract violation:

\begin{lstlisting}[mathescape]
> app increase 1 (-5)
> *** Exception: contract failed: the expression labeled `1' is to blame.
\end{lstlisting}

Because $(-5)$ is not a natural number, it is the reason for the contract violation, and is blamed accordingly using the location label.
In this thesis, we enrich this feedback by including position information and displaying the value responsible for the contract violation.

For brevity, we do not expand upon the inner workings of the blaming system.
Details can be found in Hinze et al's paper \cite{Hinze06typedcontracts}.

\section{Contract inference}
\label{background-inference}

In computer science, the notion of \textit{inference} most often refers to the method of \textit{type inference}, which automatically deduces types for expressions written in a programming language.

For functional programs, the Hindley-Milner type inference system described by Damas and Milner \cite{Damas:1982ve} is the most well-known.
The thesis of Stutterheim \cite{Stutterheim:2013:thesis} builds upon this system, producing an algorithm for deducing \textit{contracts} from expressions written in a simple let-polymorphic lambda calculus.

\subsection{Goals of contract inference}
Stutterheim set out three goals for his contract inference system, shown in figure \ref{fig:goals-stutterheim-contract-inference}.

\begin{figure}[htps]
\begin{framed}
\begin{center}
\begin{itemize}
	\item Infer a well-typed contract for every function in a program
	\item Inferred contracts must allow a (non-strict) subset of the values allowed
by the types
	\item The most general inferred contract must never fail an assertion
\end{itemize}
\end{center}
\end{framed}
\attrib{{\em{Contract inference for Functional Programs}}, page 12}
\caption{\label{fig:goals-stutterheim-contract-inference}Stutterheim's goals for contract inference.}
\end{figure}

The first goal states that, given a well-typed program, the algorithm must infer a contract for every function and its components.
The second goal is sensible: any values constrained by the contract of an expression should be a subset of the inhabitants of the type of that expression.
Lastly, the third goal implies that asserting any inferred contract is equal to the identity function.
In other words, inferred contracts should never cause a contract violation.

\subsection{Language used}

The contract inference algorithm works on $\lambda_c$, a let-polymorphic lambda calculus shown in figure \ref{stutterheim-lambda-language}.

\begin{figure}[htps]
\begin{lstlisting}[mathescape]
$expr$      ::=   x				-- Variable
        |   $\lambda$$expr$ $\rightarrow$ $expr$				-- Lambda abstraction
        |   $expr$ $expr$				-- Application
        |   let $expr$ = $expr$ in $expr$			-- Let binding
        |   case $expr$ of			-- Case block
              { $expr$ $\rightarrow$ $expr$ (; $expr$ $\rightarrow$ $expr$)* }
        |   $const$				-- Constants
        |   $expr$ : $expr$				-- List cons constructor
        |   []				-- List nil constructor
        |   Just $expr$			-- Maybe Just constructor
        |   Nothing			-- Maybe Nothing constructor
        |   ($expr$, $expr$)			-- Pair
        |   Left $expr$			-- Either left constructor
        |   Right $expr$			-- Either right constructor
        |   $expr$ $\oplus$ $expr$				-- Binary operation
        |   ?				-- Holes


$const$      ::=   n				-- Integers
        |   b				-- Booleans
        |   c				-- Characters
        |   s				-- Strings
\end{lstlisting}
\caption{\label{stutterheim-lambda-language}The $\lambda_c$ language.}
\end{figure}

\subsection{Contract grammar}

Contracts are generated in an intermediate language-agnostic grammar (figure \ref{fig:stutterheim-intermediate-contract-grammar}), which can be translated to library-specific contracts.

\begin{figure}[htps]
\begin{center}
\begin{lstlisting}[mathescape]
  -- Contracts
  c ::=  $\rho_{\alpha}$			-- User-defined concrete contract
      |  $true_{\alpha}$			-- true contract
      |  $false_{\alpha}$			-- false contract
      |  $c_{\alpha} \rightarrowtail c_{\beta}$			-- Function contracts
      |  $c_{\alpha} \functor c_{\beta}$			-- Functor contracts
      |  $c_{\alpha} \bifunctor (c_{\beta}, c_{\gamma})$			-- Bifunctor contracts
      |  $int_{\alpha}$			-- Succeeds for all integers
      |  $bool_{\alpha}$			-- Succeeds for all booleans
      |  $char_{\alpha}$			-- Succeeds for all characters
      |  $string_{\alpha}$			-- Succeeds for all strings
      |  $list_{\alpha}$			-- Succeeds for all lists
      |  $either_{\alpha}$			-- Succeeds for all $Either$s
      |  $maybe_{\alpha}$			-- Succeeds for all $Maybe$s
      |  $pair_{\alpha}$			-- Succeeds for all pairs
  -- Contract schemes
  $\sigma$ ::=  $c$			-- Contract
      |    $\forall{true_{\alpha}}.\sigma$			-- Universal quantification for contract 
				-- indices
\end{lstlisting}
\end{center}
\caption{\label{fig:stutterheim-intermediate-contract-grammar}Intermediate grammar for the contracts.}
\end{figure}

We have already seen some examples of user-defined contracts as well as the definitions of the \code{true} and \code{false} contracts in the \textit{typed-contracts} library.
But in this grammar, the contracts $true$, $false$ and $\rho$ also have an index $\alpha$ that is used to differentiate between different instances of the same type of contract.
This index serves the same purpose as fresh type variables in Algorithm \W.
\textit{"Generating a fresh contract"} is a commonly used phrase in this thesis that refers to a fresh indexed contract.

The syntax of the contracted function arrow ($\rightarrowtail$), functor ($\functor$) and bifunctor ($\bifunctor$) is the same as that of its inspiration, the \textit{typed-contracts} library syntax.

Stutterheim illustrates in his thesis that dependent function contracts are troublesome to use in contract inference, so these are omitted from the grammar.

Terminals for literals and several container data types are available as default contracts for the corresponding types.

Contract schemes are used to universally quantify over $true$ contracts.

\subsection{Contract relations and refinement}

Before the algorithm itself is described, Stutterheim defines relations between contracts by "regarding contracts as sets of Haskell values" and using set-theoretic operations on these sets.
He uses these relations to formally define the notion of \textit{contract refinement}, where a contract that constrains a set of values is replaced by another contract that constrains a subset of those values.
This concept is what drives the contract inference algorithm.

\subsection{Algorithm \CW}
The algorithm itself is very much alike Algorithm \W:

\begin{itemize}
	\item A contract environment $\Gamma$ is defined that maps variables to contracts.
	\item Use of generalization and instantiation to introduce and remove universally quantified $true$ contracts, respectively.
	\item A modified version of Robinson's unification algorithm that checks for free \textit{contracts} during the occurs check. It also ensures that substitutions always refine the contract.
\end{itemize}

Stutterheim proves that the algorithm is sound with respect to the contracting rules in his thesis.
For brevity, we do not replicate the proofs, contracting rules, unification rules nor code for Algorithm \CW ~here.
These elements can be found in subsection 3.4 of Stutterheim's thesis \cite{Stutterheim:2013:thesis}.

%Can we refine the contract even more without risking raising an exception?
%It appears we cannot: we have reached a fixed point for a contract that will never raise an exception, regardless of the values it is provided.
%
%In section 3.3 of his thesis, Stutterheim defines relations between contracts by "regarding contracts as sets of Haskell values" and using set-theoretic operations on these sets.
%With these relations, he is able to define the notion of a \textit{most specific} contract:
%
%\begin{quotation}
%"..the inferred contract is also the most specific contract. I.e., the semantics of the inferred contract is a subset of any other contract that can be described in the contract system. (..) Intuitively, this seems true, because \textit{(contract inference algorithm)} \CW ~will infer contracts specific to certain types."
%\end{quotation}
%
%The contract in figure \ref{fig:head-contract-fixed-point} is close to being a \textit{most specific} contract.
%The only difference between our contract and the most specific contract, is that latter has been passed through Stutterheim's contract inference algorithm.
%
%Comparing this contract with the type of \code{head} shows that they are very similar:
%
%\begin{figure}[htbp]
%\begin{lstlisting}[mathescape]
%head_ctrt :: Contract ([aT] $\rightarrowtail$ aT)
%head_ctrt = (true $\functor$ true) $\rightarrowtail$ true
%
%head :: [a] $\rightarrow$ a
%\end{lstlisting}
%\caption{\label{fig:resemblance-contract-type}A strong resemblance between contracts and types.}
%\end{figure}
%
%This is not a random occurence: in Conjecture 1 of Stutterheim's thesis, he speculates that, 
%
%
%
%The example we have just viewed showed us how we can increase the specificity of a contract, starting from the \code{true} contract and working towards a very specific contract from there.
%This is how Stutterheim's contract inference system operates.
%In this thesis, we will exploit the resemblance shown in figure \ref{resemblance-contract-type} to simplify contract inference by providing the inference algorithm with the generalized version of the most specific contract for a given expression.
%A generalized contract is one that purely uses 
%
% relation the fact that we can generate a most specific contract from a type
%
%In fact, it is possible to generate a most specific generic contract from the type of the expression.

%\section{Ask-Elle programming tutor}
%We have seen how contracts can be used to pinpoint specific locations in a section of code in the event of a contract violation.
%We have also witnessed how contracts can be automatically inferred from a section of code using Stutterheim's Algorithm \CW.
%These inferred contracts can be used to generate a fully contracted version of the original section of code.
%
%Stutterheim aimed to combine the QuickCheck properties available in the Ask-Elle programming tutor with the contract inference algorithm to generate contracted code that, in the event of a contract violation due to a counter-example generated by QuickCheck, would pinpoint exactly where the issue lies in a student's code.
%This functionality was to be integrated into the Ask-Elle programming tutor, but remained future work.
%
%Because this thesis builds upon Stutterheim's work, the syntax used by Ask-Elle is the language that we construct a contract inference algorithm for.

\section{Related work concerning contracts}
\label{section:relatedworkcontracts}
The concept of contracts dates back to the Eiffel programming language \cite{Meyer:1988wp} in 1988, which included it as a language feature.
Many other languages support contracts, or have libraries available to achieve the same functionality.

In a functional setting, contracts are less popular, but there has been a lot of research in this field.
Initial steps were taken by Findler and Felleisen \cite{Findler:2002:CHF:583852.581484}, who defined a typed lambda calculus with support for contracts for higher-order functions in the Scheme language.
For Haskell, Hinze et al. \cite{Hinze06typedcontracts} developed a dynamic contract library that builds upon Findler and Felleisen's findings. 
A static approach was taken by Xu et al. \cite{Xu:2006ul, Xu:2009:SCC:1594834.1480889}, allowing contracts to be checked using symbolic computation at compile-time. This technique is similar to that of refinement types, which we will cover in a later paragraph.

Degen et al. \cite{DegenThiemannWehr2009} provide an overview of contract implementation in lazy languages and their pitfalls, demonstrating how each form of dynamic contract monitoring (eager, semi-eager and lazy) is inherently flawed, either changing program behavior or ignoring contract violations.
The article also touches upon Xu's work on static contract systems, which the authors argue is similar to the eager monitoring style they discuss in their article.
Eager contract monitoring is preferred by the authors as all contracts defined in it are faithful: they will always evaluate to their actual value, which implies that, if a program terminates, all of the contracts within it will have evaluated to true.

Other researchers have explored enriching the type system to replace the functionality offered by contracts, producing what is commonly called "refinement types".
A refinement type contains a predicate that is assumed to hold for the elements of the refined type, constraining the inhabitants of the type in the same way as a contract does.

Rondon et al. \cite{rondon2008liquid} have developed a set of data types called Logically Qualified Data Types, often shortened to Liquid Types.
Using liquid types, they are able to embed a decidable subset of dependent typing functionality in a Hindley-Milner typing system.
With only the HM types and a predefined set of logical qualifiers, their algorithm is able to infer liquid types, which are dependent types that consist of conjunctions of the aforementioned logical qualifiers.
After inferring these liquid types, they can be resolved using an SMT solver.
In the end, one ends up with the strongest constraint possible on the expression that can be generated with the provided set of logical qualifiers.
Implementations of liquid typing are available for OCaml \cite{rondon2008liquid} and Haskell (using GHC) \cite{rondon2013refinement}.
The Haskell implementation is able to provide feedback if type checking fails, indicating the position(s) in the source code where things have gone wrong.
Additionally, a HTML file is generated of the processed source code annotated with the inferred types.

A similar approach was taken by Vytiniotis et al. \cite{Vytiniotis:2013ww}, whose framework converts contracts written in Haskell into a simpler lambda calculus, which itself is translated into first-order logic formulae.
Finally, these formulae are solved using an off-the-shelf theorem solver.

Terauchi \cite{terauchi2010dependent} also builds upon the recent developments in refinement types to present a system that is able to infer dependent types for a subset of the OCaml language without external input.
Instead of taking a user-provided set of formulas, the algorithm uses counterexample guided abstraction refinement (CEGAR) to iteratively refine a lattice of candidate dependent types.
Counterexamples are parts of the program that are untypable with the current lattice of candidate types.
The algorithm then attempts to type the program with all available types instead of the lattice.
If typing succeeds, the new candidates are added to the lattice and a new counterexample is selected.
If it fails, then the program is untypable.
As the algorithm itself generates the set of candidates, users can be sure that if the program is untypable, it really is untypable.
On the other hand, because the types are inferred automatically, they are not necessarily the strongest types available.

Ranjit et al. \cite{jhala2010refinement} take another route to attain refinement types: they first attain refinement type constraints using the implementation of Rondon et al. \cite{rondon2008liquid}, and then translate these types to a first-order imperative program.
If and only if the assertions of this imperative program hold, the higher-order program typechecks.
This verification can be done using several abstract interpretation techniques (of which CEGAR is one), which have readily available implementations for imperative languages.
The proof of safety of the imperative program translates to the solutions of the refinement type constraints.
Thus, these can be used to annotate the original higher-order program, obtaining the refinement types.

Cousot et al. \cite{cousotabstract} have implemented automatic contract inference for method extraction, a common refactoring technique.
They provide implementations for C\# and Visual Basic .NET.
The inferred contract satisfies four requirements: (i) it is valid for the extracted method; (ii) the contract takes into account language and programmer assertions; (iii) the contract of the refactored code is as precise as the non-refactored code, and (iv) the contract is as general as possible.
The authors use an iterative approximation algorithm to attain contracts that fulfill these requirements, and prove that an exact solution is uncomputable.

The articles of Dimoulas \& Felleisen \cite{Dimoulas:2011:CSH:2039346.2039348} and Greenberg et al. \cite{Greenberg:2010:CMM:1707801.1706341} provide an excellent overview of recent developments pertaining to contracts, as well as as detailed comparisons between the different libraries and frameworks. \cite{Dimoulas:2011:CSH:2039346.2039348} also goes into greater detail of the semantics of contract satisfaction.
Findler and Wadler \cite{Wadler:2009:WPC:1532974.1532976} provide a unified view of several type enrichments, yielding a system they call evolutionary types.
This system can be used to 'evolve' dynamically typed programs into statically typed ones and do the same for statically typed programs, 'evolving' them into programs with refinement types.

Another form of type enrichment that enforces constraints is dimensional typing.
In short, a (usually numerical) value is given a dimension (time, length, mass, etc.).
Either through static analysis and inference or through type-level programming, these constraints can be enforced, ensuring that nonsensical operations, such as adding a time value and a mass value, are caught at compile-time.
Kennedy's thesis \cite{langanddim} explores this domain extensively for the ML language. 
A number of dimensional typing libraries are available for Haskell, most of which are defined using type-level programming or using type families.
Some simply constrain the input and output of functions, while others perform automatic conversion between compatible types, for example between meters and inches.

\chapter{Contributions}
\label{chapter-overview}

The contract inference system devised by Stutterheim is a solid base upon which we can build to support a language such as Helium:

\begin{itemize}
	\item The grammar to describe a contract is library-agnostic. It borrows several elements from the \textit{typed-contracts} library by Hinze et al. \cite{Hinze06typedcontracts}, which it uses as the example library to describe its code generation procedure.
	\item Using simple set-theoretic operations, Stutterheim defines relations between contracts, which he uses to prove how a contract can be more general than another.
	\item The language used, $\lambda_c$, is a simple let-polymorphic lambda calculus.
	\item His contract inference algorithm \CW ~is based upon Milner's Algorithm \W ~and uses Robinson's unification algorithm, two well-understood algorithms.
\end{itemize}

There are a few limitations in Stutterheim's system that we address:

\begin{itemize}
	\item A system for code generation is left implicit in Stutterheim's thesis. Feedback towards a user is also not discussed.
	\item Substitutions generated by algorithm \CW ~are placed in a global set. Conflicting substitutions may result in generating an inferred contract that causes a violation during assertion.
\end{itemize}

The following limitations are \textit{not} addressed by us:

\begin{itemize}
	\item Inability of Algorithm \CW ~to handle dependent contracts.
	\item Lack of constant expression contracts.
	\item Integration with the Ask-Elle programming tutor.
\end{itemize}

We improve upon Stutterheim's system in the following ways:
\begin{itemize}
	\item The language we use is a slightly simplified version of the Helium language, a dialect of Haskell that is a subset of the Haskell 98 language specification.
	\item Using type information, we perform abstract syntax tree (AST) transformations to simplify the contract inference algorithm.
	\item With the same information, we generate \textit{initial contracts} that simplify contract inference even further, especially in the case of mutually recursive functions.
	\item Algorithm \CW ~is extended to support the aforementioned Helium dialect, producing Algorithm \CHW.
	\item Substitutions are divided into two lists: global and local. This avoids the problem of contract violations by inferred contracts inherent to the original system.
	\item We provide a system to generate code for the \textit{typed-contracts} library and identify several library-agnostic techniques to enrich feedback.
\end{itemize}

Furthermore, we modify the \textit{typed-contracts} library to allow for a richer form of feedback.

\chapter{System design}
\label{chapter-system-design}

In this chapter, we explain the improvements we have made to Stutterheim's system in detail.
The chapter follows a similar structure to the path code is put through as illustrated in section \ref{section:overview}.

Before providing an overview of the system, we introduce the syntax for our abstract syntax tree (AST), which is a slightly modified version of the syntax the Ask-Elle programming tutor uses.
After the overview, we follow the flow of the abstract syntax tree as it goes through the entire system, starting with several AST transformations, after which we enter the code generation system, which consists of contract generation and -inference, and code generation.
As we encounter each subsystem, we explain key concepts and definitions.

\section{Syntax}
The Ask-Elle programming tutor uses its own version of the Helium syntax, casting aside some things such as type signatures and other syntax constructs that are irrelevant to Ask-Elle.
Helium itself is a subset of the Haskell 98 language specification, its main missing component being user-definable type classes.

We have slightly modified the syntax used by the Ask-Elle system:
\begin{itemize}
	\item Fields to store range information were added to nearly all nodes. Range information consists of the line and column number of the node and its source (standard input, file, unknown) if this information is available.
	\item In Ask-Elle, constructors that use a list of patterns or expressions use the \code{Pats} and \code{Exprs} type synonyms, respectively. For example, expressions that describe a tuple or a list both use \code{Exprs}. However, from the viewpoint of contract inference, these expressions could not be more different! The solution is simple: tuples and lists in patterns and expressions use the type synonyms \code{ListPatsR}, \code{TuplePatsR}, \code{ListExprR} and \code{TupleExprR}. All other constructors remain unchanged.
\end{itemize}

This modified syntax can be downcast to the regular Ask-Elle syntax, and partially upcast to the Helium syntax.

In the rest of this thesis, we omit the \code{R} from the syntax for aesthetic reasons.

\begin{multicols}{2}
\begin{lstlisting}[caption=Our modified Ask-Elle syntax.]

-- | A Haskell source module
data ModuleR
   | ModuleR
      name     :: MaybeNameR
      body     :: BodyR
      range    :: RangeR

data BodyR
   | BHoleR
      id       :: HoleIDR
      range    :: RangeR
   | BodyR
      decls    :: DeclsR
      range    :: RangeR

-- | Declarations
data DeclR
   | DHoleR
      id       :: HoleIDR
      range    :: RangeR
   | DEmptyR
      range    :: RangeR
   | DFunBindsR
      funbinds :: FunBindsR
      range    :: RangeR
   | DPatBindR
      pat      :: PatR
      rhs      :: RhsR
      range    :: RangeR

type DeclsR = [DeclR]

-- | Expressions
data ExprR
   | HoleR
      id       :: HoleIDR
      range    :: RangeR
   | FeedbackR
      feedback :: String
      expr     :: ExprR
      range    :: RangeR
   | MustUseR
      expr     :: ExprR
      range    :: RangeR
   | CaseR
      expr     :: ExprR
      alts     :: AltsR
      range    :: RangeR
   | ConR
      name     :: NameR
      range    :: RangeR
   | IfR
      cond     :: ExprR
      then     :: ExprR
      else     :: ExprR
      range    :: RangeR
   | InfixAppR
      left     :: MaybeExprR
      op       :: ExprR
      right    :: MaybeExprR
      range    :: RangeR
   | LambdaR
      pats     :: PatsR
      expr     :: ExprR
      range    :: RangeR
   | LetR
      decls    :: DeclsR
      expr     :: ExprR
      range    :: RangeR
   | LitR
      lit      :: LiteralR
      range    :: RangeR
   | AppR
      fun      :: ExprR
      args     :: ExprsR
      range    :: RangeR
   | ParenR
      expr     :: ExprR
      range    :: RangeR
   | TupleR
      exprs    :: TupleExprR
      range    :: RangeR
   | VarR
      name     :: NameR
      range    :: RangeR
   | EnumR
      from     :: ExprR
      then     :: MaybeExprR
      to       :: MaybeExprR
      range    :: RangeR
   | ListR
      exprs    :: ListExprR
      range    :: RangeR
   | NegR
      expr     :: ExprR
      range    :: RangeR

type ExprsR = [ExprR]
type ListExprR = [ExprR]
type TupleExprR = [ExprR]

data MaybeExprR
   | NoExprR
   | JustExprR
      expr     :: ExprR

-- | Alternatives
data AltR
   | AHoleR
      id       :: HoleIDR
      range    :: RangeR
   | AltR
      feedback :: {Maybe String}
      pat      :: PatR
      rhs      :: RhsR
      range    :: RangeR
   | AltEmptyR
      range    :: RangeR

type AltsR = [AltR]

-- | Function bindings
data FunBindR
   | FBHoleR
      id       :: HoleIDR
      range    :: RangeR
   | FunBindR
      feedback :: {Maybe String}
      name     :: NameR
      pats     :: PatsR
      rhs      :: RhsR
      range    :: RangeR

type FunBindsR = [FunBindR]

-- | Guarded expressions
data GuardedExprR
   | GExprR
      guard    :: ExprR
      expr     :: ExprR
      range    :: RangeR

type GuardedExprsR = [GuardedExprR]

-- | Literal values
data LiteralR
   | LCharR
      val      :: Char
      range    :: RangeR
   | LFloatR
      val      :: Float
      range    :: RangeR
   | LIntR
      val      :: Int
      range    :: RangeR
   | LStringR
      val      :: String
      range    :: RangeR

-- | Names
data NameR
   | IdentR
      name     :: String
      range    :: RangeR
   | OperatorR
      name     :: String
      range    :: RangeR
   | SpecialR
      name     :: String
      range    :: RangeR

data MaybeNameR
   | NoNameR
   | JustNameR
      name     :: NameR

-- | Patterns
data PatR
   | PHoleR
      id       :: HoleIDR
      range    :: RangeR
   | PConR
      name     :: NameR
      pats     :: PatsR
      range    :: RangeR
   | PInfixConR
      left     :: PatR
      name     :: NameR
      right    :: PatR
      range    :: RangeR
   | PListR  
      pats     :: ListPatsR
      range    :: RangeR
   | PLitR
      lit      :: LiteralR
      range    :: RangeR
   | PParenR
      pat      :: PatR
      range    :: RangeR
   | PTupleR
      pats     :: TuplePatsR
      range    :: RangeR
   | PVarR
      name     :: NameR
      range    :: RangeR
   | PAsR
      name     :: NameR
      pat      :: PatR
      range    :: RangeR
   | PWildcardR
      range    :: RangeR

type PatsR = [PatR]
type ListPatsR = [PatR]
type TuplePatsR = [PatR]

-- | Right hand side
data RhsR
   | RhsR
      expr     :: ExprR
      where    :: DeclsR
      range    :: RangeR
   | GRhsR
      gexprs   :: GuardedExprsR
      where    :: DeclsR
      range    :: RangeR

data RangeR
    | RangeR
        rangestart :: PositionR
        rangestop  :: PositionR

data PositionR
    | PositionR
        filename  :: String
        line      :: Int
        column    :: Int
    | UnknownR
\end{lstlisting}
\end{multicols}

\section{Overview}
\label{section:overview}

\includepdf[pages={1}]{systemoverview.pdf}
\includepdf[pages={2}]{systemoverview.pdf}

\section{AST transformations}
Before passing the AST to the rest of the system, we apply several transformations to it to facilitate contract inference and code generation.

\subsection{Capture lambdas}
Anonymous functions cannot be contracted, as a name is required to properly  perform generation of contracted code.
Our solution is simple: bind all lambda functions to a unique identifier and place them in the where-clause of the original definition.
A simple example:

\begin{lstlisting}[mathescape]
f = $\lambda$x $\rightarrow$ x
\end{lstlisting}

is transformed into

\begin{lstlisting}[mathescape,caption=Result of lambda capture transformation.]
f = __lam0                   
 where                    
  __lam0 = $\lambda$x $\rightarrow$ x
\end{lstlisting}

Because of referential transparency, the behaviour of the program is not altered.

\subsection{Rewrite point-free functions}
The library of our choice, \textit{typed-contracts}, does not support asserting partially applied functions.
Because of this, all function arguments are made available on the left-hand side and applied to the right-hand side of a definition.
To continue with our previous example,

\begin{lstlisting}[mathescape]
f = __lam0                   
 where                    
  __lam0 = $\lambda$x $\rightarrow$ x
\end{lstlisting}

is now transformed into

\begin{lstlisting}[mathescape, caption=Result of $\eta$-abstraction transformation.]
f __a0 = (__lam0) __a0                
 where                    
  __lam0 __a0 = ($\lambda$x $\rightarrow$ x) __a0
\end{lstlisting}

This is essentially $\eta$-abstraction.
The information required for this transformation is provided by the type source,  which is described in section \ref{sourceoftypes}.

\subsection{Rewrite infix function applications}
To cut down on duplicate code for both contract inference and code generation, we convert infix function applications to regular function applications.
In other words, we remove a layer of syntactic sugar.

\subsection{Expand function applications}
To keep contract inference simple, we split up function applications that are applied to multiple arguments into several nested function applications.
For example:

\begin{lstlisting}
f g x y z = g x y z
\end{lstlisting}

is transformed into

\begin{lstlisting}[caption=Result of function application expansion transformation.]
f g x y z = ((g x) y) z
\end{lstlisting}

This allows us to use Stutterheim's original contract inference code for function applications.

\subsection{Expand lambda arguments}
The reasons for this transformation are similar as the previous one: keeping contract inference simple and being able to reuse Stutterheim's contract inference code.
A lambda function with multiple arguments is split up into nested lambda functions:

\begin{lstlisting}[mathescape]
f = $\lambda$g x y z $\rightarrow$ g x y z
\end{lstlisting}

is transformed into

\begin{lstlisting}[caption=Result of lambda argument expansion transformation.,mathescape]
f = $\lambda$g $\rightarrow$ ($\lambda$x $\rightarrow$ ($\lambda$y $\rightarrow$ ($\lambda$z $\rightarrow$ g x y z)))
\end{lstlisting}

Because this is done after the lambda function capture transformation, this transformation solely occurs in where-clauses, where the original lambda functions are bound to an identifier.

\section{Source of types and initial contracts}
\label{sourceoftypes}
After these transformations, the AST is passed to the type source and to the code generator.
in this section, we explain the concept and role of a type source in the contract inference algorithm and code generation system.

\subsection{Type source}

%Each node in the tree holds an attribute list of a 3-tuple of information: 
%\begin{itemize}
%\item A textual representation of the piece of code, for debugging purposes.
%\item A Helium AST of the piece of code.
%\item If applicable, the type of the piece of code.
%\end{itemize}

Abstractly, a type source $\Xi$ (pronounced "Xi") is a data structure that may hold information about the type of a node in an AST.
A node can query the type source to obtain its type if it is available using the following notation: $\Xi( x )$.

Our particular type source consists of a doubly linked tree that resembles the corresponding AST.
This "type tree" is generated by a modified version of the Helium type inference code and is deconstructed to provide the following AST nodes with type information:

%This "type tree" is generated in the \code{ModuleR} node of the AST, and is then passed down to the body of the module.
%
%For the most part, the type tree format is the same as the code AST, the biggest discrepancies being situated in the following nodes:
%
%\begin{description}
%	\item{GRhsR:} The attribute list is of the form:
%\begin{lstlisting}
%[guard,expr,guard,expr,...,wheredecls]
%\end{lstlisting}
%	\item{CaseR:} An alternative has two entries in the attribute list: one for the left-hand side, and one for the right-hand side.
%	\item{EnumR:} The type tree is ambiguous here: both \code{[1..2]} and \code{[1,2..]} return the same type tree. The code AST is inspected to determine what form is used, and the type tree is split up accordingly.
%	\item{FunBindR:} A type is not available for a function binding, so we must synthesize one. This is done by concatenating all the types of any patterns of the function binding and the type of the right-hand side. 
%\end{description}

%Types are available for the following AST nodes:
\begin{itemize}
	\item \code{Expr}
	\item \code{Pat}
	\item \code{Alt}
	\item \code{FunBind}
	\item \code{Rhs}
	\item \code{GuardedExpr}
\end{itemize}

\subsection{Initial contract generation}
\label{subsection:contractgeneration}

Using the type information present in the type source, we generate \textit{initial contracts} that prove useful in simplifying contract inference and final contract generation.

\subsubsection{Definition of initial contracts}

By deriving an initial contract from an identifier's type, we obtain a contract with the following properties:

\begin{itemize}
	\item Asserting the contract is equal to the identity function.
	\item It is a \textit{generalized} version of the \textit{most specific} contract for that identifier.
\end{itemize}

Let us discuss the latter property in further detail:
Stutterheim posits a conjecture that any inferred contract in algorithm \CW ~is also the \textit{most specific}, which means that the contract inferred for an expression $e$ is a subset of any other contract that is valid for $e$.

A \textit{generalized} version of such a contract is one where every contract variable present in the contract maps to a $true$ contract and where the relations in an identifier or expression's type are also present in its contract.

For example, here are generalized most specific contracts for the functions \code{id} and \code{map}:

\begin{lstlisting}[mathescape]
ctrt_id = c$_0$ $\rightarrowtail$ c$_0$
ctrt_map = (c$_1$ $\rightarrowtail$ c$_2$) $\rightarrowtail$ (c$_3$ $\functor$ c$_1$) $\rightarrowtail$ (c$_4$ $\functor$ c$_2$)
\end{lstlisting}

Conversely, these are \textbf{not} generalized most specific contracts for those functions, as they do not capture the relations present in the types of the functions:

\begin{lstlisting}[mathescape]
ctrt_id = c$_0$ $\rightarrowtail$ c$_1$
ctrt_map = (c$_1$ $\rightarrowtail$ c$_2$) $\rightarrowtail$ (c$_3$ $\functor$ c$_4$) $\rightarrowtail$ (c$_5$ $\functor$ c$_6$)
\end{lstlisting}

Generalized most specific contracts, also called \textit{initial} contracts, are not unique: it is possible to have the initial contracts \code{c$_0$ $\rightarrowtail$ c$_0$} and \code{c$_1$ $\rightarrowtail$ c$_1$} for the identity function.

\subsubsection{Uses for initial contracts}

There are a few uses for initial contracts:

\begin{itemize}
	\item The contract environment utilized by the inference algorithm is seeded with contracts from the type source before inference initiates. This is where the term \textit{initial contract} comes from. 
	\item They simplify contract inference by already incorporating some of the relations that would otherwise be discovered during inference. Particularly, relations between mutually recursive functions are captured as well.
	\item They allow for polymorphic versions of the $\finaltemplate$, $\apptemplate$ and $\ctrttemplate$ templates. 
\end{itemize}

The last two uses merit more detail, but to understand them, knowledge about the contract inference and code generation systems is necessary.
The relation between the type source and the contract environment is explained in subsection \ref{section:contract-inference-system}.
Explanation of the last use case is deferred to section \ref{generation-of-final-contracts}.

\subsubsection{Transferring relations between mutually recursive functions}

Mutually recursive functions are troublesome to define in Stutterheim's $\lambda_c$, requiring the contract environment $\Gamma$ to be pre-populated with the contract for the last-defined mutually recursive function to ensure Algorithm \CW ~does not terminate with an error.
In the case that Algorithm \CW ~terminates without error, the relation(s) between the mutually recursive functions is recorded in their contracts.

Because initial contracts are derived from types that record any relation(s) functions may have, the equivalent of pre-populating $\Gamma$, binding group analysis, is no longer necessary.
Binding group analysis is done during type inference to increase polymorphism in those types, an attribute we wish to mirror in our contracts.
By piggybacking upon already-inferred types, we gain both this increased polymorphism and any relations between functions present in the types.

%These initial contracts are of great use for mutually recursive functions.
%Let's look at the initial contracts that are generated for the following example:
%
%\begin{lstlisting}[caption=Simple mutually recursive function example.]
%f x = g x
%g x = f x
%\end{lstlisting}
%
%which generate the following types:
%\begin{description}
%	\item{\code{f} :} \code{v1 >-> v2}
%	\item{\code{g} :} \code{v1 >-> v2}
%\end{description}
%
%From the types, it is obvious that the two functions are very closely intertwined, as they both take the same form of contracted input and the same form of contracted output.

\subsubsection{Initial contract generation algorithm}

%After providing types, a contract environment is constructed that holds the contracts for all identifiers (which consists of function identifiers and pattern identifiers) currently in scope at a certain node of the AST.

An initial contract is generated by passing the type representation (a data type from the \textit{top} library) to the \code{convertTopTypeToContract} function, which strips down the type to its primitive type and converts it.

The following list shows which pattern match relates to which action:
\begin{description}
	\item{\code{(TVar i)} :} A \code{TVar} contains an integer \code{i} that corresponds to a specific type. That integer is prefixed with the character 'c' to create a fresh contract variable. For example, if \code{a} maps to the integer \code{1}, the type \code{a} is converted to the contract \code{c1}.
	\item{\code{(TApp (TApp (TCon "$\rightarrow$") t1) t2)} :} A function application. \code{t1} and \code{t2} are also converted and put in a non-dependent function contract. For example, given the mapping \code{a $\mapsto$ 1, b $\mapsto$ 2} the type \code{a $\rightarrow$ b} is converted to the contract \code{c1 $\rightarrowtail$ c2}.
	\item{\code{(TApp (TCon x) t1) | x `elem` ["Maybe","[]"]} :} Both the \code{Maybe} type and the list type are converted to a functor contract.
	\item{\code{(TApp (TApp (TCon x) t1) t2) | x `elem` ["Either","(,)"]} :} Both the \code{Either} type and the 2-tuple type are converted to a bifunctor contract.
	\item{\code{(TCon x) | x `elem` ["Int","Char","Float","Bool","String"]} :} Literals of these types are converted to a fresh contract variable that does not collide with those used for the \code{TVar} constructors.
\end{description}

3-tuples and 4-tuples are also supported, but have been left out for brevity.

At the moment, user-defined data types are unsupported.
Implementing support is discussed in section \ref{datatype-support-initial-contracts-algorithm} of the future work chapter.

\section{Contract inference}
Our contract inference system is based upon Stutterheim's work, and it is advised you read his chapters on contract inference if you are interested in the details, which we may omit if they are the same.

Our algorithm is also based on the Damas and Milner type inference system, with a few modifications and simplifications thanks to our use of a type source.

Our goals for contract inference remain the same as Stutterheim's:
\begin{enumerate}
	\item Infer a well-typed contract for each function in a program;
	\item Inferred contracts must allow a (possibly non-strict) subset of the values that the type allows, and
	\item The most general contract inferred by the inference system must never fail during assertion.
\end{enumerate}

Because we use Algorithm \CW ~as a starting point, our algorithm, too, is based on Milner's Algorithm \W, and we make use of Robinson's unification algorithm as well.
The resulting algorithm is called Algorithm \CHW.

\subsection{Formal description of the contract language}
Figure \ref{fig:contract-grammar} describes our intermediate contract language, which is a subset of that of Stutterheim's contract language.

While Stutterheim preferred to have specific terminals for data types and literals, we feel this over-encumbers the contract language.
Instead, we replace this multitude of terminals with a single $literal_i$ terminal.

\begin{figure}[htbp]
\begin{center}
\begin{lstlisting}[mathescape]
  -- Contracts
  c ::=  $\rho_{\alpha}$			-- User-defined concrete contract
      |  $c_{\alpha} \rightarrowtail c_{\beta}$			-- Function contracts
      |  $c_{\alpha} \functor c_{\beta}$			-- Functor contracts
      |  $c_{\alpha} \bifunctor (c_{\beta}, c_{\gamma})$			-- Bifunctor contracts
      |  $true_{\alpha}$			-- true contract
      |  $false_{\alpha}$			-- false contract
      |  $literal_{\alpha}$			-- literal contract
\end{lstlisting}
\end{center}
\caption{\label{fig:contract-grammar}Simplified grammar for the contract language.}
\end{figure}

Furthermore, contract schemes for universal quantification of contract indices are removed from the grammar.
Instead, every generated contract is implicitly universally quantified.
Instantiation can be said to be deferred to substitution application due to the way we divide and apply substitutions as described in section \ref{generation-of-final-contracts}.

Stutterheim describes several definitions, properties and relations between contracts in his thesis. 
The following of those can be brought over to our system without change:

Definitions:
\begin{itemize}
	\item Definition 1. Equivalency of contracts.
	\item Definition 2. Semantics of contracts.
\end{itemize}

Propositions:
\begin{itemize}
	\item Proposition 1. Contract relations with $true$ and $false$.
	\item Proposition 2. Assertion fails for subset.
	\item Proposition 3. Assertion succeeds for superset.
	\item Proposition 4. Superset relation for function contract semantics.
\end{itemize}

Propositions 5 (\textit{Soundness of inference}) and 6 (\textit{Asserting inferred contract is identity}) must be redone due to the new syntax, although the majority of the proofs for the \code{Expr} node will be very similar to Stutterheim's proofs.
We leave these proofs as future work.

\subsection{The contract inference system}
\label{section:contract-inference-system}
In this section, we introduce a system that allows us to infer a contract from an expression.
This system is based upon Stutterheim's work, and this section will roughly follow the same structure as the corresponding section in his thesis.

\subsubsection{Contract environment}

In our system, we use a contract environment $\Gamma$ (pronounced "Gamma") that maps contract variables to contracts.

A contract environment is defined as such:

\begin{figure}[htbp]
$\Gamma ::= [\!~]\!~||\!~\Gamma_1[x \mapsto c]$
\end{figure}

So, $\Gamma$ can either be completely empty, or consist of an environment $\Gamma_1$ that is extended by a mapping from an identifier $x$ to a contract $c$.

We use the same notation as Stutterheim for contract environments:
\begin{itemize}
	\item $\Gamma(x)=c$ means that the right-most binding for $x$ in $\Gamma$ maps $x$ to $c$.
	\item $\Gamma \vdash e : c$ denotes that, in environment $\Gamma$, the expression $e$ has the contract $c$.
	\item $fc(\sigma)$ indicates the set of $true$ contracts that are free in contract schema $\sigma$.
	\item $fc(\Gamma)$ indicates the set of $true$ contracts that are free in the codomain of $\Gamma$.
\end{itemize}

The \code{gen} and \code{inst} support functions used by Stutterheim are depreciated because of our choice to implicitly universally quantify contract variables and by our use of a type source.

Before moving on to the contracting rules and Algorithm \CHW, we first explain in detail the relations and differences between the contract environment $\Gamma$ and type source $\Xi$.

\subsubsection{Relation between $\Xi$ and $\Gamma$}

In type inference, a type environment $\Gamma$ is updated during the inference process.
For instance, encountering a $let$-binding will add the bound identifier $x$ to $\Gamma$ so it can be used in the rest of the $let$-binding.
A similar process occurs for a lambda function's pattern(s).
Fresh type variables are used when introducing these identifiers into $\Gamma$.
These variables are later unified with others to infer the final type of an expression.

But in our case, we require contracts, not types, to be inferred.
We have seen in subsection \ref{subsection:contractgeneration} how we can derive a generalized, most-specific contract from a type.
What if we take these derived contracts and use them as a starting point from which to initialize inference?
Would inference even be necessary anymore?

The answer is \textit{yes}.
When deriving a contract from a type, some information cannot be gleaned from the type: container types, such as those of lists, require a fresh contract to be used as their outer contract.
For example, the relations between the outer contracts of an input list and an output list cannot be derived from inspecting the type.
One must inspect the actual expression to which the type belongs.

Using contracts derived from types, then, allows us to focus on the inference uniquely required by (our definition of) a contract.
For this reason, we seed the contract environment $\Gamma$ with initial contracts from the type source $\Xi$ for the following identifiers:

\begin{itemize}
	\item Patterns
	\item Function identifiers
\end{itemize}

Seeding the contract environment $\Gamma$ is not done once: it is seeded every time new identifiers come into scope, shadowing existing ones.
The seeding rules that precisely describe this behaviour are very similar to the contracting rules of Stutterheim and inference rules of Damas and Milner.

\subsubsection{Seeding rules}

We use the following notation for the type source:

\begin{itemize}
	\item $\Xi(x) = c$ means that the type source query for node $x$ returns contract $c$ as a result.
\end{itemize}

We begin with the seeding rules for patterns, followed by those for declarations.

\paragraph{Patterns.}

In figure \ref{fig:pattern-seeding-rules}, the seeding rule \code{S-PVar} we see how the contract for a pattern variable is requested from the type source $\Xi$ and added to the environment $\Gamma$.
The same occurs for a pattern alias in \code{S-PAs}.

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{S-PVar}\quad}
  \AxiomC{$\Xi(p) = c$}
  \UnaryInfC{$\Gamma[p \mapsto c]$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{S-PAs}\quad}
  \AxiomC{$\Xi(p) = c$}
  \UnaryInfC{$\Gamma[p \mapsto c]$}
  \DisplayProof
\end{center}
\caption{\label{fig:pattern-seeding-rules}Seeding rules for patterns.}
\end{figure}

\paragraph{Declarations.}

The seeding rules for declarations (figure \ref{fig:declaration-seeding-rules}) add function identifier contracts to the environment(s) for the function binding(s).
\code{S-DFunBinds} illustrates how the contracts derived from a declaration group must all be the same: \code{f (x:xs) = [x]} should have the same initial contract as \code{f [] = []}, for example.
For pattern bindings, the pattern's contract is requested from the type source and inserted into $\Gamma$.

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{S-DFunBinds}}
  \AxiomC{$\forall{i}\in[0\ldots{n}]$ $d_i =$ $f$ $p_i$ $=$ $rhs_i$}
  \AxiomC{$\Xi(d_i) = c$}
  \BinaryInfC{$\Gamma[f \mapsto c]$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{S-DPatBind}\quad}
  \AxiomC{$\Xi(p) = c$}
  \UnaryInfC{$\Gamma[p \mapsto c]$}
  \DisplayProof
\end{center}
\caption{\label{fig:declaration-seeding-rules}Seeding rules for declarations.}
\end{figure}

\subsubsection{$\Gamma$ versus $\Xi$}

Even though contract environment $\Gamma$ has been seeded, it is sometimes required to directly query the type source $\Xi$.

For the seeding rules, we slightly simplified the notation for querying a type source. 
In reality, the type source is also given as many fresh contracts as is required to convert the type into a contract.
These fresh contracts are exclusively used for outer contracts in functor and bifunctor contracts.
This means that two queries to $\Xi$ for the list constructor \code{(:[])}, for example, result in two different contracts being delivered, the contracts differing in their fresh outer contracts.
Contracting rules such as \code{C-PCon} and \code{C-Con} make use of this functionality.

The key difference between $\Gamma$ and $\Xi$ is this: contracts from $\Gamma$ are \textit{static} and are only changed by substitutions.
Contracts from $\Xi$ can be \textit{dynamic}.

Now that it is clear what the relations and differences between $\Gamma$ and $\Xi$ are, we are ready to proceed to the contracting rules.

\subsubsection{Contracting rules}

We first introduce the contracting rules for patterns, as many of the rules are similar to those for declarations, right-hand sides, (guarded) expressions and alternatives.

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-PHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PWildcard}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $* :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PCon}}
  \AxiomC{$\Xi(p_1) :: c_1 \rightarrowtail c$}
  \AxiomC{$\Gamma \vdash$ $p_2 :: c_1$}
  \BinaryInfC{$\Gamma \vdash$ $p_1$ $p_2 :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PVar}\quad}
  \AxiomC{$\Gamma(p) = c$}
  \UnaryInfC{$\Gamma \vdash$ $p :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PAs}\quad}
  \AxiomC{$\Gamma(p) = c$}
  \UnaryInfC{$\Gamma \vdash$ $p@(ps) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PCons}\quad}
  \AxiomC{$\Gamma \vdash$ $x :: c$}
  \AxiomC{$\Gamma \vdash$ $xs :: list \functor c$}
  \BinaryInfC{$\Gamma \vdash$ $(x : xs) :: list \functor c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PNil}\quad}
  \AxiomC{$fresh(i, j)$}
  \UnaryInfC{$\Gamma \vdash$ $[] :: true_i \functor true_j$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PTuple}\quad}
  \AxiomC{$\forall{i}\in{[0\ldots{n}]} \Gamma \vdash$ $e_i :: c_i$}
  \AxiomC{$fresh(j)$}
  \BinaryInfC{$\Gamma \vdash$ $(e_0, .., e_i) :: true_j \bifunctor (c_1, .., c_i)$}
  \DisplayProof
  \vskip 0.5em
%  \RightLabel{\textsc{C-PTupleNil}\quad}
%  \AxiomC{$\forall{i}\in[0\ldots{n}]$ $\Gamma \vdash$ $t_i :: c_i$}
%  \AxiomC{$\forall{j}\in[0\ldots{n-1}]$ $fresh(j)$}
%  \BinaryInfC{$\Gamma \vdash$ $(t_0, ..., t_i) :: true_0 <@@> (c_0, true_1 <@@> (..., true_j <@@> (c_i-1, c_i) ) )$}
%  \DisplayProof
%  \vskip 0.5em
  \RightLabel{\textsc{C-PLit}}
  \AxiomC{l is a literal}
  \AxiomC{$fresh(i)$}
  \BinaryInfC{$\Gamma \vdash$ $l :: literal_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PParen}\quad}
  \AxiomC{$\Gamma \vdash$ $p :: c$}
  \UnaryInfC{$\Gamma \vdash$ $(p) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-PInfixCon}}
  \AxiomC{$\Gamma \vdash$ $e_1 :: c_1$}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c_2$}
  \AxiomC{$\Xi(\oplus) = c_1 \rightarrowtail c_2 \rightarrowtail c_3$}
  \TrinaryInfC{$\Gamma \vdash e_1 \oplus e_2 :: c_3$}
  \DisplayProof
\end{center}
\caption{\label{fig:pattern-inference-rules}Contracting rules for patterns.}
\end{figure}

\paragraph{Patterns.}

Let us go over the rules in figure \ref{fig:pattern-inference-rules}.
Please note that while our syntax contains a \code{PListR} data constructor, we use the two contracting rules \code{C-PCons} and \code{C-PNil} to describe its contracting behaviour. 
This is how the \code{PListR} constructor works behind the scenes.
We will follow this convention for all constructors that describe lists.

\begin{description}
	\item{\code{C-PHole} and \code{C-PWildcard} :} In both cases, a fresh contract is generated because a more specific contract cannot be provided.
	\item{\code{C-PCon} :} The contract $c_1 \rightarrowtail c$ is queried from $\Xi$. $c$ may contain a fresh outer contract.
	\item{\code{C-PVar} and \code{C-PAs} :} The contract for $p$ is fetched from $\Gamma$. In the case of \code{C-PAs}, $c$ is used for the entire pattern.
	\item{\code{C-PNil} :} Because we know nothing about the inner or outer contract, we generate fresh $true$ contracts for both.
	\item{\code{C-PCons} :} In this case, we know about the contracts of the tail and head of the list. The inner contract of the list tail must be the same as the contract of the head of the list. The resulting contract is the same as the list tail.
	\item{\code{C-PTuple} :} For a tuple; we know about each contract of the tuple's members. We generate a nested bifunctor contract for tuples larger than 2, nesting in $c_2$ until we have accommodated every member of the tuple. For each bifunctor contract, we require a fresh contract for the outer contract, which means we require $n-1$ fresh contracts, $n$ being the size of the tuple.
	\item{\code{C-PLit} :} A pattern literal is given a fresh $literal$ contract.
	\item{\code{C-PParen} :} Parentheses simply copy the contract of the enclosed pattern.
	\item{\code{C-PInfixCon} :} An infix operator in Helium supports two arguments, so the contracting rule is a slight variation \code{C-PCon}.
\end{description}

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-DHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-DEmpty}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $ :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-DFunBinds}}
  \AxiomC{$\Gamma \vdash$ $d :: c$}
  \UnaryInfC{$\Gamma \vdash$ $(d:ds) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-DPatBind}\quad}
  \AxiomC{$\Gamma(p) = c$}
  \UnaryInfC{$\Gamma \vdash$ $p = rhs :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:declaration-inference-rules}Contracting rules for declarations.}
\end{figure}

\paragraph{Declarations.}

Figure \ref{fig:declaration-inference-rules} shows the contracting rules for declarations. The rules \code{C-DHole} and \code{C-DEmpty} are trivial, but the remaining two warrant a little more explanation:

\begin{description}
	\item{\code{C-DFunBinds} :} In this rule, we select the contract of the very first element of the list of function bindings and use that as the contract of the entire list. This makes sense because function bindings must have the same number of arguments and the same result, meaning that the contract is also the same.
	\item{\code{C-DPatBind} :} A pattern binding will look up its contract in the contract environment, in the same manner as \code{C-PVar}.
\end{description}

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-FBHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-FunBind}}
  \AxiomC{$\Gamma(ident) = c$}
  \UnaryInfC{$\Gamma \vdash$ $ident$ $ps = rhs :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-FCons}\quad}
  \AxiomC{$\Gamma \vdash$ $f :: c$}
  \AxiomC{$\Gamma \vdash$ $fs :: c$}
  \BinaryInfC{$\Gamma \vdash$ $(f:fs) :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:funbinds-inference-rules}Contracting rules for function bindings.}
\end{figure}

\paragraph{Function bindings.}

The contracting rules for function bindings in figure \ref{fig:funbinds-inference-rules} are straightforward: \code{C-FBHole} works as all other holes, and \code{C-FunBind} looks up the identifier in the contract environment and assigns that contract to the entire function binding.
\code{C-FCons} illustrates that every element in a list of function bindings must have the same contract.
The rule \code{C-FNil} does not exist, as it would be represented by a \code{DEmpty} declaration node.

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-Rhs}}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $e$ \textbf{where} $d :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-GRhs}}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $|$ $g = e$ \textbf{where} $d :: c$}
  \DisplayProof
\end{center}
\caption{\label{fig:rhs-inference-rules}Contracting rules for right-hand sides.}
\end{figure}

\paragraph{Guarded expressions.}

Figure \ref{fig:guardedexpr-inference-rules} illustrates the contracting rules for guarded expressions.
The guard itself is ignored, and the contract for the expression that is guarded is used for the entire guarded expressions.

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-GExpr}}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $g$ $|$ $e :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-GCons}}
  \AxiomC{$\Gamma \vdash$ $g :: c$}
  \UnaryInfC{$\Gamma \vdash (g:gs) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-GNil}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash [] :: true_i$}
  \DisplayProof
\end{center}
\caption{\label{fig:guardedexpr-inference-rules}Contracting rules for guarded expressions.}
\end{figure}

\paragraph{Right-hand sides.}

Right-hand side contracting rules (see figure \ref{fig:rhs-inference-rules}) are equally simple: the contract of $e$ is looked up in the contract environment and is used for the entire right-hand side.
The same is done for guarded expressions (figure \ref{fig:guardedexpr-inference-rules}).

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-Hole}\quad}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Feedback}\quad}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $e :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-MustUse}\quad}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $e :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Case}}
  \AxiomC{$\Gamma \vdash$ $m :: c_1$}
  \AxiomC{$\forall{i}\in[0\ldots{n}] \Gamma \vdash$ $p_i :: c_1$}
  \AxiomC{$\forall{i}\in{[0\ldots{n}]} \Gamma \vdash$ $e_i :: c_2$}
  \TrinaryInfC{$\Gamma \vdash$ \textbf{case} $m$ \textbf{of} \{${p_0 \rightarrow e_0; ...; p_n \rightarrow e_n}$\} $:: c_2$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Con}\quad}
  \AxiomC{$\Xi(x) = c$}
  \UnaryInfC{$\Gamma \vdash$ $x :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-If}\quad}
  \AxiomC{$\Gamma \vdash$ $t :: c$}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \BinaryInfC{$\Gamma \vdash$ \textbf{if} $cond$ \textbf{then} $t$ \textbf{else} $e :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Lambda}\quad}
  \AxiomC{$\Gamma[x \mapsto c_1] \vdash$ $e :: c_2$}
  \UnaryInfC{$\Gamma \vdash$ $\lambda x \rightarrow e :: c_1 \rightarrowtail c_2$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Let}\quad}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c$}
  \UnaryInfC{$\Gamma \vdash$ \textbf{let x =} $e_1$ \textbf{in} $e_2 :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Lit}}
  \AxiomC{$l$ is a literal}
  \AxiomC{$fresh(i)$}
  \BinaryInfC{$\Gamma \vdash$ $l :: literal_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-App}\quad}
  \AxiomC{$\Gamma \vdash$ $e_1 :: c_2 \rightarrowtail c$}
  \AxiomC{$\Gamma \vdash$ $e_2 :: c_2$}
  \BinaryInfC{$\Gamma \vdash$ $e_1$ $e_2 :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Paren}\quad}
  \AxiomC{$\Gamma \vdash$ $p :: c$}
  \UnaryInfC{$\Gamma \vdash$ $(p) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Tuple}\quad}
  \AxiomC{$\forall{i}\in{[0\ldots{n}]} \Gamma \vdash$ $e_i :: c_i$}
  \AxiomC{$fresh(j)$}
  \BinaryInfC{$\Gamma \vdash$ $(e_0, .., e_i) :: true_j \bifunctor (c_1, .., c_i)$}  
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Var}\quad}
  \AxiomC{$\Gamma(x) = c$}
  \UnaryInfC{$\Gamma \vdash$ $x :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Enum}\quad}
  \AxiomC{$fresh(i)$ $\Gamma \vdash$ $x :: c$}
  \AxiomC{$\Gamma \vdash$ $y :: c$}
  \AxiomC{$\Gamma \vdash$ $z :: c$}
  \TrinaryInfC{$\Gamma \vdash$ [$x$ .. ($y$) .. ($z$)] $ :: true_i \functor c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Cons}\quad}
  \AxiomC{$\Gamma \vdash$ $x :: c$}
  \AxiomC{$\Gamma \vdash$ $xs :: list \functor c$}
  \BinaryInfC{$\Gamma \vdash$ $(x : xs) :: list \functor c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Nil}\quad}
  \AxiomC{$fresh(i, j)$}
  \UnaryInfC{$\Gamma \vdash$ $[] :: true_i \functor true_j$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Neg}\quad}
  \AxiomC{$\Gamma \vdash$ $e :: c$}
  \UnaryInfC{$\Gamma \vdash$ $-e :: c$}
  \DisplayProof
  \vskip 0.5em
\end{center}
\caption{\label{fig:expr-inference-rules}Contracting rules for expressions.}
\end{figure}

\paragraph{Expressions.}

Figure \ref{fig:expr-inference-rules} details the contracting rules for expressions, which have large overlaps with those for patterns.
Note how there is no rule \code{C-InfixApp}.
This is because infix function applications are converted to regular function applications before contract inference occurs.
As such, there is no need for such a rule.

Rules that are either trivial or similar to those of patterns are: \code{C-Hole}, \code{C-Feedback}, \code{C-MustUse}, \code{C-Con}, \code{C-Lit}, \code{C-App}, \code{C-Paren}, \code{C-Tuple}, \code{C-Cons}, \code{C-Nil} and \code{C-Neg}.
The rest of the contracting rules are discussed hereafter.

\begin{description}
	\item{\code{C-Case} :} This rule describes contracting of a case statement for an arbitrary number of cases. The contract of the expression being evaluated, $m$, must be the same as the contracts of the patterns $p_i$, namely $c_1$. The contract of the entire case statement is $c_2$, which is the contract that is given to each alternative.
	\item{\code{C-If} :} Syntactic sugar for a boolean case statement. Like its generalized version, the contract of the entire statement is the same of each alternative, in this case $c$. 
	\item{\code{C-Lambda} :} This contracting rule is the same as in Stutterheim's work.
	\item{\code{C-Let} :} A non-generalized let. Generalization is not necessary because every contract variable is implicitly universally quantified in the global contract environment. 
	\item{\code{C-Enum} :} A list generator. $y$ and $z$ are fully optional, but if they are present, they must have the same contract as that of $x$, namely $c$. A fresh outer contract is generated to complete the final contract.
\end{description}

\begin{figure}[htbp]
\begin{center}
  \RightLabel{\textsc{C-AHole}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $? :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-AltEmpty}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash$ $ :: true_i$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-Alt}}
  \AxiomC{$\Gamma \vdash$ $rhs :: c$}
  \UnaryInfC{$\Gamma \vdash$ $p$ $\rightarrow$ $rhs :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-ACons}}
  \AxiomC{$\Gamma \vdash$ $a :: c$}
  \AxiomC{$\Gamma \vdash$ $as :: c$}
  \BinaryInfC{$\Gamma \vdash (a:as) :: c$}
  \DisplayProof
  \vskip 0.5em
  \RightLabel{\textsc{C-ANil}}
  \AxiomC{$fresh(i)$}
  \UnaryInfC{$\Gamma \vdash [] :: true_i$}
  \DisplayProof
\end{center}
\caption{\label{fig:alternatives-inference-rules}Contracting rules for alternatives.}
\end{figure}

\paragraph{Alternatives.}

The contracting rules for alternatives in figure \ref{fig:alternatives-inference-rules} are quite simple. \code{C-AHole} and \code{C-AltEmpty} are trivial, and \code{C-Alt} takes the contract of the right-hand side as the contract of the entire alternative.
\code{ACons} and \code{ANil} are how the \code{Alts} node functions behind the scenes: all alternatives must have the same contract.

%\todo{A few simple examples of applying the rules?}

\subsubsection{Substitutions and unification}

We use the same substitution grammar as that of Stutterheim.
Our unification algorithm, too, is identical to that of Stutterheim, which itself is based upon Robinson's unification algorithm.
We refer you to subsection 3.4.2 of Stutterheim's thesis for a description of the unification algorithm and the substitutions it generates.
When you are done reading, we will note a caveat in his description of the algorithm.

It merits mentioning that although Stutterheim's unification algorithm supports concrete contract refinement in theory, in code this is unsupported.
In fact, the example posed by Stutterheim:

$\mathcal{U}$ $(int,nat)$

results in an error message, as evidenced by the relevant pattern matches of the \code{unifyC} function as shown in figure \ref{figure:unifyCWFails}.

\begin{figure}[htbp]
\begin{lstlisting}[mathescape]
unifyC :: Contract $\rightarrow$ Contract $\rightarrow$ Subst
unifyC c1              c2 | c1 == c2   = SId
unifyC v@CVar{}        c               = unifyCVars v c
unifyC c               v@CVar{}        = unifyCVars v c
...
unifyC c1 c2 = unifyErr "No such unification case when" c1 c2
\end{lstlisting}
\caption{\label{figure:unifyCWFails}A part of the \code{unifyC} function of Algorithm \CW.}
\end{figure}

This is because the $int$ and $nat$ contracts are in fact defined as user-defined concrete contracts.
The default contracts that Stutterheim refers to in figure 3.2 of his thesis do not exist in the actual Contract data type in the source code. 
It only supports the inhabitants of our simplified grammar as shown in figure \ref{fig:contract-grammar}.
Relations between contracts that allow for refinement are thus non-existent.
While these relations can be mapped out manually, a better idea would be to look towards true refinement types as described in section \ref{section:relatedworkcontracts}.

%\begin{figure}[htbp]
%\begin{center}
%\begin{lstlisting}[mathescape]
%$\theta$  ::=  Id		-- Identity substitution
%    |    $\theta_1 \circ \theta_2$		-- Substitution composition
%    |    [$c_1 \mapsto c_2$]		-- Substitution for $c_1$ with a contract $c_2$
%\end{lstlisting}
%\end{center}
%\caption{\label{fig:subst-grammar} The substitution grammar as defined by Stutterheim.}
%\end{figure}

The manner in which we apply generated substitutions differs greatly from Stutterheim's approach.
We explain how and why in section \ref{generation-of-final-contracts}.

\subsubsection{Algorithm \CHW}

Now that we have reviewed the contracting rules and the unification algorithm, let us define the contract inference Algorithm \CHW, which is based upon Stutterheim's Algorithm $\mathcal{CW}$.
Our algorithm takes a \code{Module} and infers contracts for each declaration, pattern, right-hand side, (guarded) expression and alternative that resides in the module.

To infer a contract, we require:
\begin{enumerate}
	\item The contract environment $\Gamma$.
	\item The type source $\Xi$.
	\item An infinite supply of fresh $true$ contracts.
\end{enumerate}

We follow the same order as the contracting rules here: patterns are introduced first, then declarations, function bindings, right-hand sides, expressions and alternatives.

\paragraph{Patterns.}

The code for patterns is shown in figure \ref{fig:pattern-algorithm-chw}.
We omit the infix constructor, as it is the same as in Stutterheim's system for expressions. 
Again, \code{PList} is replaced by the \code{PCons} and \code{PNil} constructors, which is how the constructor works behind the scenes.

\begin{figure}[htbp]
\begin{lstlisting}[mathescape]
chw :: Environment $\rightarrow$ TypeSource $\rightarrow$ Pattern $\rightarrow$ (Substitution,Contract)

chw $\Gamma$ $\Xi$ PHole = 
 let $i$ be fresh
 in ($Id$, $true_i$)
 
chw $\Gamma$ $\Xi$ PWildcard = 
 let $i$ be fresh
 in ($Id$, $true_i$)
 
chw $\Gamma$ $\Xi$ (PCon n p) = ($Id$, $\Xi$(PCon n p))

chw $\Gamma$ $\Xi$ PNil = 
 let $i$ and $j$ be fresh
 in ($Id$, $true_i$ $\functor$ $true_j$)
 
chw $\Gamma$ $\Xi$ (PCons x xs) = 
 let ($\theta_1$,c) = chw $\Gamma$ $\Xi$ x
     ($\theta_2$, $true_i$ $\functor$ c) = chw $\Gamma$ $\Xi$ xs
 in  ($\theta_2 \circ \theta_1$, $true_i$ $\functor$ c)
 
chw $\Gamma$ $\Xi$ (PLit l) = 
 let $i$ be fresh
 in ($Id$, $literal_i$)

chw $\Gamma$ $\Xi$ (Paren p) = chw $\Gamma$ $\Xi$ p

chw $\Gamma$ $\Xi$ (Tuple (p:ps)) = 
 let $i$ be fresh
     ($\theta_1$, c$_1$) = chw $\Gamma$ $\Xi$ p
     ($\theta_2$, c$_2$) = chw $\Gamma$ $\Xi$ ps
 in  ($\theta_2 \circ \theta_1$, $true_i$ $\bifunctor$ (c$_1$, c$_2$))
 
chw $\Gamma$ $\Xi$ (Tuple [p]) = chw $\Gamma$ $\Xi$ p

chw $\Gamma$ $\Xi$ (PVar x) = ($Id$, $\Gamma$(x))

chw $\Gamma$ $\Xi$ (PAs p ps) = ($Id$, $\Gamma$(p))
\end{lstlisting}
\caption{\label{fig:pattern-algorithm-chw}Algorithm \CHW ~for patterns.}
\end{figure}

\paragraph{Declarations.}

For declarations (figure \ref{fig:declaration-algorithm-chw}), we omit \code{DHole} and \code{DEmpty}, as they both function the same as \code{PHole}.
\code{DCons} is of particular interest, as it shows how substitutions are passed between groups of function bindings.

\begin{figure}[htbp]
\begin{lstlisting}[mathescape]
chw :: Environment $\rightarrow$ TypeSource $\rightarrow$ Declaration $\rightarrow$ (Substitution,Contract)

chw $\Gamma$ $\Xi$ (DFunBinds []) = chw $\Gamma$ $\Xi$ DEmpty

chw $\Gamma$ $\Xi$ (DFunBinds fs) = chw $\Gamma$ $\Xi$ fs

chw $\Gamma$ $\Xi$ (DPatBind p rhs) = 
 let ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ p
     ($\theta_2$,c$_2$) = chw $\Gamma$ $\Xi$ rhs
     $\theta_3$ = $\mathcal{U}$(c$_1$,c$_2$)
 in  ($\theta_3 \circ \theta_2 \circ \theta_1$, $\theta_3 \circ \theta_2$ c$_1$)
     
chw $\Gamma$ $\Xi$ (DCons d ds) = 
 let ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ d
     ($\theta_2$,c$_2$) = chw ($\theta_1$ $\Gamma$) $\Xi$ ds
 in  ($\theta_2 \circ \theta_1$, c$_1$)
 
chw $\Gamma$ $\Xi$ DNil = 
 let $i$ be fresh
 in  ($Id$, $true_i$)
\end{lstlisting}
\caption{\label{fig:declaration-algorithm-chw}Algorithm \CHW ~for declarations.}
\end{figure}

\paragraph{Function bindings.}

Figure \ref{fig:funbinds-algorithm-chw} shows Algorithm \CHW ~for function bindings.
We omit \code{FBHole} as we did before, and \code{FCons} and \code{FNil} are trivial.
\code{FunBind} may look a bit odd.
This is what it does: first, the contract of the function identifier, $c_1$, is trimmed by the length of $pats$ starting from the left of the contract, removing these arguments from the contract and producing $c'_1$, the contract for the result of the function.
Then, $c'_1$ is unified with $c_2$, which is the contract for the right-hand side of the function binding.

\begin{figure}[htbp]
\begin{lstlisting}[mathescape]
chw :: Environment $\rightarrow$ TypeSource $\rightarrow$ FuncBinding $\rightarrow$ (Substitution,Contract)

chw $\Gamma$ $\Xi$ (FunBind nm pats rhs) = 
 let c$_1$ = $\Gamma$(nm)
     lp = length pats
     c$'_1$ = dropc lp c$_1$
     ($\theta_1$,c$_2$) = chw $\Gamma$ $\Xi$ rhs
     $\theta_2$ = $\mathcal{U}$(c$'_1$,c$_2$)
 in  ($\theta_2 \circ \theta_1$, $\theta_2$ c$_1$)
 
chw $\Gamma$ $\Xi$ (FCons f fs) = 
 let ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ f
     ($\theta_2$,c$_2$) = chw $\Gamma$ $\Xi$ fs
 in  ($\theta_2 \circ \theta_1$, c$_1$)
 
chw $\Gamma$ $\Xi$ FNil = 
 let $i$ be fresh
 in  ($Id$, $true_i$)
\end{lstlisting}
\caption{\label{fig:funbinds-algorithm-chw}Algorithm \CHW ~for function bindings.}
\end{figure}

\paragraph{Right-hand sides.}

The code for right-hand sides (figue \ref{fig:rhs-algorithm-chw}) is quite simple.
In both cases, the contract of expression $e$ is used for the entire right-hand side.
In the case of guarded expressions, the substitution of each guarded expression is collected.

\begin{figure}[htbp]
\begin{lstlisting}[mathescape]
chw :: Environment $\rightarrow$ TypeSource $\rightarrow$ RHS $\rightarrow$ (Substitution,Contract)

chw $\Gamma$ $\Xi$ (Rhs e w) = 
 let ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ e
     ($\theta_2$,c$_2$) = chw $\Gamma$ $\Xi$ w
 in  ($\theta_2 \circ \theta_1$, c$_1$)

chw $\Gamma$ $\Xi$ (GRhs (e:es) w) = 
 let ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ e
     ($\theta_2$,c$_2$) = chw $\Gamma$ $\Xi$ es
     ($\theta_3$,c$_3$) = chw $\Gamma$ $\Xi$ w
 in  ($\theta_3 \circ \theta_2 \circ \theta_1$, c$_1$)
 
chw $\Gamma$ $\Xi$ (GRhs [] w) = 
 let $i$ be fresh
 in  ($Id$, $true_i$)
\end{lstlisting}
\caption{\label{fig:rhs-algorithm-chw}Algorithm \CHW ~for right-hand sides.}
\end{figure}

\paragraph{Expressions.}

We omit the code for \code{Hole}, \code{Feedback}, \code{MustUse}, \code{Neg} and \code{Paren} in figure \ref{fig:expression-algorithm-chw}, as these are trivial: in the first case, a fresh $true$ contract is generated and in the other cases, the expression $e$ that is wrapped by the node is used to attain the substitutions and contract.
Furthermore, we omit \code{InfixApp} because it is converted to regular function application, which is covered by \code{App}.

The code for \code{App} differs from the original algorithm.
Instead of generating a fresh $true$ contract to unify with the contract of $f$, we drop a single argument from the $c_1$ contract to obtain $\alpha$, the contract for the result of $f$.
This is done to reduce the amount of generated substitutions.
$\alpha$ is then used for unification in the usual manner.


\begin{figure}[htbp]
\begin{lstlisting}[mathescape]
chw :: Environment $\rightarrow$ TypeSource $\rightarrow$ Expression $\rightarrow$ (Substitution,Contract)

chw $\Gamma$ $\Xi$ (Case e alts) = 
 let ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ e
     ($\theta_2$,c$_2$) = chw $\Gamma$ $\Xi$ alts
 in  ($\theta_2 \circ \theta_1$, $\theta_2 \circ \theta_1$ c$_2$)
 
chw $\Gamma$ $\Xi$ (Con name) = ($Id$, $\Xi$(name))

chw $\Gamma$ $\Xi$ (Lit l) = ($Id$, $\Xi$(l))

chw $\Gamma$ $\Xi$ (If i t e) = 
 let ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ i
     ($\theta_2$,c$_2$) = chw $\Gamma$ $\Xi$ t
     ($\theta_3$,c$_3$) = chw $\Gamma$ $\Xi$ e
     $\theta_4$ = $\mathcal{U}$(c$_2$,c$_3$)
 in  ($\theta_4 \circ \theta_3 \circ \theta_2 \circ \theta_1$, $\theta_4 \circ \theta_3 \circ \theta_2 \circ \theta_1$ c$_2$)
 
chw $\Gamma$ $\Xi$ (Lambda p e) = 
 let ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ p
     ($\theta_2$,c$_2$) = chw $\Gamma$ $\Xi$ e
 in  ($\theta_2 \circ \theta_1$, $\theta_2$ (c$_1$ $\rightarrowtail$ c$_2$))
 
chw $\Gamma$ $\Xi$ (Let decls e) = 
 let ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ decls
     ($\theta_2$,c$_2$) = chw $\Gamma$ $\Xi$ e
 in  ($\theta_2 \circ \theta_1$, c$_2$)
 
chw $\Gamma$ $\Xi$ (App f x) = 
 let ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ f
     ($\theta_2$,c$_2$) = chw $\Gamma$ $\Xi$ x
     $\alpha$ = dropc 1 c$_1$
     $\theta_3$ = $\mathcal{U}$($\theta_2$ c$_1$,c$_2$ $\rightarrowtail$ $\alpha$)
 in  ($\theta_3 \circ \theta_2 \circ \theta_1$, $\theta_3$ $\alpha$)

chw $\Gamma$ $\Xi$ (Enum f t o) = 
 let ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ f
     ($\theta_2$,c$_2$) = chw $\Gamma$ $\Xi$ t
     ($\theta_3$,c$_3$) = chw $\Gamma$ $\Xi$ o
     $\theta_4$ = $\mathcal{U}$(c$_1$,c$_2$)
     $\theta_5$ = $\mathcal{U}$($\theta_4$ c$_2$,c$_3$)
 in  ($\theta_5 \circ \theta_4 \circ \theta_3 \circ \theta_2 \circ \theta_1$, $\theta_5 \circ \theta_4 \circ \theta_3 \circ \theta_2 \circ \theta_1$ c$_1$)
 
chw $\Gamma$ $\Xi$ (Cons x xs) =
 let $i$ be fresh
     ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ x
     ($\theta_2$,c$_2$) = chw $\Gamma$ $\Xi$ xs
     $\theta_3$ = $\mathcal{U}$(c$_2$,$\theta_2$ ($true_i$ $\functor$ c$_1$))
 in  ($\theta_3 \circ \theta_2 \circ \theta_1$, $\theta_3$ ($true_i$ $\functor$ c$_1$))
     
chw $\Gamma$ $\Xi$ Nil = 
 let $i$ and $j$ be fresh
 in  ($Id$, $true_i$ $\functor$ $true_j$)
 
chw $\Gamma$ $\Xi$ (Tuple (t:ts)) = 
 let $i$ be fresh
     ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ t
     ($\theta_2$,c$_2$) = chw $\Gamma$ $\Xi$ ts
 in  ($\theta_2 \circ \theta_1$, $true_i$ $\bifunctor$ (c$_1$,c$_2$))
 
chw $\Gamma$ $\Xi$ (Tuple [t]) = chw $\Gamma$ $\Xi$ t
\end{lstlisting}
\caption{\label{fig:expression-algorithm-chw}Algorithm \CHW ~for expressions.}
\end{figure}

\paragraph{Alternatives.}

For alternatives, we omit \code{AHole} and \code{AltEmpty} in figure \ref{fig:alternative-algorithm-chw} because they are trivial.

\begin{figure}[htbp]
\begin{lstlisting}[mathescape]
chw :: Environment $\rightarrow$ TypeSource $\rightarrow$ Alternative $\rightarrow$ (Substitution,Contract)

chw $\Gamma$ $\Xi$ (Alt p rhs) = 
 let ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ p
     ($\theta_2$,c$_2$) = chw $\Gamma$ $\Xi$ rhs
 in  ($\theta_2 \circ \theta_1$, $\theta_2$ c$_2$)
 
chw $\Gamma$ $\Xi$ (ACons x xs) = 
 let ($\theta_1$,c$_1$) = chw $\Gamma$ $\Xi$ x
     ($\theta_2$,c$_2$) = chw $\Gamma$ $\Xi$ xs
     $\theta_3$ = $\mathcal{U}$(c$_1$,c$_2$)
 in  ($\theta_3 \circ \theta_2 \circ \theta_1$, $\theta_3 \circ \theta_2$ c$_1$)
 
chw $\Gamma$ $\Xi$ ANil = 
 let $i$ be fresh
 in  ($Id$, $true_i$)
\end{lstlisting}
\caption{\label{fig:alternative-algorithm-chw}Algorithm \CHW ~for alternatives.}
\end{figure}

\section{Code Generation}
\label{codegeneration}

After the process of contract inference, we possess enough information to fully contract the original code.
For each function definition \code{X}, we generate three new function definitions:

\begin{itemize}
	\item $\underline{\hspace{1.5em}}final\_\code{X}$
	\item $\underline{\hspace{1.5em}}app\_\code{X}$
	\item $\underline{\hspace{1.5em}}contracted\_\code{X}$
\end{itemize}

We will inspect each template in detail and explain its purpose.

\subsection{\finaltemplate}

The $\finaltemplate$ template is simple: it is a transformed copy of the original function definition.
Every function application found within the original code is replaced by its contracted equivalent, the $\apptemplate$ template.
This transformation makes this template the entry point for all other generated functions.

As an example, here is the filled-in $\finaltemplate$ template for the \code{foldr} function:

\begin{lstlisting}[mathescape]
__final_foldr __ctrtf f b (x:xs) = f x (__app_foldr $ctrt$ $pos$ ($p1$,__ctrtf) ($p2$,b) ($p3$,xs))
__final_foldr __ctrtf f b [] = b
\end{lstlisting}

%\todo{Why could we not also give the position info of x to f? I think this has to do with the type-level representation then expecting functions that expect tuples. Perhaps modifying the 'final' template to take that into account is an idea, although it's possible the position info is useless there.}

The first thing to note is how the recursive call to \code{foldr} is contracted by replacing the original function application with a call to the $\apptemplate$ template of the \code{foldr} function definition.
From the original code, extra information is generated that is passed to the $\apptemplate$ template. 
The placeholders in the above example represent the following extra information:

\begin{itemize}
	\item $ctrt$: The contract that will be used to assert the original function. Details of the generation of the contract are found in the next section (\ref{generation-of-final-contracts}).
	\item $pos$: A tuple of the line and column position of the function application. It is is used to generate specific feedback at runtime in case of a contract violation.
	\item $p1...n$: Line and column position information is generated for each argument applied to the original function application, again used for specific feedback.
\end{itemize}

\subsubsection{Patterns representing functions are already contracted}

It may puzzle you why the application of \code{f} is not transformed in the same manner.
This is because it is a \textit{pattern} available in the left-hand side of the function definition.
It is a call to a locally-available function that has already been contracted.

To clarify, let us look at this example.
The following expression:

\begin{lstlisting}
foldr insert [] [5,4,7,0,10]
\end{lstlisting}

is transformed into the following one:

\begin{lstlisting}[mathescape]
__app_foldr ($p1$,__contracted_insert $ctrt$ $pos$) ($p2$,[]) ($p3$,[5,4,7,0,10])
\end{lstlisting}

Because \code{insert} is a function that does not yet have any arguments applied to it, it is replaced by its $\ctrttemplate$ counterpart.

%\todo{What about partially-applied functions? I think we have to wrap these with lambdas and put in "unknown" positions and then use the app versions, but that would probably not go well with the contract types.}

As you can see, the $\ctrttemplate$ template of \code{insert} is passed to the $\apptemplate$ template of \code{foldr}.
There, the contracted version of \code{insert} is annotated with detailed information and wrapped so that it can be applied with regular function application instead of using the \code{appParam} function from the \textit{typed-contracts} library.
Hence, the $pattern$ \code{f} in \code{\underline{\hspace{1.5em}}final\_foldr} in our previous example does not have to be transformed again.

\subsubsection{Type difference between contracted and regular functions}

In \code{\underline{\hspace{1.5em}}final\_foldr}, {\code{f} has a regular function type (\code{a $\rightarrow$ b $\rightarrow$ b}), but \code{\underline{\hspace{1.5em}}app\_foldr} expects a contracted version of \code{f} with the type \code{a $\rightarrowtail$ b $\rightarrowtail$ b}.
So, the $\finaltemplate$ template includes a new pattern for each function argument present in the original function definition.
In the case of \code{foldr}, this is only \code{f}.
The original pattern is prefixed with \code{\underline{\hspace{1.5em}}ctrt} and added to the function definition.

\subsection{\apptemplate}

This template is given information for use in feedback, wraps it appropriately using \code{appParam}, and passes it to the $\ctrttemplate$ template of the function definition.

Let us examine the template:

\begin{lstlisting}[mathescape]
__app_X ctrt posinfo $argument$ $patterns$ = $applied$ $arguments$
\end{lstlisting}

%The patterns ctrt and posinfo appear here again: both are passed to the \_\_contracted version of the function. Note again that this generated function is polymorphic with respect to its contract.

The placeholders \textit{argument patterns} and \textit{applied arguments} are relatively simple:

\begin{itemize}
	\item \textit{argument patterns} generates a tuple for each argument, containing the position information of the argument and the argument itself.
	\item \textit{applied arguments} uses this extra information to provide richer feedback at runtime and applies the arguments to the $\ctrttemplate$ template of the function.
\end{itemize}

Let us take the following example:

\begin{lstlisting}
g f x = f x
\end{lstlisting}

which generates the following code:

\begin{lstlisting}
__app_g ctrt posinfo (posf,f) (posx,x) =
 appParam (appParam (__contracted_g ctrt posinfo) (show f ++ generatePositionData posf) f) (show x ++ generatePositionData posx) x
\end{lstlisting}

The $\ctrttemplate$ template of the function is fed arguments using \code{appParam}, and are accompanied by feedback strings containing the argument as a string and its position in the source code.


\subsection{\ctrttemplate}

The final template, $\ctrttemplate$, constructs an assertion with the contract provided for a function definition \code{X}.

Let us inspect the template:

\begin{lstlisting}[mathescape]
__contracted_X ctrt posinfo = assertPos $(function$ $info)$ 
 (generatePositionData posinfo) ctrt funs
  where funs = $(contracted$ $function$ $definition)$
\end{lstlisting}

The placeholders represent the following:

\begin{itemize}
	\item \textit{function info}: A string that informs the user which function violated its contract, and if that function is higher-order or not.
	\item \textit{contracted function definition}: Using the \code{fun} function, a function is lifted to a contracted version.
\end{itemize}

The latter placeholder benefits from a few examples.
Here is what the contract version of the identity function looks like:

\begin{lstlisting}[mathescape]
fun ($\lambda$x $\rightarrow$ __final_id x)
\end{lstlisting}

For each argument, an extra layer of the \code{fun} function is applied to capture them and make them available to the original function.

\subsubsection{Functions as arguments to higher-order functions}

A function argument is slightly more involved, as it must be applied to its arguments using \code{appParam}.
For example, the code snippet

\begin{lstlisting}
g f x = f x
\end{lstlisting}

generates the following for the \textit{contracted function definition} placeholder:

\begin{lstlisting}[mathescape]
(fun ($\lambda$f $\rightarrow$ (fun ($\lambda$x $\rightarrow$ __final_g f ($\lambda$a $\rightarrow$ (appParam f $info$ a)) x))))
\end{lstlisting}

Note how \code{a} is captured and applied to \code{f} using \code{appParam}.
This is because \code{f} is a contracted function that was passed to the higher-order function.

\subsubsection{Two versions of function arguments}

Because \code{a} is captured using a lambda function, the type of the expression \code{($\lambda$a $\rightarrow$ (appParam f $info$ a))} is \code{a $\rightarrow$ a}, and can be used as a "regular" function in \code{\underline{\hspace{1.5em}}final\_g}.

\code{f}, whose type is \code{a $\rightarrowtail$ a}, is also provided to \code{\underline{\hspace{1.5em}}final\_g} unwrapped, in the case that a higher-order function takes \code{f} as an argument.
A good example of this is that of \code{foldr}:

\begin{lstlisting}[mathescape]
__final_foldr __ctrtf f b (x:xs) = f x (__app_foldr $ctrt$ $pos$ ($p1$,__ctrtf) ($p2$,b) ($p3$,xs))
__final_foldr __ctrtf f b [] = b
\end{lstlisting}



\section{Generation of final contracts}
\label{generation-of-final-contracts}

In this section, we illustrate an important limitation in the substitutions generated by Algorithm \CW ~and propose a solution to this limitation.
This limitation manifests itself when generating code for a library.
We have seen how templates for the \textit{typed-contracts} library are filled out, but it is not yet clear how the intermediate contract language is translated to a \textit{typed-contracts} contract.
Hence, that is what we start with before moving on to the limitation.

\subsection{Translation of intermediate contract language to \textit{typed-contracts} library}

Because the intermediate contract language is inspired by the notation used by the \textit{typed-contracts} library, translation between the two is simple.

The $true_i$ and $false_i$ contracts are translated into the \code{true} and \code{false} functions, respectively.
The index $i$ is only relevant to contract inference, so it is discarded.

The contract arrow ($\rightarrowtail$), functor ($\functor$) and bifunctor ($\bifunctor$) translate directly to the \textit{typed-contracts} library. 

At the moment, $literal_i$ contracts are translated into \code{true} contracts. Stutterheim's thesis suggests constant expression contracts as a better candidate for translation, but notes that extra program analysis is required to safely replace a simple \code{true} contract with a constant expression one.

Finally, user-defined concrete contracts only exist as a string in the intermediate contract language.
Translation is done simply by printing that string when generating the code, as the string is the identifier of a contract defined outside of the generated code.

Now that it is clear how translation works, we explain the limitation in Algorithm \CW  ~and how doing the translation we have just discussed at runtime proves troublesome.


\subsection{The monomorphic Algorithm \CW}
\label{subsection:monomorphic-algo-cw}

Algorithm \CW ~contains a severe limitation: every generated substitution is placed in a global set.
This set is then used to generate the final contract of an expression $e$ during code generation by applying the substitutions to the inferred contract of $e$.
The limitation presents itself when we apply a function \code{f} to two different arguments with different contracts:

\begin{lstlisting}[caption=An example code snippet that may generate incorrect code when using substitutions from Algorithm \CW.,label=code:incorrectgeneratedcode]
f x = [x]
z = (f 'a', f 5)
\end{lstlisting}

If we leave the contract environment $\Gamma$ empty, both \code{'a'} and \code{5} receive a $true$ contract, say, $true_1$ and $true_2$.
During inference, these contracts are unified and generate a substitution indicating they refer to the same contract.
In the end, the contract of \code{z} is as follows:
\begin{lstlisting}[mathescape]
true$_0$ $\bifunctor$ (true$_3$ $\functor$ true$_1$, true$_4$ $\functor$ true$_2$)
\end{lstlisting}
Because $true$ contracts are translated into the \code{true} \textit{typed-contracts} contract, no runtime or compilation error occurs.

But if we seed $\Gamma$ with an initial contract, the story is entirely different!
The contract of \code{z} is now set to the following:

\begin{lstlisting}[mathescape,label=env:contractz,caption=Contract environment $\Gamma$ is now seeded with a contract for \code{z}.]
$\Gamma$(z) = true$_0$ $\bifunctor$ (true$_1$ $\functor$ isChar, true$_2$ $\functor$ isNum)
\end{lstlisting}

For the rest of the identifiers and literals, the following contracts are constructed by Algorithm \CW:

\begin{lstlisting}[mathescape]
$\Gamma$(x) 	= true$_4$
$\Gamma$(f) 	= (true$_4$ $\rightarrowtail$ (true$_3$ $\functor$ true$_4$)) 
$\Gamma$('a') 	= true$_5$
$\Gamma$(5) 	= true$_6$
\end{lstlisting}

The relevant unifications of \code{f 'a'}, \code{f 5} and \code{z} are as follows:

\begin{lstlisting}[mathescape]
-- Unification of first argument of f with 'a'
unify (true$_4$) (true$_5$)

-- Unification of first argument of f with 5
unify (true$_4$) (true$_6$)
\end{lstlisting}

We obtain the following substitutions:

\begin{itemize}
	\item \code{true$_4$ $\mapsto$ true$_5$}
	\item \code{true$_4$ $\mapsto$ true$_6$}
\end{itemize}

We can apply these substitutions in left-to-right or right-to-left order to the contract of the right-hand side of z, which is 

\code{(true$_7$ $\bifunctor$ true$_3$ $\functor$ true$_4$, true$_3$ $\functor$ true$_4$)}. 
$true_7$ is a fresh contract:

\begin{itemize}
	\item left-to-right: \code{(true$_7$ $\bifunctor$ (true$_3$ $\functor$ true$_5$, true$_3$ $\functor$ true$_5$))}
	\item right-to-left: \code{(true$_7$ $\bifunctor$ (true$_3$ $\functor$ true$_6$, true$_3$ $\functor$ true$_6$))}
\end{itemize}

What happens when we unify either of these with the contract for \code{z}?

\begin{lstlisting}[mathescape]
unify (true$_0$ $\bifunctor$ (true$_1$ $\functor$ isChar, true$_2$ $\functor$ isNum))
      (true$_7$ $\bifunctor$ (true$_3$ $\functor$ true$_5$, true$_3$ $\functor$ true$_5$))
\end{lstlisting}

Relevant substitutions:

\begin{itemize}
	\item \code{true$_5$ $\mapsto$ isChar}
	\item \code{true$_5$ $\mapsto$ isNum}
\end{itemize}
      
\begin{lstlisting}[mathescape]
unify (true$_0$ $\bifunctor$ (true$_1$ $\functor$ isChar, true$_2$ $\functor$ isNum))
      (true$_7$ $\bifunctor$ (true$_3$ $\functor$ true$_6$, true$_3$ $\functor$ true$_6$))
\end{lstlisting}

Relevant substitutions:

\begin{itemize}
	\item \code{true$_6$ $\mapsto$ isChar}
	\item \code{true$_6$ $\mapsto$ isNum}
\end{itemize}

Here, the limitation becomes apparent: regardless of how we apply these substitutions, one of the contracts of expressions \code{f 'a'} and \code{f 5} will always be incorrect!
If we apply the substitutions left-to-right, the expression \code{f 5} is given the contract \code{true$_1$ $\functor$ isChar}. Doing it right-to-left provides \code{f 'a'} with the contract \code{true$_1$ $\functor$ isNum}.

In both instances, either a compile-time or a runtime error occurs.
This breaks Stutterheim's proposition that \textit{"(an) inferred contract will never fail assertion for that expression"} (\cite{Stutterheim:2013:thesis}, proposition 6). 

In this manner, Algorithm CW ~is monomorphic: the inferred contract of a function may constrain the acceptable values of an argument to a static subset of what the argument should actually be able to accept.

\subsubsection{Proposed solution: global and local substitution lists}

Instead of a single, global set of substitutions that is applied to every contract during translation, we keep track of a single global list of substitutions and several local lists.
Contract variables are also given a flavour of global or local: $true_i$ contracts are global, concrete contracts are local.

Whenever unification between two contracts takes place, the resulting substitutions are split up in a global and local group:
\begin{itemize}
\item The global group holds all substitutions that go from global contract variables to other global contract variables.
\item The local group holds all substitutions that go from global contract variables to local contract variables, as well as those that go from local contract variables to other local contract variables.
\end{itemize}

The global group is added to the global substitution list.
The local group is added to the local substitution list, which already contains the parent's local substitution list.
In other words, the global group travels up the AST towards the top, and the local group travels downwards into the child nodes of the node where unification took place.

\subsubsection{Applying global and local substitution lists}

The algorithm for calculating the final contract from these lists is comprised of four steps.
First, look up the initial contract $c_{initial}$ in the contract environment $\Gamma$.

Second, apply the global substitution list $s_{global}$ to $c_{initial}$ until a fixed point is reached or until $n+1$ applications have taken place, where $n$ is the number of substitutions in the global list. 
This yields $c_{global}$.
For those interested, a more detailed description of this application can be found in section \ref{futurework:efficientsubstalgo}.
The reason why the substitutions must be applied up to $n+1$ times is because, in our language, the ordering of function declarations is random, but the order in which the generated substitutions must be applied is not.
Stutterheim's language uses nested let-expressions to introduce multiple function declarations, which means the order of the generated substitutions is always correct, so it did not have to perform this search.

As the third step, the local substitution list $s_{local}$ is updated to reflect the changes in $c_{initial}$ that have been introduced by $s_{global}$.
This is done by applying $s_{global}$ to $s_{local}$ up to $n+1$ times until a fixed point is reached, producing $s_{updated}$.

Finally, $s_{updated}$ is applied to $c_{global}$ in the same manner until a fixed point is reached, resulting in $c_{final}$.


%It is this contract that is translated into a \textit{typed-contracts} contract and placed in the generated code.

%A more abstract solution is this: generate a deterministic finite state machine from $s$ and $v_{orig}$:
%\begin{description}
%	\item{$\sum$} = The unique set of contract variables in $s$.
%	\item{$S$} = The unique set of contract variables in $s$.
%	\item{$s_0$} = $v_{orig}$.
%	\item{$\delta$} = The substitution set $s$.
%	\item{$F$} = All contract variables in $s$ that occur on the right-hand side of a substitution.
%\end{description}
%
%Now, step through the list of substitutions $s$, interpreting $v_a$ $\mapsto$ $v_b$ as follows: if $v_a$ equals the current state we are in, accept $v_b$ as a symbol and transition to state $v_b$.
%When the list is empty, 

At first, it appears logical to apply these substitutions during code generation, and not during runtime, but this is not optimal.
To see why, let us look at the code generated by this example:

\begin{lstlisting}[caption=Expanded version of listing \ref{code:incorrectgeneratedcode}.]
f x = g x
g x = [x]
z = (f 'a', f 5)
\end{lstlisting}

The example has been expanded to include function \code{g}, which is called by \code{f}.
Our code generation system for the \textit{typed-contracts} library produces the following \finaltemplate ~code for \code{z}, \code{g} and \code{f} (we omit the line and column position information):

\begin{lstlisting}[caption=Output of code generation for the \textit{typed-contracts} library.,mathescape]
__final_f x = __app_g (c1 $\rightarrowtail$ (c2 $\functor$ c1)) x
 where c1 = true
       c2 = true
__final_g x = [x]
__final_z = (__app_f (isChar $\rightarrowtail$ (true $\functor$ isChar)) 'a', __app_f (isNum $\rightarrowtail$ (true $\functor$ isNum)) 5)
\end{lstlisting}

Calling the contracted version of \code{f} will call the contracted version of \code{g}, but with an initial contract!
In other words, the local substitutions that made the contract passed to \code{\_\_app\_f} more specific, are not utilized by \code{\_\_app\_g}.
The solution appears trivial: pass the local substitutions as another argument to the \apptemplate ~and \ctrttemplate ~templates and apply them to the initial contract at runtime.

\subsubsection{Applying substitutions at runtime}

Unfortunately, it is not so simple.
Doing substitutions at runtime instead of statically means a runtime translation is necessary between the intermediate contract language and the \textit{typed-contracts} contract datatype, because the substitutions only work on the intermediate contract language.
The targeted library expects a contract in its own datatype, of course.
The intermediate contract language is modeled as a simple data type automatically generated by the Utrecht University Attribute Grammar Compiler (UUAGC) without a phantom type, and \textit{typed-contracts}'s datatype is a GADT with a phantom type used for a type-level representation of the contract.
Conversion between the two means we need to be able to tell what this phantom type should be. This is especially a problem when we need to convert between user-defined concrete contracts (\code{Prop} and \code{PropInfo}), because each of these contracts may have a different phantom type and assorted type class constraints, and the only information available in the AST datatype equivalent is a \code{String}.

Several attempts were made to provide a runtime translation function, but none were initially successful.
Due to time constraints, we defer this translation method as future work.
Section \ref{futurework:runtimetranslation} provides an overview of the attempts and promising methods.

The current code generation system generates monomorphic code that may fail when a contracted function is applied to different contracts.

\section{Providing richer feedback}

We investigate how feedback towards the user can be improved in this section.

\subsection{Modifications to \textit{typed-contracts} library}
\label{modificationstotypedcontracts}
In order to provide adequate feedback to the user, we modify the \textit{typed-contracts} library by Hinze et al. \cite{Hinze06typedcontracts} to produce more specific feedback in a language that the user can understand.
The original library code provides error messages that refer to contract violations and (higher-order) blame of expressions, concepts that are foreign to the average user and thus do not provide any useful feedback.

Here is an example of the feedback provided by the original library:

\begin{lstlisting}[mathescape]
inc :: Int $\rightarrowtail$ Int
inc  = assert "inc" (nat $\rightarrowtail$ nat) (fun ($\lambda$n $\rightarrow$ n + 1))

> app inc 1 (-5)
> *** Exception: contract failed: the expression labelled `1' is to blame.
\end{lstlisting}

\subsubsection{Type position information}

To improve this rudimentary feedback, we require position information that records the position of an argument (or result) in a type.
We record this information in a tuple:

\begin{lstlisting}
type PosInfo = (Int,Int)
\end{lstlisting}

For example, the position $(0,1)$ indicates the first argument of a function that has one argument.
The position $(1,1)$ indicates the result of such a function.

Using this information, it is possible to produce highly specific feedback messages:

\begin{lstlisting}[caption=Code that generates text indicating the location of the problem.]
posInfoText (pos,arity) | pos < arity  = "The " ++ showPos (pos+1) ++ " supplied argument of this function "
                        | pos == arity = "The result of this function "
                        | (pos,arity) == (-1,-1) = "An unknown position "

showPos p | p == 1 = "first"
          | p == 2 = "second"
          | p == 3 = "third"
          | p == 4 = "fourth"
          | p == 5 = "fifth"
          | p == 6 = "sixth"
          | otherwise = show p
\end{lstlisting}

\subsubsection{Using the type position information}

The \code{Contract} GADT is modified to include the \code{PropInfo} constructor, which takes an additional argument: a function that, given type position information of which argument or result that the property is asserting, returns an appropriate error message:

\begin{lstlisting}[mathescape]
PropInfo   ::  (aT $\rightarrow$ Bool) $\rightarrow$ (PosInfo $\rightarrow$ String) $\rightarrow$ Contract aT
Prop       ::  (aT $\rightarrow$ Bool) $\rightarrow$ Contract aT
\end{lstlisting}

Here is a usage example of \code{PropInfo}:

\begin{lstlisting}[mathescape]
isBiggerThan_prop = PropInfo ($\lambda$x $\rightarrow$ fromEnum x > 5 ) ($\lambda$p $\rightarrow$ mkErrorMsg p "the number must be larger than five.")
\end{lstlisting}

If this property were to be asserted on the first argument of a function and was violated, it would generate the following error message:

\begin{quote}
\textit{"The first supplied argument of this function does not fulfill the following property: the number must be larger than five."}
\end{quote}

We add the functions \code{assertPos} and \code{assert''} to the \textit{typed-contracts} library to record this type position information.
For brevity, we omit the definitions of \code{makeLoc} and \code{Def}.
These can be found in the \textit{typed-contracts} library source code.

\begin{lstlisting}[mathescape]
assertPos :: String $\rightarrow$ String $\rightarrow$ Contract a $\rightarrow$ a $\rightarrow$ a
assertPos s ext c = assert$"$ c (0, ctrtarity c) (makeloc (Def (s ++ ext)))
 where
  ctrtarity :: Contract a $\rightarrow$ Int
  ctrtarity (Function c1 c2) = 1 + ctrtarity (c2 undefined)
  ctrtarity _                = 0
\end{lstlisting}

\subsubsection{External feedback}

\code{assertPos}'s purpose is twofold: to initialize the type position information, and to accept an additional feedback string \code{ext}.

Because the \code{app} function is responsible for providing a location label in the form of an integer, it makes sense to define a version of \code{app} that accepts an additional feedback string instead of an integer: \code{appParam}.

\begin{lstlisting}[mathescape]
app :: (a $\rightarrowtail$ b) $\rightarrow$ Int $\rightarrow$ a $\rightarrow$ b
app f loc x = apply f (makeloc (App loc)) x

appParam :: (a $\rightarrowtail$ b) $\rightarrow$ String $\rightarrow$ a $\rightarrow$ b
appParam f s x = apply f (makeloc (Def s)) x
\end{lstlisting}

The use for these extra feedback strings is discussed in the next subsection.

\subsection{External library-agnostic feedback}
\label{codegeneration}

Along with improvements to the \textit{typed-contracts} library, we have identified several techniques for generating library-agnostic feedback through abstract syntax tree analysis and modification.

\subsubsection{Dynamic representation of values using \code{Show} class}
The most robust way of displaying a value is through use of the \code{Show} typeclass.
The natural caveat one thinks of is the lack of a \code{Show} instance for terms such as functions.
Circular or infinite data structures are also troublesome.

So, when generating code that relies on \code{Show} instances, one must ensure that there are no datatypes without a \code{Show} instance, and that circular or infinite data structures are not present.

In our particular situation, we assume that every argument has a \code{Show} instance. Because QuickCheck should not generate infinite structures (quite the contrary!), this appears to be a reasonable assumption.

\code{Show} instances for functions would still be required, but those can be provided:

\begin{lstlisting}[mathescape]
instance Show (a $\rightarrowtail$ b) where
	showsPrec a = showString "<function>"
\end{lstlisting}

\subsubsection{Static string representation of functions}
In the event of a contract violation inside a higher-order function, it is possible that the offending value is a function.
But providing a meaningful \code{Show} instance for the function type is impossible.
How can this limitation be amended?
One possibility is to generate a static string representation of each argument and use that in the feedback.
For instance, the following example:

\begin{lstlisting}[mathescape]
f g x = g x
z = f id 1
\end{lstlisting}

would become

\begin{lstlisting}[mathescape]
f g x = g (x,"x")
z = f (id,"id") (1,"1")
\end{lstlisting}

However, a string representation loses all notion of the original structure.
In the case of functions, this is not a problem, but structures such as lists suffer.
Let us assume we apply the \code{map} function to an appropriate function and the list \code{[1,2,3]}.
Code is generated that replaces the original argument with the tuple \code{([1,2,3],"[1,2,3]")}.
The \code{map} function then applies its function argument to the first item in the list.
This list item causes a contract violation, but the only visual information available is a string representation of the entire list.
Clearly, this catch-all approach does not work.

By defining a new typeclass \code{ShowFunc}, we can circumvent this issue while still making use of the statically generated string representations:

\begin{lstlisting}[mathescape]
class ShowFunc a where
 showFunc :: String $\rightarrow$ a $\rightarrow$ String
 
instance (Show a) $\Rightarrow$ ShowFunc a where
 showFunc _ a = show a
 
instance ShowFunc (a $\rightarrow$ b) where
 showFunc rep _ = rep
\end{lstlisting}

Unfortunately, user-defined typeclasses are currently unsupported by Helium, so this technique is not applicable to us.

\subsubsection{Identifying a function as higher-order}

By inspecting the type of a function, it is possible to inform the user if the contract violation was caused by a higher-order function or a first-order function.

\subsubsection{Dynamic generation of line and column numbers of an expression}

If the abstract syntax tree provides them, extracting line and column numbers and putting them in the modified AST as a string is trivial and a highly valuable way of improving feedback.

\subsection{Example of detailed feedback for \textit{typed-contracts} library}

While we are unable to say what function caused the contract violation in a higher-order function due to the lack of user-defined typeclasses, we can indicate which arguments of both the higher-order function and the function argument failed.
We use this information to generate highly detailed feedback, as can be seen with this snippet of generated code:

\begin{lstlisting}
g f x = f x
\end{lstlisting}

becomes

\begin{lstlisting}[caption=Detailed feedback is generated when applying the function argument in a higher-order function.,label=listing:detailedfeedback,mathescape]
(fun ($\lambda$f $\rightarrow$ (fun ($\lambda$x $\rightarrow$ g ($\lambda$a $\rightarrow$ (appParam f (concat "the application of the higher-order function 'g' ",(generatePositionData posinfo),". g has a function as its first argument."," The first argument of that function",", namely ",show a]) a)) x))))
\end{lstlisting}

Note how the argument \code{x} is applied to \code{f} with a very detailed feedback message that incorporates the following elements:

\begin{itemize}
	\item Whether the function is higher-order or not.
	\item Run-time generation of line and column number information.
	\item Identification of the position of \code{f} in the type of \code{g}. This is a duplication of the type position information functionality added to the \textit{typed-contracts} library.
	\item Identification of the position of \code{x} in the type of \code{f}.
	\item Run-time representation of the offending value using the \code{Show} typeclass.
\end{itemize}

In the case of a contract violation, the feedback could look like this:

\begin{quote}
\textit{
A part of your code, or a supplied argument to a function, does not fulfill a required property. This occurred at the application of the higher-order function 'g' at line number 1, column number 1. g has a function as its first argument. The first argument of that function, namely -5, does not fulfill the following property: the number must be a natural number.
}
\end{quote}

From this feedback, the user can deduce the following:
\begin{itemize}
\item Which application of a higher-order function caused the contract violation.
\item Which argument of the higher-order function is the function that caused the contract violation.
\item Which argument of that function caused the violation.
\item Possibly, the offending value.
\end{itemize}

\subsection{Reusing QuickCheck properties}
\label{subsection:reusing-qc-props}

The Ask-Elle programming tutor supports QuickCheck properties that are executed to verify the correctness of code that cannot be reduced to a known strategy.
A very interesting idea is to derive contracts from such properties automatically and use them to construct contracts that can be used to contract the result of the function.
However, remember that we are limited to non-dependent contracts, so we only have access to a single argument or the result of the function in a contract.
Most QuickCheck properties, however, refer to one or more arguments of the function.

A simple QuickCheck property of the palindrome function illustrates the problem well:

\begin{lstlisting}[mathescape]
prop_Main = $\lambda$xs $\rightarrow$ whenFail (putStrLn "This function does not correctly check for palindromes.") ( (palindrome xs) == (reverse xs == xs) )  
\end{lstlisting}

The input \code{xs} must be captured with a dependent contract before it can be referred to.
This means that we are unable to derive a contract useful for contract inference.

The only QuickCheck properties that are of use to derive a contract from, are properties that only refer to the result of the function.
For these kinds of properties, we can construct a contract of the following form:

\begin{lstlisting}[mathescape]
PropInfo ($\lambda$result $\rightarrow$ ...)
\end{lstlisting}

As you can see, we are severely limited in the the range of properties that we can use.
For this reason, we do not develop a contract deriving mechanism for QuickCheck properties and leave it as future work.

\chapter{Results and future work}
\label{futurework}

This chapter presents the results of our work in section \ref{section:results} in the form of several comparisons between the feedback provided by Ask-Elle and the feedback provided by our system given the same input.
The rest of the chapter discusses interesting avenues for future work.

\section{Results}
\label{section:results}

Originally, our work was to be integrated into the Ask-Elle programming tutor, but time constraints have prevented this.
Nonetheless, it is possible to emulate the effect our new source of feedback by taking student input (comprised of source code) and system output (comprised of QuickCheck counterexamples) stored by the Ask-Elle system and using the input and output to generate our own feedback (if any):

\begin{enumerate}
	\item First, we create a contract derived from the QuickCheck properties that were used to generate the counterexample and place the counterexample in the contract as described by Stutterheim's thesis in subsection 3.5.1, \textit{"Eliminating dependent contracts"}.
	\item This contract is given to the contract environment $\Gamma$ and used during contract inference, generating substitutions that may place the counterexample-laden contract at function applications.
	\item Then, we run the student's input through the code generation system to generate contracted code.
	\item We apply the contracted version of the code to the counterexample.
	\item A contract violation occurs at a specific function application, providing detailed feedback.
\end{enumerate}

Automation of the first step is discussed in subsection \ref{subsection:reusing-qc-prop}. The rest of the steps are not as troublesome to automate.

\subsection{Strengths and weaknesses}

We have performed several tests to determine the efficacy of our feedback compared to the original Ask-Elle feedback in identifying the source of a programming error.

\subsubsection{Lack of function applications}

Because contract violations only occur during assertion, code without any function applications does not benefit from our detailed feedback.
For example, the following input will not generate more detailed feedback compared to the original Ask-Elle feedback:

\begin{lstlisting}[caption=Student input 1]
myreverse [] = []
myreverse [x,y] = [x,y]
myreverse xs = ?
\end{lstlisting}

\begin{lstlisting}[caption=Ask-Elle's response to input 1]
You have not sorted correctly.
Counterexample arguments: [1,0]
\end{lstlisting}

In order to provide our own feedback, we go through the steps outlined above.
Here is the original QuickCheck property:

\begin{lstlisting}[mathescape]
prop_Main = $\lambda$xs $\rightarrow$ prop_Elems xs .&&. prop_Model xs

prop_Elems = $\lambda$xs $\rightarrow$ whenFail (putMsg "Input and output list do not contain the same elements") (and $\$$ map ((flip elem) xs) (myreverse xs))

prop_Model = $\lambda$xs $\rightarrow$ whenFail (putMsg "You have not sorted correctly") (myreverse xs == reverse xs)
\end{lstlisting}

And our manually derived contract equivalent:

\begin{lstlisting}[mathescape]
prop_Elems = PropInfo ($\lambda$xs $\rightarrow$ (and $\$$ map ((flip elem) xs) ([1,0]) )) 
 ($\lambda$ $\rightarrow$ mkErrorMsg p "Input and output list do not contain the same elements.")
              
prop_Model = PropInfo ($\lambda$xs $\rightarrow$ ([1,0] == reverse xs)) 
 ($\lambda$ $\rightarrow$ mkErrorMsg p "You have not sorted correctly.")

prop_Main = prop_Elems & prop_Model

myreverse_ctrt  = (true $\functor$ true) $\rightarrowtail$ prop_Main
\end{lstlisting}

Then, we run the contract inference algorithm and generate contracted code:

\begin{lstlisting}[mathescape]
__final_myreverse [] = []
__final_myreverse [x,y] = [x,y]
__final_myreverse xs = ?

__contracted_myreverse ctrt posinfo =
    assertPos "At the application of the function 'myreverse'" (generatePositionData posinfo) ctrt funs
    where funs = (fun ($\lambda$__x01 $\rightarrow$ __final_myreverse __x01))
        
__app_myreverse ctrt posinfo (posa,a) =
    (appParam (__contracted_myreverse ctrt posinfo) (show a ++ generatePositionData posa) a)
\end{lstlisting}

Here, the problem becomes apparent: because there are no function applications in the original code, no contracting has been done whatsoever! 
Of course, we can manually apply the contract with bogus information:

\begin{lstlisting}[mathescape]
__app_myreverse myrevers_ctrt (Just (0,0)) ((Just (1,1)),[1,0])
\end{lstlisting}

Naturally, the feedback is not very useful:

\begin{quote}
\textit{A part of your code, or a supplied argument to a function, does not fulfill a required property. This occurred at the application of the function 'myreverse' at line number 0, column number 0. The result of this function does not fulfill the following property: You have not sorted correctly.}
\end{quote}

\subsubsection{Limitations of QuickCheck properties}

In general, the QuickCheck properties used to describe the correct behaviour of the exercises in Ask-Elle are troublesome to correctly translate to a contract and often provide scarce information in their feedback, if any is present at all.

The QuickCheck property for the \code{repli} exercise, for example, provides no textual feedback whatsoever:

\begin{lstlisting}[mathescape]
prop_Main = $\lambda$xs n $\rightarrow$ n > 0 ==> concatMap (replicate n) xs == repli xs n
\end{lstlisting}

Furthermore, translation of this property to a contract is troublesome because of the need for a dependent contract to capture \code{n}, which Stutterheim illustrated to be unusable for this form of contract inference.

\subsubsection{Defining custom contracts}

In order to get the most out of the feedback potential that contract inference provides, contracts should be tailored to each exercise.
Of course, the validation code must be shared with QuickCheck.

Let us assume the student has just finished an insertion sort exercise, but a programming error has crept in:

\begin{lstlisting}[mathescape,numbers=left]
insert z zs = case zs of
                [] $\rightarrow$ [z]
                (z':zs') $\rightarrow$ in case z <= z' of
                                True $\rightarrow$ z' : z : zs'
                                False $\rightarrow$ z' : insert z zs'
foldr f b xs = case xs of
                [] $\rightarrow$ b
                (y:ys) $\rightarrow$ f y (foldr f b ys)
                
isort us = foldr insert [] us
\end{lstlisting}

The following QuickCheck property is checked, and fails:

\begin{lstlisting}[mathescape]
prop_Main = $\lambda$xs $\rightarrow$ whenFail (putStrLn "The list elements must be in ascending order.") (isOrdered xs)
\end{lstlisting}

QuickCheck reports a counterexample of \code{[0,1]}.

The tailored contract that is given to the contract inference algorithm is as follows:

\begin{lstlisting}[mathescape]
isort_ctrt = (true $\functor$ true) $\rightarrowtail$ (ord $\functor$ true)
 where ord = PropInfo ($\lambda$x $\rightarrow$ isOrdered x) ($\lambda$p $\rightarrow$ mkErrorMsg p "the list elements must be in ascending order.") 
\end{lstlisting}

Code is generated, and we apply \code{\underline{\hspace{1.5em}}final\_isort} to \code{[0,1]}, generating the following feedback:

\begin{quote}
\textit{A part of your code, or a supplied argument to a function, does not fulfill a required property. This occurred at the application of the function 'insert' at line number 10, column number 19. The result of this function does not fulfill the following property: the list elements must be in ascending order.}
\end{quote}

Now we know that the issue lies with the \code{insert} function and not with our definition of \code{isort} or \code{foldr}.
In this case, the extra information does not cut down the search space by a lot, but it is easy to imagine how this could be of great help in larger programs.

If we rectify the bug in the definition of \code{insert} (it should be \code{z : z' : zs'}) and introduce another by changing \code{z <= z'} to \code{z' <= z} and apply the counterexample again, we receive more detailed feedback:

\begin{quote}
\textit{A part of your code, or a supplied argument to a function, does not fulfill a required property. This occurred at the application of the function ':' at line number 4, column number 45. The result of this function does not fulfill the following property: the list elements must be in ascending order.}
\end{quote}

Now, we are brought closer to the bug, indicating something apparently wrong with the snippet \code{z' : zs'}: one of the elements is causing the list to no longer be ordered.
Unfortunately, we cannot get closer to the problem, as the contract inferred for the function application \code{(<=) z' z} is the identity contract \code{(true $\rightarrowtail$ (true $\rightarrowtail$ true))}.
Nonetheless, the detail of this feedback is much greater than that of Ask-Elle's combination of a counterexample and a description of the violated property, our system displaying the violation as close to the source as it is allowed by the definition of the contract defined for the exercise.

%Enriching our contract with more properties widens the catching net: adding the requirement that the resulting list be a permutation of the input list allows us to detect bugs that produce sorted (but smaller) lists.

\section{Integration with the Ask-Elle programming tutor}

Full integration of our work with the Ask-Elle programming tutor is not yet complete.
Our system is somewhat integrated with the Ask-Elle programming tutor, primarily for its syntax.
Full integration requires modifying the QuickCheck functionality in Ask-Elle to pass its counterexample to a function that constructs a contract used for inference.
Stutterheim proposes a way to capture the counterexamples generated by QuickCheck in the future work chapter of his thesis for this purpose: by wrapping the \code{quickCheck} function and storing the result in an \code{IORef}, it is possible to capture the counterexample and read it from the \code{IORef} when it is needed.

Automatic translation of QuickCheck properties to contracts may fail to make use of the capabilities contracts offer, as contracts derived from QuickCheck properties can only say something about the \textit{results}, and not about the \textit{inputs}.
Manually constructing a contract that uses the same validation code as the QuickCheck properties do can offer a greater contracting space.
The configuration files for exercises must be modified to include these contracts.

Furthermore, it will be necessary to run the code generation on the Prelude and any other modules that are used by exercises defined in Ask-Elle, so that the final contracts for all those functions are available for contract inference.
Just as Ask-Elle maintains a static list of all the types of the Prelude, a static list of all contracts could be made available, too.

For those interested, \textit{decoupling} our system from the Ask-Elle programming tutor is also feasible.
Our use of a type source tightly couples our system with the Helium compiler, but if a source of types can be found for a new language such as Haskell, porting it over would be a realistic goal.
Replacing the Ask-Elle syntax with the Helium syntax is also feasible, but will require some refactoring of the code generation system (mostly renaming).

\section{Adding support for user-defined datatypes to the initial contract generation algorithm}
\label{datatype-support-initial-contracts-algorithm}

As we have seen in subsection \ref{subsection:contractgeneration}, contracts can be derived from types that are useful in contract inference.
However, only a few types are currently supported by the conversion function.
Custom data constructors must be manually added.
A typeclass does not solve the need for manually adding conversions for new data constructors. 
Being able to look up data types instead of manually adding them is a more interesting idea.
It is possible to query the Helium compiler for a list of all available type constructors, functions, value constructors and operators in a program.
The Ask-Elle programming tutor also has a static list available in the file \code{Domain\textbackslash FP\textbackslash HeliumImportEnvs.hs}.
Both sources could be used to look up unknown type constructors, fetch their type, and construct a fitting contract.

\section{Runtime translation of intermediate contract language}
\label{futurework:runtimetranslation}

Subsection \ref{subsection:monomorphic-algo-cw} proposes splitting up generated substitutions into a global list and placing the other local substitutions into a local list unique to the node where unification took place.
This change makes it possible to correct a limitation present in Stutterheim's original contract inference algorithm.
However, application of the substitutions and translation of the final contracts must then be done at run-time.

Several ideas were tested to perform this translation:
\begin{itemize}
	\item \textbf{Add a phantom type to the data type representing the intermediate contract language.} The UUAGC system currently does not support this.
	\item \textbf{Use a typeclass.} This approach generates a similar problem to the one that we are trying to solve.
	\item \textbf{Use a typeclass + type synonyms.} Requires a lot of extra instances to properly work. Perhaps interesting when fully automated.
	\item \textbf{Use a typeclass + newtypes.} The most promising avenue of research.
	\item \textbf{Code duplication.} The nuclear approach.
\end{itemize}

\subsection{Add a phantom type to the data type representing the intermediate contract language}
The data type that represents the intermediate contract language is a data type automatically generated by the Utrecht University Attribute Grammar Compiler (UUAGC). 
Adding a phantom type to it would make conversion trivial.
Unfortunately, an option for adding phantom types to a UUAGC-defined data type could not be found.
Even if phantom types were supported, the generation code would have had to have been rewritten to use a nested tuple for the environment contract instead of a regular list, or use another form of heterogeneous lists.

\subsection{Use a typeclass}

\begin{lstlisting}[caption=Attempt at using a typeclass to recover the extra type information.,mathescape]
class ConvertContract a where
 convert :: Contract $\rightarrow$ (Contract a)

instance ConvertContract a where
 convert (CVar s _) = true
 convert (CProp s) = searchEnvTuple s envTuple

instance ConvertContract (a $\rightarrowtail$ b) where
 convert (CArr c1 c2) = ($\rightarrowtail$) (convert c1) (convert c2)

instance Bifunctor f $\Rightarrow$ ConvertContract (f a b) where
 convert (CBifunctor o il ir) = (convert o) $\bifunctor$ (convert il,convert ir)

instance Functor f $\Rightarrow$ ConvertContract (f a) where
 convert (CFunctor o i) = (convert o) $\functor$ (convert i)
 
testEnvTuple
  :: (Functor f, Ord d, Ord b, RealFrac e) $\Rightarrow$
     ((String, Contract (f c $\rightarrowtail$ [d])),
      ((String, Contract a),
       ((String, Contract [b]),
        ((String, Contract Char),
         ((String, Contract e), ([a], Contract f))))))
testEnvTuple = ( ("isort",sortCtrt), ( ("ctrue",true), ( ("ord",ord), ( ("isChar_prop",isChar_prop), ( ("isInt_prop", isInt_prop), ([], true) ) ) ) ) )
\end{lstlisting}

Because of the different phantom types, a nested tuple was needed to house the property environment, but the tuple lookup function refused to typecheck, as the typechecker tried to unify the different contracts.
Additionally, this solution suffers from the need for a type annotation so the compiler knows which instance to select.
Statically generating such an annotation would have been perfectly feasible, although it would have suffered from the same issue as the one we were trying to solve by doing the translation at run-time.

\subsection{Use a typeclass + type synonyms}
What about using type synonyms and the aforementioned typeclass?

\begin{lstlisting}[caption=Attempt at using type synonyms to choose the correct instances.,mathescape]
instance ConvertContract a where
  convert (CVar s _) = true
type IsIntProp a = a
instance RealFrac (IsIntProp a) $\Rightarrow$ ConvertContract (IsIntProp a) where
  convert (CProp p) | p == "isInt_prop" = isInt_prop
\end{lstlisting}

Unfortunately, when deciding an instance, any constraints are ignored, and because type synonyms are transparent to the compiler, these instances fully overlap.
Simon Peyton-Jones and Oleg Kiselyov do describe a way to use overlapping instances and functional dependencies to achieve this \cite{spj:online}, but it requires a lot of extra work for every property.
Automatic generation of these instances may be an interesting avenue.

\subsection{Use a typeclass + newtypes}

\begin{lstlisting}[caption=Attempt at using newtypes to choose the correct instances.,mathescape]
newtype IsIntProp a = IsIntProp a
instance RealFrac (IsIntProp a) $\Rightarrow$ ConvertContract (IsIntProp a) where
  convert (CProp p) | p == "isInt_prop" = isInt_prop
\end{lstlisting}

This seems to work, but it requires wrapping and unwrapping of values, which is incompatible with the generated code.
Recall the contracted version of \code{f}:

\begin{lstlisting}[mathescape]
__app_f ctrt x = appParam (__contracted_f ctrt) x
__contracted_f ctrt = assertPos "f" ctrt funs
    where
        funs = (fun ($\lambda$x $\rightarrow$ __final_f x))
__final_f x = __app_g (c1 $\rightarrowtail$ (c2 $\functor$ c1)) x
\end{lstlisting}

The value \code{x} would have to be unwrapped before it could be passed to \code{\_\_final\_f}, and these unwrapping functions would all have a different name.
A typeclass could be used to provide a singular function to wrap and unwrap newtypes.
Placing the generated code together with this typeclass in a single module and running it with GHC makes this the most interesting avenue to investigate.

\subsection{Code duplication}

A final "solution" that would not require the use of typeclasses, would have been to generate a monomorphic set of contracted functions for every single function application.
Naturally, this set would need to contain every single function that is called when evaluating that particular function application; a possibly daunting amount.
Importing other modules makes this solution even less feasible, as functions from those modules would also need to be included in the set.
Because of the multitude of issues, this solution was disregarded early in the process.

\section{More efficient algorithm for finding final contracts}
\label{futurework:efficientsubstalgo}

The algorithm to find a final contract uses a brute-force search, going through a substitution list up $(n+1)$ times, where $n$ is the number of substitutions in the list. 
This algorithm may become a bottleneck when it has to trudge through a very large global substitution list.
The optional addition of local substitution lists is not as troublesome, because they contain only substitutions that are relevant to that node.

The current algorithm goes as follows:

Given a contract variable $c_{orig}$ and a list of substitutions $s$, set $c_i$ to $c_{orig}$.
While you have not reached the end of $s$, search for a substitution that goes from $c_i$ to $c_j$.
If you encounter such a substitution, set $c_i$ to $c_j$.
When the end of $s$ has been reached, check if $c_{orig} = c_i$.
If yes, return $c_{orig}$ as the result.
Otherwise, recurse with $c_j$ and $s$.

Proving that this algorithm always terminates is easy.
When applying a list of substitutions to a contract $c$, there are two possible results: either the result is once again $c$, or it is $c'$.
In the first case, we are done.
In the second, we must recurse.

The question is, is it possible to construct a substitution loop in which we always recurse and never terminate?
The answer is no.

The proof is as follows:
assume a substitution list $s$ that only contains the substitution \code{c $\mapsto$ c$'$}.
When applying $s$ to $c$, we obtain $c'$.
Recursing, $c'$ is applied to $s$ again.
This time, $c'$ remains unchanged, so we are done.
Let us extend $s$ with substitution \code{c$'$ $\mapsto$ c}.
We apply $s$ to $c$, obtaining $c$ itself, because the substitutions cancel each other out.
So, we are done.
If we apply $s$ to $c'$, we obtain $c$.
Recursing, we end up in the previous case, so we are done as well.
Applying a substitution list $s$ that does not contain any substitutions that involve $c$ will naturally result in $c$ again, making all cases accounted for.

\section{Adding support for partially applied function arguments to higher-order functions in \textit{typed-contracts} code generation}

At the moment, function arguments to higher-order functions are assumed not to be applied at all.
These arguments are replaced by their $\ctrttemplate$ template.
Of course, it is possible to pass partially applied functions to a higher-order function.
To support such arguments, the generation code has to be modified to check if the function argument has been partially applied and, if so, replace it with its $\apptemplate$ template and wrap the applied values accordingly with \code{appParam}.
Just as extensive feedback is generated when applying the function argument to a value in the $\ctrttemplate$ template for a higher-order function (see listing \ref{listing:detailedfeedback}), so must similar feedback be generated for these arguments.

\section{Using paramorphisms to tackle dependent contracts}

Johan Jeuring provided an excellent idea to be able to run contract inference on some catamorphisms with dependent contracts by converting them to a paramorphism, which is a catamorphism that provides its function argument with the original input as well:

\begin{figure}[htps]
\begin{lstlisting}[mathescape]
para  :: (a $\rightarrow$ [a] $\rightarrow$ b $\rightarrow$ b) $\rightarrow$ b $\rightarrow$ [a] $\rightarrow$ b
foldr :: (a $\rightarrow$         b $\rightarrow$ b) $\rightarrow$ b $\rightarrow$ [a] $\rightarrow$ b

para  c n (x : xs) = c x xs (para c n xs)
foldr c n (x : xs) = c x    (foldr c n xs)
para  c n []       = n
foldr c n []       = n
\end{lstlisting}
\texttt{\scriptsize{Source: http://stackoverflow.com/questions/13317242/what-are-paramorphisms}}
\end{figure}

This functionality is of great use for dependent contracts that need access to the original argument, as can be seen in the following example code (courtesy of Johan Jeuring):

\begin{lstlisting}[mathescape]
-- GList      ::  Contract a $\rightarrow$ ([a] $\rightarrow$ Bool) $\rightarrow$ Contract [a]
sortc =  GList int (const True) $\rightarrowtail$ $\lambda$xs $\rightarrow$ GList int ($\lambda$r $\rightarrow$ nonDesc r && isPerm xs r)
isPerm xs ys = null (xs \\ ys)

sort_perm' :: Ord a $\Rightarrow$ [a] $\rightarrow$ [a]
sort_perm' =  foldr insert_notPerm []
insert_notPerm ::  Ord a $\Rightarrow$ a $\rightarrow$ [a] $\rightarrow$ [a]
insert_notPerm x []                    =  [x]
insert_notPerm x (y:ys)  |  x <= y     =  x:y:ys
                         |  otherwise  =  insert_notPerm x ys
                         
sort_permWrong        =  foldr insert_notPerm [] 
sort_permNotViolated  =  assert sortc sort_permWrong [3,2,4]
\end{lstlisting}

In the above example the input, \code{xs}, is needed in the \code{sortc} contract to be able to express the permutation property, but this introduces a dependent contract, which means the contract cannot be used for contract inference.

This is where the paramorphism comes in, as it provides that \code{xs} value.
The contract for the \code{para} function is, then:

\begin{lstlisting}[mathescape]
parac
  :: Contract a
     $\rightarrow$ ([a] $\rightarrow$ Bool)
     $\rightarrow$ ([a] $\rightarrow$ Contract b)
     $\rightarrow$ Contract ((a $\rightarrow$ [a] $\rightarrow$ b $\rightarrow$ b) $\rightarrow$ b $\rightarrow$ [a] $\rightarrow$ b)
parac a p b =   (a $\rightarrowtail$ $\lambda$x $\rightarrow$ GList a p $\rightarrowtail$ $\lambda$xs $\rightarrow$ b xs >- b (x:xs))
              >-  b []
              >-  GList a p
              $\rightarrowtail$ $\lambda$xs -> b xs
              
psort  =  para ($\lambda$x xs ys $\rightarrow$ insert_correct x ys) []
\end{lstlisting}

Unifying \code{sortc} and \code{parac} gives us:

\begin{lstlisting}[mathescape]
GList a   p             $\rightarrowtail$  $\lambda$xs $\rightarrow$ b xs
GList int (const True)  $\rightarrowtail$  $\lambda$xs $\rightarrow$ GList int ($\lambda$r $\rightarrow$ nonDesc r && isPerm xs r)

a   :=  int
p   :=  const True
b   :=  $\lambda$xs $\rightarrow$ GList int ($\lambda$r $\rightarrow$ nonDesc r && isPerm xs r)
\end{lstlisting}

Applying these substitutions, we see that \code{bT []} will get the contract:  

\begin{lstlisting}[mathescape]
GList int ($\lambda$r $\rightarrow$ nonDesc r && isPerm [] r)
\end{lstlisting}

And the contract for \code{insert} becomes:

\begin{lstlisting}[mathescape]
insertc'  =    int 
          $\rightarrowtail$  $\lambda$x  $\rightarrow$ GList int (const True) 
          $\rightarrowtail$  $\lambda$xs $\rightarrow$ GList int ($\lambda$r $\rightarrow$ nonDesc r && isPerm xs r)
          >-   GList int ($\lambda$r $\rightarrow$ nonDesc r && isPerm (x:xs) r)
cinsert_notPerm_violated = assert insertc' ($\lambda$x xs ys $\rightarrow$ insert_notPerm x ys) 3 [2,4] [2,4]
\end{lstlisting}

Note that by using a paramorphism instead of a catamorphism, \code{insert} is supplied with an argument it does not require, so it is wrapped in a lambda function and the superfluous argument is ignored.

How do we relate this contracted paramorphism to the original user's \code{foldr} call?
By defining \code{foldr} as a paramorphism, which is quite simple:

\begin{lstlisting}[mathescape]
pfoldr f e = para ($\lambda$x xs r $\rightarrow$ f x r) e
sort_perm''        =  pfoldr insert_notPerm []
sort_permViolated' =  assert sortc' sort_perm'' [3,2,4]
\end{lstlisting}

In short, this implies it is possible to convert some functions that use catamorphisms with dependent contracts, into paramorphisms with non-dependent contracts.

Some feedback problems do pop up: how do we meaningfully inform the user of a violated contract in  \code{($\lambda$x xs r $\rightarrow$ f x r)} ? 
And what if the \code{para} contract is violated, how do we report that?
It is possible to modify the feedback messages in contract generation to "cloak" the use of a paramorphism, but this has not yet been investigated further.

\chapter{Conclusion}
\label{chapter-conclusion}

The main objective of this thesis was the extension of Stutterheim's contract inference algorithm to the Helium-like Ask-Elle syntax and the construction of a code generation system with the goal to integrate it into the tutor and provide more detailed feedback to students.

To achieve this, a framework was constructed that links the contract inference algorithm with the code generation system.
Input to this framework consists of a program written in the Ask-Elle syntax, a slightly simplified version of the Helium functional programming language.
The framework first applies several transformations to the input, removing syntactic sugar and similar simplifications before it is passed to the contract inference algorithm and code generation system.

Our contract inference algorithm {Algorithm \CHW ~is based on Stutterheim's Algorithm \CW. Unlike \CW, \CHW ~uses a type source to simplify contract inference and focus on the inference uniquely required by contracts.

Stutterheim's code contained a proof-of-concept code generation system.
We expanded this system considerably to create a framework for generating code for the \textit{typed-contracts} contract library.
Many elements of the code generation system are library-agnostic, so generation interfaces for other contract libraries can be added with nearly no code duplication.

We identified a limitation of the generated code due to the way substitutions are collected and applied in Stutterheim's proof-of-concept code generation system.
A solution was devised and implemented in our system, but the last step, a run-time translation from the contract's data type used in Algorithm \CHW ~to the contract's data type of the targeted library, proved to be harder than expected.
We listed our attempts to this problem and highlighted the more promising candidates.
In the case that this translation problem is solved, the rest of our solution can be reactivated with some minor modifications to the substitution code.
At the moment, the limitation is still in effect.

Full integration with the Ask-Elle programming tutor was deferred as future work.
Through several examples, we showed how the feedback of our framework was equally or more detailed than the feedback of Ask-Elle when provided the same inputs.
Especially large programs benefit the most from our improved feedback, cutting down the programming error search space down to a single function and sometimes a single function application.
If possible, our feedback includes the value that caused the contract violation, a feature that is especially useful in recursive functions.

Decoupling our framework from Ask-Elle and making it available for the Helium language is also a possibility.
Replacing the Ask-Elle syntax with that of Helium would require some refactoring, but no significant changes to the framework would have to be made.
The result would be an automatic contract annotation framework for Helium, something that most certainly deserves further inquiry and research.

\bibliographystyle{plain}
\bibliography{bibliography}
\end{document}
